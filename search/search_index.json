{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Wildcard Match","text":""},{"location":"#overview","title":"Overview","text":"<p>Wildcard Match provides an enhanced <code>fnmatch</code>, <code>glob</code>, and <code>pathlib</code> library in order to provide file matching and globbing that more closely follows the features found in Bash. In some ways these libraries are similar to Python's builtin libraries as they provide a similar interface to match, filter, and glob the file system. But they also include a number of features found in Bash's globbing such as backslash escaping, brace expansion, extended glob pattern groups, etc. They also add a number of new useful functions as well, such as <code>globmatch</code> which functions like <code>fnmatch</code>, but for paths.</p> <p>Wildcard Match also adds a file search utility called <code>wcmatch</code> that is built on top of <code>fnmatch</code> and <code>globmatch</code>. It was originally written for Rummage, but split out into this project to be used by other projects that may find its approach useful.</p> <p>Bash is used as a guide when making decisions on behavior for <code>fnmatch</code> and <code>glob</code>. Behavior may differ from Bash version to Bash version, but an attempt is made to keep Wildcard Match up with the latest relevant changes. With all of this said, there may be a few corner cases in which we've intentionally chosen to not exactly mirror Bash. If an issue is found where Wildcard Match seems to deviate in an illogical way, we'd love to hear about it in the issue tracker.</p>"},{"location":"#features","title":"Features","text":"<p>A quick overview of Wildcard Match's Features:</p> <ul> <li>Provides an interface comparable to Python's builtin in <code>fnmatch</code>, <code>glob</code>, and     <code>pathlib</code>.</li> <li>Allows for a much more configurable experience when matching or globbing with many more features.</li> <li>Adds support for <code>**</code> in glob.</li> <li>Adds support for Zsh style <code>***</code> recursive glob for symlinks.</li> <li>Adds support for escaping characters with <code>\\</code>.</li> <li>Add support for POSIX style character classes inside sequences: <code>[[:alnum:]]</code>, etc. The <code>C</code> locale is used.</li> <li>Adds support for brace expansion: <code>a{b,{c,d}}</code> \u2192 <code>ab ac ad</code>.</li> <li>Adds support for expanding <code>~</code> or <code>~username</code> to the appropriate user path.</li> <li>Adds support for extended match patterns: <code>@(...)</code>, <code>+(...)</code>, <code>*(...)</code>, <code>?(...)</code>, and <code>!(...)</code>.</li> <li>Adds ability to match path names via the path centric <code>globmatch</code>.</li> <li>Provides a <code>pathlib</code> variant that uses Wildcard Match's <code>glob</code> library instead of Python's default.</li> <li>Provides an alternative file crawler called <code>wcmatch</code>.</li> <li>And more\u2026</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Installation is easy with pip:</p> <pre><code>$ pip install wcmatch\n</code></pre>"},{"location":"#libraries","title":"Libraries","text":"<ul> <li><code>fnmatch</code>: A file name matching library.</li> <li><code>glob</code>: A file system searching and file path matching library.</li> <li><code>pathlib</code>: A implementation of Python's <code>pathlib</code> that uses our own <code>glob</code> implementation.</li> <li><code>wcmatch</code>: An alternative file search library built on <code>fnmatch</code> and <code>globmatch</code>.</li> </ul>"},{"location":"fnmatch/","title":"<code>wcmatch.fnmatch</code>","text":"<pre><code>from wcmatch import fnmatch\n</code></pre>"},{"location":"fnmatch/#syntax","title":"Syntax","text":"<p>The <code>fnmatch</code> library is similar to the builtin <code>fnmatch</code>, but with some enhancements and some differences. It is mainly used for matching filenames with glob patterns. For path names, Wildcard Match's <code>globmatch</code> is a more appropriate choice. Not all of the features listed below are enabled by default. See flags for more information.</p> <p>Backslashes</p> <p>When using backslashes, it is helpful to use raw strings. In a raw string, a single backslash is used to escape a character <code>r'\\?'</code>.  If you want to represent a literal backslash, you must use two: <code>r'some\\\\path'</code>.</p> Pattern Meaning <code>*</code> Matches everything. <code>?</code> Matches any single character. <code>[seq]</code> Matches any character in seq. <code>[!seq]</code> Matches any character not in seq. Will also accept character exclusions in the form of <code>[^seq]</code>. <code>[[:alnum:]]</code> POSIX style character classes inside sequences. See POSIX Character Classes for more info. <code>\\</code> Escapes characters. If applied to a meta character or non-meta characters, the character will be treated as a literal character. If applied to another escape, the backslash will be a literal backslash. <code>!</code> When used at the start of a pattern, the pattern will be an exclusion pattern. Requires the <code>NEGATE</code> flag. If also using the <code>MINUSNEGATE</code> flag, <code>-</code> will be used instead of <code>!</code>. <code>?(pattern_list)</code> The pattern matches if zero or one occurrences of any of the patterns in the <code>pattern_list</code> match the input string. Requires the <code>EXTMATCH</code> flag. <code>*(pattern_list)</code> The pattern matches if zero or more occurrences of any of the patterns in the <code>pattern_list</code> match the input string. Requires the <code>EXTMATCH</code> flag. <code>+(pattern_list)</code> The pattern matches if one or more occurrences of any of the patterns in the <code>pattern_list</code> match the input string. Requires the <code>EXTMATCH</code> flag. <code>@(pattern_list)</code> The pattern matches if exactly one occurrence of any of the patterns in the <code>pattern_list</code> match the input string. Requires the <code>EXTMATCH</code> flag. <code>!(pattern_list)</code> The pattern matches if the input string cannot be matched with any of the patterns in the <code>pattern_list</code>. Requires the <code>EXTMATCH</code> flag. <code>{}</code> Bash style brace expansions.  This is applied to patterns before anything else. Requires the <code>BRACE</code> flag. <ul> <li>Slashes are generally treated as normal characters, but on windows they are normalized. On Windows, <code>/</code> will match     both <code>/</code> and <code>\\\\</code>. There is no need to explicitly use <code>\\\\</code> in patterns on Windows, but if you do, they must be escaped     to specify a literal <code>\\\\</code>. If a backslash is escaped, it will match all valid windows separators, just like <code>/</code> does.</li> <li>By default, <code>.</code> is not matched by <code>*</code>, <code>?</code>, and <code>[]</code>. See the <code>DOTMATCH</code> flag to match <code>.</code> at     the start of a filename without a literal <code>.</code>.</li> </ul>"},{"location":"fnmatch/#posix-character-classes","title":"POSIX Character Classes","text":"<p>A number of POSIX style character classes are available in the form <code>[:alnum:]</code>. They must be used inside sequences: <code>[[:digit:]]</code>. The <code>C</code> locale is used, and the values for each character class are found in the table below.</p> Property Pattern <code>alnum</code> <code>[a-zA-Z0-9]</code> <code>alpha</code> <code>[a-zA-Z]</code> <code>ascii</code> <code>[\\x00-\\x7F]</code> <code>blank</code> <code>[ \\t]</code> <code>cntrl</code> <code>[\\x00-\\x1F\\x7F]</code> <code>digit</code> <code>[0-9]</code> <code>graph</code> <code>[\\x21-\\x7E]</code> <code>lower</code> <code>[a-z]</code> <code>print</code> <code>[\\x20-\\x7E]</code> <code>punct</code> <code>[!\\\"\\#$%&amp;'()*+,\\-./:;&lt;=&gt;?@\\[\\\\\\]^_`{}~]</code> <code>space</code> <code>[ \\t\\r\\n\\v\\f]</code> <code>upper</code> <code>[A-Z]</code> <code>word</code> <code>[a-zA-Z0-9_]</code> <code>xdigit</code> <code>[A-Fa-f0-9]</code>"},{"location":"fnmatch/#multi-pattern-limits","title":"Multi-Pattern Limits","text":"<p>Many of the API functions allow passing in multiple patterns or using either <code>BRACE</code> or <code>SPLIT</code> to expand a pattern in to more patterns. The number of allowed patterns is limited <code>1000</code>, but you can raise or lower this limit via the keyword option <code>limit</code>. If you set <code>limit</code> to <code>0</code>, there will be no limit.</p> <p>New 6.0</p> <p>The imposed pattern limit and corresponding <code>limit</code> option was introduced in 6.0.</p>"},{"location":"fnmatch/#precompiling","title":"Precompiling","text":"<p>While patterns are often cached, auto expanding patterns, such as <code>'file{a, b, c}'</code> will have each individual permutation cached (up to the cache limit), but not the entire pattern. This is to prevent the cache from exploding with really large patterns such as <code>{1..100}</code>. Essentially, individual patterns are cached, but not the expansion of a pattern into many patterns.</p> <p>If it is planned to reuse a pattern and the performance hit of recompiling is not desired, you can precompile a matcher object via <code>fnmatch.compile</code> which returns a <code>WcMatcher</code> object.</p> <pre><code>&gt;&gt;&gt; import wcmatch.fnmatch as fnmatch\n&gt;&gt;&gt; m = fnmatch.compile('*.md')\n&gt;&gt;&gt; m.match('README.md')\nTrue\n&gt;&gt;&gt; m.filter(['test.txt', 'file.md', 'README.md'])\n['file.md', 'README.md']\n</code></pre>"},{"location":"fnmatch/#api","title":"API","text":""},{"location":"fnmatch/#fnmatch","title":"<code>fnmatch.fnmatch</code>","text":"<pre><code>def fnmatch(filename, patterns, *, flags=0, limit=1000, exclude=None)\n</code></pre> <p><code>fnmatch</code> takes a file name, a pattern (or list of patterns), and flags.  It also allows configuring the max pattern limit. Exclusion patterns can be specified via the <code>exclude</code> parameter which takes a pattern or a list of patterns. It will return a boolean indicating whether the file name was matched by the pattern(s).</p> <pre><code>&gt;&gt;&gt; from wcmatch import fnmatch\n&gt;&gt;&gt; fnmatch.fnmatch('test.txt', '@(*.txt|*.py)', flags=fnmatch.EXTMATCH)\nTrue\n</code></pre> <p>When applying multiple patterns, a file matches if it matches any of the patterns:</p> <pre><code>&gt;&gt;&gt; from wcmatch import fnmatch\n&gt;&gt;&gt; fnmatch.fnmatch('test.txt', ['*.txt', '*.py'], flags=fnmatch.EXTMATCH)\nTrue\n</code></pre> <p>Exclusions can be used by taking advantage of the <code>exclude</code> parameter. It takes a single exclude pattern or a list of patterns. Files that match the exclude pattern will not be matched.</p> <pre><code>&gt;&gt;&gt; from wcmatch import fnmatch\n&gt;&gt;&gt; fnmatch.fnmatch('test.py', '*', exclude='*.py')\nFalse\n&gt;&gt;&gt; fnmatch.fnmatch('test.txt', '*', exclude='*.py')\nTrue\n</code></pre> <p>Inline exclusion patterns are allowed as well. When exclusion patterns are used in conjunction with inclusion patterns, a file will be considered matched if one of the inclusion patterns match and none of the exclusion patterns match. If an exclusion pattern is given without any inclusion patterns, the pattern will match nothing. Exclusion patterns are meant to filter other patterns, not match anything by themselves.</p> <pre><code>&gt;&gt;&gt; from wcmatch import fnmatch\n&gt;&gt;&gt; fnmatch.fnmatch('test.py', '*|!*.py', flags=fnmatch.NEGATE | fnmatch.SPLIT)\nFalse\n&gt;&gt;&gt; fnmatch.fnmatch('test.txt', '*|!*.py', flags=fnmatch.NEGATE | fnmatch.SPLIT)\nTrue\n&gt;&gt;&gt; fnmatch.fnmatch('test.txt', ['*.txt', '!avoid.txt'], flags=fnmatch.NEGATE)\nTrue\n&gt;&gt;&gt; fnmatch.fnmatch('avoid.txt', ['*.txt', '!avoid.txt'], flags=fnmatch.NEGATE)\nFalse\n</code></pre> <p>As mentioned, exclusion patterns need to be applied to a inclusion pattern to work, but if it is desired, you can force exclusion patterns to assume all files should be filtered with the exclusion pattern(s) with the <code>NEGATEALL</code> flag. Essentially, it means if you use a pattern such as <code>!*.md</code>, it will assume two pattern were given: <code>*</code> and <code>!*.md</code>.</p> <pre><code>&gt;&gt;&gt; from wcmatch import fnmatch\n&gt;&gt;&gt; fnmatch.fnmatch('test.py', '!*.py', flags=fnmatch.NEGATE | fnmatch.NEGATEALL)\nFalse\n&gt;&gt;&gt; fnmatch.fnmatch('test.txt', '!*.py', flags=fnmatch.NEGATE | fnmatch.NEGATEALL)\nTrue\n</code></pre> <p>New 6.0</p> <p><code>limit</code> was added in 6.0.</p> <p>New 8.4</p> <p><code>exclude</code> parameter was added.</p>"},{"location":"fnmatch/#filter","title":"<code>fnmatch.filter</code>","text":"<pre><code>def filter(filenames, patterns, *, flags=0, limit=1000, exclude=None):\n</code></pre> <p><code>filter</code> takes a list of filenames, a pattern (or list of patterns), and flags. It also allows configuring the max  pattern limit. Exclusion patterns can be specified via the <code>exclude</code> parameter which takes a pattern or a list of patterns.It returns a list of all files that matched the pattern(s). The same logic used for <code>fnmatch</code> is used for <code>filter</code>, albeit more efficient for processing multiple files.</p> <pre><code>&gt;&gt;&gt; from wcmatch import fnmatch\n&gt;&gt;&gt; fnmatch.filter(['a.txt', 'b.txt', 'c.py'], '*.txt')\n['a.txt', 'b.txt']\n</code></pre> <p>New 6.0</p> <p><code>limit</code> was added in 6.0.</p> <p>New 8.4</p> <p><code>exclude</code> parameter was added.</p>"},{"location":"fnmatch/#compile","title":"<code>fnmatch.compile</code>","text":"<pre><code>def compile(patterns, *, flags=0, limit=1000, exclude=None):\n</code></pre> <p>The <code>compile</code> function takes a file pattern (or list of patterns) and flags. It also allows configuring the max pattern limit. Exclusion patterns can be specified via the <code>exclude</code> parameter which takes a pattern or a list of patterns. It returns a <code>WcMatcher</code> object which can match or filter file paths depending on which method is called.</p> <pre><code>&gt;&gt;&gt; import wcmatch.fnmatch as fnmatch\n&gt;&gt;&gt; m = fnmatch.compile('*.md')\n&gt;&gt;&gt; m.match('README.md')\nTrue\n&gt;&gt;&gt; m.filter(['test.txt', 'file.md', 'README.md'])\n['file.md', 'README.md']\n</code></pre>"},{"location":"fnmatch/#wcmatcher","title":"<code>fnmatch.WcMatcher</code>","text":"<p>The <code>WcMatcher</code> class is returned when a pattern is precompiled with <code>compile</code>. It has two methods: <code>match</code> and <code>filter</code>.</p> <pre><code>def match(self, filename):\n</code></pre> <p>This <code>match</code> method allows for matching against a precompiled pattern.</p> <pre><code>&gt;&gt;&gt; import wcmatch.fnmatch as fnmatch\n&gt;&gt;&gt; m = fnmatch.compile('*.md')\n&gt;&gt;&gt; m.match('README.md')\nTrue\n</code></pre> <pre><code>def filter(self, filenames):\n</code></pre> <p>The <code>filter</code> method allows for filtering paths against a precompiled pattern.</p> <pre><code>&gt;&gt;&gt; import wcmatch.fnmatch as fnmatch\n&gt;&gt;&gt; m = fnmatch.compile('*.md')\n&gt;&gt;&gt; m.filter(['test.txt', 'file.md', 'README.md'])\n['file.md', 'README.md']\n</code></pre>"},{"location":"fnmatch/#translate","title":"<code>fnmatch.translate</code>","text":"<pre><code>def translate(patterns, *, flags=0, limit=1000, exclude=None):\n</code></pre> <p><code>translate</code> takes a file pattern (or list of patterns) and flags. It also allows configuring the max pattern limit. Exclusion patterns can be specified via the <code>exclude</code> parameter which takes a pattern or a list of patterns. It returns two lists: one for inclusion patterns and one for exclusion patterns. The lists contain the regular expressions used for matching the given patterns. It should be noted that a file is considered matched if it matches at least one inclusion pattern and matches none of the exclusion patterns.</p> <pre><code>&gt;&gt;&gt; from wcmatch import fnmatch\n&gt;&gt;&gt; fnmatch.translate('*.{a,{b,c}}', flags=fnmatch.BRACE)\n(['^(?s:(?=.)(?![.]).*?\\\\.a)$', '^(?s:(?=.)(?![.]).*?\\\\.b)$', '^(?s:(?=.)(?![.]).*?\\\\.c)$'], [])\n&gt;&gt;&gt; fnmatch.translate('**|!*.{a,{b,c}}', flags=fnmatch.BRACE | fnmatch.NEGATE | fnmatch.SPLIT)\n(['^(?s:(?=.)(?![.]).*?)$'], ['^(?s:(?=.).*?\\\\.a)$', '^(?s:(?=.).*?\\\\.b)$', '^(?s:(?=.).*?\\\\.c)$'])\n</code></pre> <p>When using <code>EXTMATCH</code> patterns, patterns will be returned with capturing groups around the groups:</p> <p>While in regex patterns like <code>r'(a)+'</code> would capture only the last character, even though multiple where matched, we wrap the entire group to be captured: <code>'+(a)'</code> \u2192 <code>r'((a)+)'</code>.</p> <pre><code>&gt;&gt;&gt; from wcmatch import fnmatch\n&gt;&gt;&gt; import re\n&gt;&gt;&gt; gpat = fnmatch.translate(\"@(file)+([[:digit:]])@(.*)\", flags=fnmatch.EXTMATCH)\n&gt;&gt;&gt; pat = re.compile(gpat[0][0])\n&gt;&gt;&gt; pat.match('file33.test.txt').groups()\n('file', '33', '.test.txt')\n</code></pre> <p>New 6.0</p> <p><code>limit</code> was added in 6.0.</p> <p>New 7.1</p> <p>Translate patterns now provide capturing groups for <code>EXTMATCH</code> groups.</p> <p>New 8.4</p> <p><code>exclude</code> parameter was added.</p>"},{"location":"fnmatch/#escape","title":"<code>fnmatch.escape</code>","text":"<pre><code>def escape(pattern):\n</code></pre> <p>The <code>escape</code> function will conservatively escape <code>-</code>, <code>!</code>, <code>*</code>, <code>?</code>, <code>(</code>, <code>)</code>, <code>[</code>, <code>]</code>, <code>|</code>, <code>{</code>, <code>}</code>, and <code>\\</code> with backslashes, regardless of what feature is or is not enabled. It is meant to escape filenames.</p> <pre><code>&gt;&gt;&gt; from wcmatch import fnmatch\n&gt;&gt;&gt; fnmatch.escape('**file**{}.txt')\n'\\\\*\\\\*file\\\\*\\\\*\\\\{\\\\}.txt'\n&gt;&gt;&gt; fnmatch.fnmatch('**file**{}.txt', fnmatch.escape('**file**{}.txt'))\nTrue\n</code></pre> <p>New 8.1</p> <p>An <code>escape</code> variant for <code>fnmatch</code> was made available in 8.1.</p>"},{"location":"fnmatch/#is_magic","title":"<code>fnmatch.is_magic</code>","text":"<pre><code>def is_magic(pattern, *, flags=0):\n    \"\"\"Check if the pattern is likely to be magic.\"\"\"\n</code></pre> <p>This checks a given filename or <code>pattern</code> to see if it is \"magic\" or not. The check is based on the enabled features via <code>flags</code>. Filenames or patterns are expected to be/target full names. This variant of <code>is_magic</code> is meant to be run on filenames or patterns for file names only. If you need to check patterns with full paths, particularly Windows paths that include drive names or UNC sharepoints (which require special logic), it is recommended to use the <code>glob.escape</code> function.</p> <pre><code>&gt;&gt;&gt; fnmatch.is_magic('test')\nFalse\n&gt;&gt;&gt; fnmatch.is_magic('[test]ing?')\nTrue\n</code></pre> <p>The table below illustrates which symbols are searched for based on the given feature. Each feature adds to the \"default\". In the case of <code>NEGATE</code>, if <code>MINUSNEGATE</code> is also enabled, <code>MINUSNEGATE</code>'s symbols will be searched instead of <code>NEGATE</code>'s symbols.</p> Features Symbols Default <code>?*[]\\</code> <code>EXTMATCH</code> <code>()</code> <code>BRACE</code> <code>{}</code> <code>NEGATE</code> <code>!</code> <code>MINUSNEGATE</code> <code>-</code> <code>SPLIT</code> <code>|</code> <p>New 8.1</p> <p>Added <code>is_magic</code> in 8.1.</p>"},{"location":"fnmatch/#flags","title":"Flags","text":""},{"location":"fnmatch/#case","title":"<code>fnmatch.CASE, fnmatch.C</code>","text":"<p><code>CASE</code> forces case sensitivity. <code>CASE</code> has higher priority than <code>IGNORECASE</code>.</p>"},{"location":"fnmatch/#ignorecase","title":"<code>fnmatch.IGNORECASE, fnmatch.I</code>","text":"<p><code>IGNORECASE</code> forces case insensitivity. <code>CASE</code> has higher priority than <code>IGNORECASE</code>.</p>"},{"location":"fnmatch/#rawchars","title":"<code>fnmatch.RAWCHARS, fnmatch.R</code>","text":"<p><code>RAWCHARS</code> causes string character syntax to be parsed in raw strings: <code>r'\\u0040'</code> \u2192 <code>r'@'</code>. This will handle standard string escapes and Unicode including <code>r'\\N{CHAR NAME}'</code>.</p>"},{"location":"fnmatch/#negate","title":"<code>fnmatch.NEGATE, fnmatch.N</code>","text":"<p><code>NEGATE</code> causes patterns that start with <code>!</code> to be treated as exclusion patterns. A pattern of <code>!*.py</code> would match any file but Python files. Exclusion patterns cannot be used by themselves though, and must be paired with a normal, inclusion pattern, either by utilizing the <code>SPLIT</code> flag, or providing multiple patterns in a list. Assuming the <code>SPLIT</code> flag, this means using it in a pattern such as <code>inclusion|!exclusion</code>.</p> <p>If it is desired, you can force exclusion patterns, when no inclusion pattern is provided, to assume all files match unless the file matches the excluded pattern. This is done with the <code>NEGATEALL</code> flag.</p> <p><code>NEGATE</code> enables <code>DOTMATCH</code> in all exclude patterns, this cannot be disabled. This will not affect the inclusion patterns.</p> <p>If <code>NEGATE</code> is set and exclusion patterns are passed via a matching function's <code>exclude</code> parameter, <code>NEGATE</code> will be ignored and the <code>exclude</code> patterns will be used instead. Either <code>exclude</code> or <code>NEGATE</code> should be used, not both.</p>"},{"location":"fnmatch/#negateall","title":"<code>fnmatch.NEGATEALL, fnmatch.A</code>","text":"<p><code>NEGATEALL</code> can force exclusion patterns, when no inclusion pattern is provided, to assume all files match unless the file matches the excluded pattern. Essentially, it means if you use a pattern such as <code>!*.md</code>, it will assume two patterns were given: <code>*</code> and <code>!*.md</code>, where <code>!*.md</code> is applied to the results of <code>*</code>.</p> <p>Dot files will not be returned unless <code>DOTMATCH</code>.</p>"},{"location":"fnmatch/#minusnegate","title":"<code>fnmatch.MINUSNEGATE, fnmatch.M</code>","text":"<p>When <code>MINUSNEGATE</code> is used with <code>NEGATE</code>, exclusion patterns are recognized by a pattern starting with <code>-</code> instead of <code>!</code>. This plays nice with the <code>EXTMATCH</code> option.</p>"},{"location":"fnmatch/#dotmatch","title":"<code>fnmatch.DOTMATCH, fnmatch.D</code>","text":"<p>By default, <code>fnmatch</code> and related functions will not match file or directory names that start with dot <code>.</code> unless matched with a literal dot. <code>DOTMATCH</code> allows the meta characters (such as <code>*</code>) to match dots like any other character. Dots will not be matched in <code>[]</code>, <code>*</code>, or <code>?</code>.</p>"},{"location":"fnmatch/#extmatch","title":"<code>fnmatch.EXTMATCH, fnmatch.E</code>","text":"<p><code>EXTMATCH</code> enables extended pattern matching. This includes special pattern lists such as <code>+(...)</code>, <code>*(...)</code>, <code>?(...)</code>, etc. See the syntax overview for more information.</p> <p>EXTMATCH and NEGATE</p> <p>When using <code>EXTMATCH</code> and <code>NEGATE</code> together, if a pattern starts with <code>!(</code>, the pattern will not be treated as a <code>NEGATE</code> pattern (even if <code>!(</code> doesn't yield a valid <code>EXTMATCH</code> pattern). To negate a pattern that starts with a literal <code>(</code>, you must escape the bracket: <code>!\\(</code>.</p>"},{"location":"fnmatch/#brace","title":"<code>fnmatch.BRACE, fnmatch.B</code>","text":"<p><code>BRACE</code> enables Bash style brace expansion: <code>a{b,{c,d}}</code> \u2192 <code>ab ac ad</code>. Brace expansion is applied before anything else. When applied, a pattern will be expanded into multiple patterns. Each pattern will then be parsed separately. Redundant, identical patterns are discarded<sup>1</sup> by default.</p> <p>For simple patterns, it may make more sense to use <code>EXTMATCH</code> which will only generate a single pattern which will perform much better: <code>@(ab|ac|ad)</code>.</p> <p>Massive Expansion Risk</p> <ol> <li> <p>It is important to note that each pattern is matched separately, so patterns such as <code>{1..100}</code> would generate     one hundred patterns. Sometimes patterns like this are needed, so construct patterns thoughtfully and carefully.</p> </li> <li> <p><code>BRACE</code> and <code>SPLIT</code> both expand patterns into multiple patterns. Using these two syntaxes     simultaneously can exponential increase in duplicate patterns:</p> <pre><code>&gt;&gt;&gt; expand('test@(this{|that,|other})|*.py', BRACE | SPLIT | EXTMATCH)\n['test@(this|that)', 'test@(this|other)', '*.py', '*.py']\n</code></pre> <p>This effect is reduced as redundant, identical patterns are optimized away<sup>1</sup>. But it is useful to know if trying to construct efficient patterns.</p> </li> </ol>"},{"location":"fnmatch/#split","title":"<code>fnmatch.SPLIT, fnmatch.S</code>","text":"<p><code>SPLIT</code> is used to take a string of multiple patterns that are delimited by <code>|</code> and split them into separate patterns. This is provided to help with some interfaces that might need a way to define multiple patterns in one input. It pairs really well with <code>EXTMATCH</code> and takes into account sequences (<code>[]</code>) and extended patterns (<code>*(...)</code>) and will not parse <code>|</code> within them.  You can also escape the delimiters if needed: <code>\\|</code>.</p> <p>While <code>SPLIT</code> is not as powerful as <code>BRACE</code>, it's syntax is very easy to use, and when paired with <code>EXTMATCH</code>, it feels natural and comes a bit closer. It also much harder to create massive expansions of patterns with it, except when paired with <code>BRACE</code>. See <code>BRACE</code> and it's warnings related to pairing it with <code>SPLIT</code>.</p> <pre><code>&gt;&gt;&gt; from wcmatch import fnmatch\n&gt;&gt;&gt; fnmatch.fnmatch('test.txt', '*.txt|*.py', flags=fnmatch.SPLIT)\nTrue\n&gt;&gt;&gt; fnmatch.fnmatch('test.py', '*.txt|*.py', flags=fnmatch.SPLIT)\nTrue\n</code></pre>"},{"location":"fnmatch/#forcewin","title":"<code>fnmatch.FORCEWIN, fnmatch.W</code>","text":"<p><code>FORCEWIN</code> will force Windows name and case logic to be used on Linux/Unix systems. It will also cause slashes to be normalized. This is great if you need to match Windows specific names on a Linux/Unix system.</p> <p>If <code>FORCEWIN</code> is used along side <code>FORCEUNIX</code>, both will be ignored.</p>"},{"location":"fnmatch/#forceunix","title":"<code>fnmatch.FORCEUNIX, fnmatch.U</code>","text":"<p><code>FORCEUNIX</code> will force Linux/Unix name and case logic to be used on Windows systems. This is great if you need to match Linux/Unix specific names on a Windows system.</p> <p>When using <code>FORCEUNIX</code>, the names are assumed to be case sensitive, but you can use <code>IGNORECASE</code> to use case insensitivity.</p> <p>If <code>FORCEUNIX</code> is used along side <code>FORCEWIN</code>, both will be ignored.</p> <ol> <li> <p>Identical patterns are only reduced by comparing case sensitively as POSIX character classes are case sensitive: <code>[[:alnum:]]</code> \u2260 <code>[[:ALNUM:]]</code>.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"glob/","title":"<code>wcmatch.glob</code>","text":"<pre><code>from wcmatch import glob\n</code></pre>"},{"location":"glob/#syntax","title":"Syntax","text":"<p>The <code>glob</code> library provides methods for traversing the file system and returning files that matched a defined set of glob patterns.  The library also provides a function called <code>globmatch</code> for matching file paths which is similar to <code>fnmatch</code>, but for paths. In short, <code>globmatch</code> matches what <code>glob</code> globs .</p> <p>Tip</p> <p>When using backslashes, it is helpful to use raw strings. In a raw string, a single backslash is used to escape a character <code>r'\\?'</code>.  If you want to represent a literal backslash, you must use two: <code>r'some\\\\path'</code>.</p> Pattern Meaning <code>*</code> Matches everything except slashes.  On Windows it will avoid matching backslashes as well as slashes. <code>**</code> Matches zero or more directories, but will never match the directories <code>.</code> and <code>..</code>. Requires the <code>GLOBSTAR</code> flag. <code>***</code> Like <code>**</code> but will also recurse symlinks. Requires the <code>GLOBSTARLONG</code> flag. <code>?</code> Matches any single character. <code>[seq]</code> Matches any character in seq. <code>[!seq]</code> Matches any character not in seq. Will also accept character exclusions in the form of <code>[^seq]</code>. <code>[[:alnum:]]</code> POSIX style character classes inside sequences. See POSIX Character Classes for more info. <code>\\</code> Escapes characters. If applied to a meta character or non-meta characters, the character will be treated as a literal character. If applied to another escape, the backslash will be a literal backslash. <code>!</code> When used at the start of a pattern, the pattern will be an exclusion pattern. Requires the <code>NEGATE</code> flag. If also using the <code>MINUSNEGATE</code> flag, <code>-</code> will be used instead of <code>!</code>. <code>?(pattern_list)</code> The pattern matches if zero or one occurrences of any of the patterns in the <code>pattern_list</code> match the input string. Requires the <code>EXTGLOB</code> flag. <code>*(pattern_list)</code> The pattern matches if zero or more occurrences of any of the patterns in the <code>pattern_list</code> match the input string. Requires the <code>EXTGLOB</code> flag. <code>+(pattern_list)</code> The pattern matches if one or more occurrences of any of the patterns in the <code>pattern_list</code> match the input string. Requires the <code>EXTGLOB</code> flag. <code>@(pattern_list)</code> The pattern matches if exactly one occurrence of any of the patterns in the <code>pattern_list</code> match the input string. Requires the <code>EXTGLOB</code> flag. <code>!(pattern_list)</code> The pattern matches if the input string cannot be matched with any of the patterns in the <code>pattern_list</code>. Requires the <code>EXTGLOB</code> flag. <code>{}</code> Bash style brace expansions.  This is applied to patterns before anything else. Requires the <code>BRACE</code> flag. <code>~/pattern</code> User path expansion via <code>~/pattern</code> or <code>~user/pattern</code>. Requires the <code>GLOBTILDE</code> flag. <ul> <li> <p>Slashes are generally treated special in glob related methods. Slashes are not matched in <code>[]</code>, <code>*</code>, <code>?</code>, or extended     patterns like <code>*(...)</code>. Slashes can be matched by <code>**</code> if <code>GLOBSTAR</code> is set.</p> </li> <li> <p>Slashes on Windows are normalized. <code>/</code> will match both <code>/</code> and <code>\\\\</code>. There is no need to explicitly use <code>\\\\</code> in     patterns on Windows, but if you do, they must be escaped to specify a literal <code>\\\\</code>. If a backslash is escaped, it will     match all valid windows separators, just like <code>/</code> does.</p> </li> <li> <p>On Windows, drives are treated special and must come at the beginning of the pattern and cannot be matched with <code>*</code>,     <code>[]</code>, <code>?</code>, or even extended match patterns like <code>+(...)</code>.</p> </li> <li> <p>Windows drives are recognized as either <code>C:/</code> and <code>//Server/mount/</code>. If a path uses an ambiguous root (<code>/some/path</code>),     the system will assume the drive of the current working directory.</p> </li> <li> <p>Meta characters have no effect when inside a UNC path: <code>//Server?/mount*/</code>. The one exception is pattern expansion     characters like <code>{}</code> which are used by brace expansion and <code>|</code> used by pattern splitting.     Pattern expansion characters are the only characters that can be escaped in a Windows drive/mount.</p> </li> <li> <p>If <code>FORCEUNIX</code> is applied on a Windows system, match and filter commands that do not touch the file     system will not have slashes normalized. In addition, drive letters will also not be handled. Essentially, paths     will be treated as if on a Linux/Unix system. Commands that do touch the file system (<code>glob</code> and     <code>iglob</code>) will ignore <code>FORCEUNIX</code> and <code>FORCEWIN</code>.     <code>globmatch</code> and <code>globfilter</code>, will also ignore <code>FORCEUNIX</code> and     <code>FORCEWIN</code> if the <code>REALPATH</code> flag is enabled.</p> <p><code>FORCEWIN</code> will do the opposite on a Linux/Unix system, and will force Windows logic on a Linux/Unix system. Like with <code>FORCEUNIX</code>, it only applies to commands that don't touch the file system.</p> </li> <li> <p>By default, file and directory names starting with <code>.</code> are only matched with literal <code>.</code>.  The patterns <code>*</code>, <code>**</code>,     <code>?</code>, and <code>[]</code> will not match a leading <code>.</code>.  To alter this behavior, you can use the <code>DOTGLOB</code> flag.</p> </li> <li> <p><code>NEGATE</code> will always enable <code>DOTGLOB</code> in exclude patterns.</p> </li> <li> <p>Even with <code>DOTGLOB</code> enabled, special tokens will not match a special directory (<code>.</code> or <code>..</code>).  But     when a literal <code>.</code> is used at the start of the pattern (<code>.*</code>, <code>.</code>, <code>..</code>, etc.), <code>.</code> and <code>..</code> can potentially be     matched.</p> </li> <li> <p>In general, Wildcard Match's behavior is modeled off of Bash's, and prior to version 7.0, unlike Python's default     <code>glob</code>, Wildcard Match's <code>glob</code> would match and return <code>.</code> and <code>..</code> for magic patterns like <code>.*</code>.     This is because our directory scanning logic inserts <code>.</code> and <code>..</code> into results to be faithful to Bash. While this     emulates Bash's behavior, it can be surprising to the user, especially if they are used to Python's default glob. In     7.0 we now avoid returning <code>.</code> and <code>..</code> in our directory scanner. This does not affect how patterns are matched, just     what is returned via our directory scan logic. You can once again enable the old Bash-like behavior with the flag     <code>SCANDOTDIR</code> if this old behavior is desired.</p> <p>Python's default:</p> <pre><code>&gt;&gt;&gt; import glob\n&gt;&gt;&gt; glob.glob('docs/.*')\n[]\n</code></pre> <p>Wildcard Match:</p> <pre><code>&gt;&gt;&gt; from wcmatch import glob\n&gt;&gt;&gt; glob.glob('docs/.*')\n[]\n</code></pre> <p>Bash:</p> <pre><code>$ echo docs/.*\ndocs/. docs/..\n</code></pre> <p>Bash-like behavior restored in Wildcard Match <code>SCANDOTDIR</code>:</p> <pre><code>&gt;&gt;&gt; from wcmatch import glob\n&gt;&gt;&gt; glob.glob('docs/.*', flags=glob.SCANDOTDIR)\n['docs/.', 'docs/..']\n</code></pre> <p>It is important to stress that this logic only relates to directory scanning and does not fundamentally alter glob patterns.  We can still match a path of <code>..</code> with <code>.*</code> when strictly doing a match:</p> <pre><code>&gt;&gt;&gt; from wcmatch import glob\n&gt;&gt;&gt; glob.globmatch('..', '.*')\nTrue\n</code></pre> <p>Nor does it affect exclude results as they are used to filter the results after directory scanning:</p> <pre><code>&gt;&gt;&gt; from wcmatch import glob\n&gt;&gt;&gt; glob.glob('..')\n['..']\n&gt;&gt;&gt; glob.glob(['..', '!.*'], flags=glob.NEGATE)\n[]\n</code></pre> <p>If we wish to fundamentally alter the pattern matching behavior, we can use <code>NODOTDIR</code>. This would provide a more Zsh feel.</p> <pre><code>&gt;&gt;&gt; from wcmatch import glob\n&gt;&gt;&gt; glob.glob(['..', '!.*'], flags=glob.NEGATE | glob.NODOTDIR)\n['..']\n&gt;&gt;&gt; glob.glob(['..', '!..'], flags=glob.NEGATE | glob.NODOTDIR)\n[]\n&gt;&gt;&gt; glob.globmatch('..', '.*', flags=glob.NODOTDIR)\nFalse\n</code></pre> <p>Changes 7.0</p> <p>Prior to 7.0 <code>.</code> and <code>..</code> would get returned by our directory scanner. This is no longer the default.</p> <p>New 7.0</p> <p>Legacy behavior of directory scanning, in relation to <code>.</code> and <code>..</code>, can be restored via <code>SCANDOTDIR</code>.</p> <p><code>NODOTDIR</code> was added in 7.0.</p> </li> </ul>"},{"location":"glob/#posix-character-classes","title":"POSIX Character Classes","text":"<p>A number of POSIX style character classes are available in the form <code>[:alnum:]</code>. They must be used inside sequences: <code>[[:digit:]]</code>. The <code>C</code> locale is used, and the values for each character class are found in the table below.</p> Property Pattern <code>alnum</code> <code>[a-zA-Z0-9]</code> <code>alpha</code> <code>[a-zA-Z]</code> <code>ascii</code> <code>[\\x00-\\x7F]</code> <code>blank</code> <code>[ \\t]</code> <code>cntrl</code> <code>[\\x00-\\x1F\\x7F]</code> <code>digit</code> <code>[0-9]</code> <code>graph</code> <code>[\\x21-\\x7E]</code> <code>lower</code> <code>[a-z]</code> <code>print</code> <code>[\\x20-\\x7E]</code> <code>punct</code> <code>[!\\\"\\#$%&amp;'()*+,\\-./:;&lt;=&gt;?@\\[\\\\\\]^_`{}~]</code> <code>space</code> <code>[ \\t\\r\\n\\v\\f]</code> <code>upper</code> <code>[A-Z]</code> <code>word</code> <code>[a-zA-Z0-9_]</code> <code>xdigit</code> <code>[A-Fa-f0-9]</code>"},{"location":"glob/#windows-separators","title":"Windows Separators","text":"<p>On Windows, it is not required to use backslashes for path separators as <code>/</code> will match path separators for all systems. The following will work on Windows and Linux/Unix systems.</p> <pre><code>glob.glob('docs/.*')\n</code></pre> <p>With that said, you can match Windows separators with backslashes as well. Keep in mind that Wildcard Match allows escaped characters in patterns, so to match a literal backslash separator, you must escape the backslash. It is advised to use raw strings when using backslashes to make the patterns more readable, but either of the below will work.</p> <pre><code>glob.glob(r'docs\\\\.*')\nglob.glob('docs\\\\\\\\.*')\n</code></pre>"},{"location":"glob/#multi-pattern-limits","title":"Multi-Pattern Limits","text":"<p>Many of the API functions allow passing in multiple patterns or using either <code>BRACE</code> or <code>SPLIT</code> to expand a pattern in to more patterns. The number of allowed patterns is limited <code>1000</code>, but you can raise or lower this limit via the keyword option <code>limit</code>. If you set <code>limit</code> to <code>0</code>, there will be no limit.</p> <p>New 6.0</p> <p>The imposed pattern limit and corresponding <code>limit</code> option was introduced in 6.0.</p>"},{"location":"glob/#precompiling","title":"Precompiling","text":"<p>While patterns are often cached, auto expanding patterns, such as <code>'file{a, b, c}'</code> will have each individual permutation cached (up to the cache limit), but not the entire pattern. This is to prevent the cache from exploding with really large patterns such as <code>{1..100}</code>. Essentially, individual patterns are cached, but not the expansion of a pattern into many patterns.</p> <p>If it is planned to reuse a pattern and the performance hit of recompiling is not desired, you can precompile a matcher object via <code>glob.compile</code> which returns a <code>WcMatcher</code> object.</p> <pre><code>&gt;&gt;&gt; import wcmatch.glob as glob\n&gt;&gt;&gt; m = glob.compile('**/*.py', flags=glob.GLOBSTAR)\n&gt;&gt;&gt; m.match('wcmatch/__init__.py')\nTrue\n&gt;&gt;&gt; m.filter(['wcmatch/__init__.py', 'wcmatch/glob.py', 'README.md'])\n['wcmatch/__init__.py', 'wcmatch/glob.py']\n</code></pre>"},{"location":"glob/#api","title":"API","text":""},{"location":"glob/#glob","title":"<code>glob.glob</code>","text":"<pre><code>def glob(patterns, *, flags=0, root_dir=None, dir_fd=None, limit=1000, exclude=None):\n</code></pre> <p><code>glob</code> takes a pattern (or list of patterns), flags, and an optional root directory (string or path-like object) and/or directory file descriptor. It also allows configuring the max pattern limit. Exclusion patterns can be specified via the <code>exclude</code> parameter which takes a pattern or a list of patterns.When executed it will crawl the file system returning matching files.</p> <p>Path-like Input Support</p> <p>Path-like object input support is only available in Python 3.6+ as the path-like protocol was added in Python 3.6.</p> <pre><code>&gt;&gt;&gt; from wcmatch import glob\n&gt;&gt;&gt; glob.glob('**/*.md')\n['docs/src/markdown/_snippets/abbr.md', 'docs/src/markdown/_snippets/links.md', 'docs/src/markdown/_snippets/refs.md', 'docs/src/markdown/changelog.md', 'docs/src/markdown/fnmatch.md', 'docs/src/markdown/glob.md', 'docs/src/markdown/index.md', 'docs/src/markdown/installation.md', 'docs/src/markdown/license.md', 'README.md']\n</code></pre> <p>Using a list, we can add exclusion patterns and also exclude directories and/or files:</p> <pre><code>&gt;&gt;&gt; from wcmatch import glob\n&gt;&gt;&gt; glob.glob(['**/*.md', '!README.md', '!**/_snippets'], flags=glob.NEGATE)\n['docs/src/markdown/changelog.md', 'docs/src/markdown/fnmatch.md', 'docs/src/markdown/glob.md', 'docs/src/markdown/index.md', 'docs/src/markdown/installation.md', 'docs/src/markdown/license.md']\n</code></pre> <p>When a glob pattern ends with a slash, it will only return directories:</p> <pre><code>&gt;&gt;&gt; from wcmatch import glob\n&gt;&gt;&gt; glob.glob('**/')\n['__pycache__/', 'docs/', 'docs/src/', 'docs/src/markdown/', 'docs/src/markdown/_snippets/', 'docs/theme/', 'requirements/', 'stuff/', 'tests/', 'tests/__pycache__/', 'wcmatch/', 'wcmatch/__pycache__/']\n</code></pre> <p>When providing a list, all patterns are run in the same context, but will not be run in the same pass. Each pattern is run in a separate pass, except for exclusion patterns (see the <code>NEGATE</code> flag) which are applied as filters to the inclusion patterns. Since each pattern is run in its own pass, it is possible for many directories to be researched multiple times. In Bash, duplicate files can be returned:</p> <pre><code>$ echo *.md README.md\nLICENSE.md README.md README.md\n</code></pre> <p>And we see that Wildcard Match's <code>glob</code> behaves the same, except it only returns unique results.</p> <pre><code>&gt;&gt;&gt; from wcmatch import glob\n&gt;&gt;&gt; glob.glob(['*.md', 'README.md'])\n['LICENSE.md', 'README.md']\n</code></pre> <p>If we wanted to completely match Bash's results, we would turn off unique results with the <code>NOUNIQUE</code> flag.</p> <pre><code>&gt;&gt;&gt; from wcmatch import glob\n&gt;&gt;&gt; glob.glob(['*.md', 'README.md'], flags=glob.NOUNIQUE)\n['LICENSE.md', 'README.md', 'README.md']\n</code></pre> <p>And if we apply an exclusion pattern, since the patterns share the same context, the exclusion applies to both:</p> <pre><code>&gt;&gt;&gt; from wcmatch import glob\n&gt;&gt;&gt; glob.glob(['*.md', , 'README.md', '!README.md'], flags=glob.NEGATE | glob.NOUNIQUE)\n['LICENSE.md']\n</code></pre> <p>Features like <code>BRACE</code> and <code>SPLIT</code> actually take a single string and breaks them up into multiple patterns. These features, when enabled and used, will also exhibit this behavior:</p> <pre><code>&gt;&gt;&gt; from wcmatch import glob\n&gt;&gt;&gt; glob.glob('{*,README}.md', flags=glob.BRACE | glob.NOUNIQUE)\n['LICENSE.md', 'README.md', 'README.md']\n</code></pre> <p>This also aligns with Bash's behavior:</p> <pre><code>$ echo {*,README}.md\nLICENSE.md README.md README.md\n</code></pre> <p>You can resolve user paths with <code>~</code> if the <code>GLOBTILDE</code> flag is enabled. You can also target specific users with <code>~user</code>.</p> <pre><code>&gt;&gt;&gt; from wcmatch import glob\n&gt;&gt;&gt; glob.glob('~', flags=glob.GLOBTILDE)\n['/home/facelessuser']\n&gt;&gt;&gt; glob.glob('~root', flags=glob.GLOBTILDE)\n['/root']\n</code></pre> <p>By default, <code>glob</code> uses the current working directory to evaluate relative patterns. Normally you'd have to use <code>os.chdir('/new/path')</code> to evaluate patterns relative to a different path. By setting <code>root_dir</code> parameter you can change the root path without using <code>os.chdir</code>.</p> <pre><code>&gt;&gt;&gt; from wcmatch import glob\n&gt;&gt;&gt; glob.glob('*')\n['appveyor.yml', 'docs', 'LICENSE.md', 'MANIFEST.in', 'mkdocs.yml', 'README.md', 'requirements', 'setup.cfg', 'setup.py', 'tests', 'tox.ini', 'wcmatch']\n&gt;&gt;&gt; glob.glob('*', root_dir='docs/src')\n['dictionary', 'markdown']\n</code></pre> <p>Additionally, you can use <code>dir_fd</code> and specify a root directory with a directory file descriptor.</p> <pre><code>&gt;&gt;&gt; import os\n&gt;&gt;&gt; from wcmatch import glob\n&gt;&gt;&gt; dir_fd = os.open('docs/src', os.O_RDONLY | os.O_DIRECTORY)\n&gt;&gt;&gt; glob.glob('*', dir_fd=dir_fd)\n['markdown', 'dictionary']\n</code></pre> <p>Support for Directory Descriptors</p> <p>Directory descriptors may not be supported on all systems. You can check whether or not <code>dir_fd</code> is supported for a your platform referencing the attribute <code>glob.SUPPORT_DIR_FD</code> which will be <code>True</code> if it is supported.</p> <p>Additionally, the <code>os.O_DIRECTORY</code> may not be defined on some systems. You can likely just use <code>os.O_RDONLY</code>.</p> <p>New 5.1</p> <p><code>root_dir</code> was added in 5.1.0.</p> <p>New 6.0</p> <p><code>limit</code> was added in 6.0.</p> <p>New 8.2</p> <p><code>dir_fd</code> parameter was added in 8.2.</p> <p>New 8.4</p> <p><code>exclude</code> parameter was added.</p>"},{"location":"glob/#iglob","title":"<code>glob.iglob</code>","text":"<pre><code>def iglob(patterns, *, flags=0, root_dir=None, dir_fd=None, limit=1000, exclude=None):\n</code></pre> <p><code>iglob</code> is just like <code>glob</code> except it returns an iterator.</p> <pre><code>&gt;&gt;&gt; from wcmatch import glob\n&gt;&gt;&gt; list(glob.iglob('**/*.md'))\n['docs/src/markdown/_snippets/abbr.md', 'docs/src/markdown/_snippets/links.md', 'docs/src/markdown/_snippets/refs.md', 'docs/src/markdown/changelog.md', 'docs/src/markdown/fnmatch.md', 'docs/src/markdown/glob.md', 'docs/src/markdown/index.md', 'docs/src/markdown/installation.md', 'docs/src/markdown/license.md', 'README.md']\n</code></pre> <p>New 5.1</p> <p><code>root_dir</code> was added in 5.1.0.</p> <p>New 6.0</p> <p><code>limit</code> was added in 6.0.</p> <p>New 8.2</p> <p><code>dir_fd</code> parameter was added in 8.2.</p> <p>New 8.4</p> <p><code>exclude</code> parameter was added.</p>"},{"location":"glob/#globmatch","title":"<code>glob.globmatch</code>","text":"<pre><code>def globmatch(filename, patterns, *, flags=0, root_dir=None, dir_fd=None, limit=1000, exclude=None):\n</code></pre> <p><code>globmatch</code> takes a file name (string or path-like object), a pattern (or list of patterns), flags, and an optional root directory and/or file descriptor.  It also allows configuring the max pattern limit. Exclusion patterns can be specified via the <code>exclude</code> parameter which takes a pattern or a list of patterns. It will return a boolean indicating whether the file path was matched by the pattern(s).</p> <pre><code>&gt;&gt;&gt; from wcmatch import glob\n&gt;&gt;&gt; glob.globmatch('some/path/test.txt', '**/*/@(*.txt|*.py)', flags=glob.EXTGLOB)\nTrue\n</code></pre> <p>When applying multiple patterns, a file path matches if it matches any of the patterns:</p> <pre><code>&gt;&gt;&gt; from wcmatch import glob\n&gt;&gt;&gt; glob.globmatch('some/path/test.txt', ['**/*/*.txt', '**/*/*.py'])\nTrue\n</code></pre> <p>Exclusion patterns are allowed as well. When exclusion patterns are used in conjunction with other patterns, a path will be considered matched if one of the positive patterns match and none of the exclusion patterns match. If an exclusion pattern is given without any inclusion patterns, the pattern will match nothing. Exclusion patterns are meant to filter other patterns, not match anything by themselves.</p> <pre><code>&gt;&gt;&gt; from wcmatch import glob\n&gt;&gt;&gt; glob.globmatch('some/path/test.py', '**|!**/*.txt', flags=glob.NEGATE | glob.GLOBSTAR | glob.SPLIT)\nTrue\n&gt;&gt;&gt; glob.globmatch('some/path/test.txt', '**|!**/*.txt', flags=glob.NEGATE | glob.GLOBSTAR | glob.SPLIT)\nFalse\n&gt;&gt;&gt; glob.globmatch('some/path/test.txt', ['*/*/*.txt', '!*/*/avoid.txt'], flags=glob.NEGATE)\nTrue\n&gt;&gt;&gt; glob.globmatch('some/path/avoid.txt', ['*/*/*.txt', '!*/*/avoid.txt'], flags=glob.NEGATE)\nFalse\n</code></pre> <p>As mentioned, exclusion patterns need to be applied to a inclusion pattern to work, but if it is desired, you can force exclusion patterns to assume all files should be filtered with the exclusion pattern(s) with the <code>NEGATEALL</code> flag. Essentially, it means if you use a pattern such as <code>!*.md</code>, it means if you use a pattern such as <code>!*.md</code>, it will assume two pattern were given: <code>*</code> and <code>!*.md</code> (where <code>**</code> is specifically treated as if <code>GLOBSTAR</code> was enabled).</p> <pre><code>&gt;&gt;&gt; from wcmatch import glob\n&gt;&gt;&gt; glob.globmatch('some/path/test.py', '!**/*.txt', flags=glob.NEGATE | glob.GLOBSTAR | glob.NEGATEALL)\nTrue\n&gt;&gt;&gt; glob.globmatch('some/path/test.txt', '!**/*.txt', flags=glob.NEGATE | glob.GLOBSTAR | glob.NEGATEALL)\nFalse\n</code></pre> <p>By default, <code>globmatch</code> and <code>globfilter</code> do not operate on the file system. This is to allow you to process paths from any source, even paths that are not on your current system. So if you are trying to explicitly match a directory with a pattern such as <code>*/</code>, your path must end with a slash (<code>my_directory/</code>) to be recognized as a directory. It also won't be able to evaluate whether a directory is a symlink or not as it will have no way of checking. Here we see that <code>globmatch</code> fails to match the filepath as the pattern is explicitly looking for a directory and our filepath does not end with <code>/</code>.</p> <pre><code>&gt;&gt;&gt; from wcmatch import glob\n&gt;&gt;&gt; glob.globmatch('docs', '*/')\nFalse\n</code></pre> <p>If you would like for <code>globmatch</code> (or <code>globfilter</code>) to operate on your current filesystem directly, simply pass in the <code>REALPATH</code> flag. When enabled, the path under consideration will be analyzed and will use that context to determine if the file exists, if it is a directory, does it's context make sense compared to what the pattern is looking vs the current working directory, or if it has symlinks that should not be traversed by <code>GLOBSTAR</code>.</p> <p>Here we use <code>REALPATH</code> and can see that <code>globmatch</code> now knows that <code>doc</code> is a directory.</p> <pre><code>&gt;&gt;&gt; from wcmatch import glob\n&gt;&gt;&gt; glob.globmatch('docs', '*/', flags=glob.REALPATH)\nTrue\n</code></pre> <p>It also can tell if a file doesn't exist or is out of scope compared to what is being asked. For instance, the below example fails because the pattern is looking for any folder that is relative to the current path, which <code>/usr</code> is not. When we disable <code>REALPATH</code>, it will match just fine. Both cases can be useful depending on how you plan to use <code>globmatch</code>.</p> <pre><code>&gt;&gt;&gt; from wcmatch import glob\n&gt;&gt;&gt; glob.globmatch('/usr', '**/', flags=glob.G | glob.REALPATH)\nFalse\n&gt;&gt;&gt; glob.globmatch('/usr', '**/', flags=glob.G)\nTrue\n</code></pre> <p>If you are using <code>REALPATH</code> and want to evaluate the paths relative to a different directory, you can set the <code>root_dir</code> parameter.</p> <pre><code>&gt;&gt;&gt; from wcmatch import glob\n&gt;&gt;&gt; glob.globmatch('markdown', 'markdown', flags=glob.REALPATH)\nFalse\n&gt;&gt;&gt; glob.globmatch('markdown', 'markdown', flags=glob.REALPATH, root_dir='docs/src')\nTrue\n</code></pre> <p>Additionally, you could also provide a root directory using a file descriptor.</p> <pre><code>&gt;&gt;&gt; import os\n&gt;&gt;&gt; from wcmatch import glob\n&gt;&gt;&gt; dir_fd = os.open('docs/src', os.O_RDONLY | os.O_DIRECTORY)\n&gt;&gt;&gt; glob.globmatch('markdown', 'markdown', flags=glob.REALPATH)\nFalse\n&gt;&gt;&gt; glob.globmatch('markdown', 'markdown', flags=glob.REALPATH, dir_fd=dir_fd)\nTrue\n</code></pre> <p>Support for Directory Descriptors</p> <p>Directory descriptors may not be supported on all systems. You can check whether or not <code>dir_fd</code> is supported for a your platform referencing the attribute <code>glob.SUPPORT_DIR_FD</code> which will be <code>True</code> if it is supported.</p> <p>Additionally, the <code>os.O_DIRECTORY</code> may not be defined on some systems. You can likely just use <code>os.O_RDONLY</code>.</p> <p>New 5.1</p> <ul> <li><code>root_dir</code> was added in 5.1.0.</li> <li>path-like object support for file path inputs was added in 5.1.0</li> </ul> <p>New 6.0</p> <p><code>limit</code> was added in 6.0.</p> <p>New 8.2</p> <p><code>dir_fd</code> parameter was added in 8.2.</p> <p>New 8.4</p> <p><code>exclude</code> parameter was added.</p>"},{"location":"glob/#globfilter","title":"<code>glob.globfilter</code>","text":"<pre><code>def globfilter(filenames, patterns, *, flags=0, root_dir=None, dir_fd=None, limit=1000, method=None):\n</code></pre> <p><code>globfilter</code> takes a list of file paths (strings or path-like objects), a pattern (or list of patterns), flags, and an optional root directory and/or directory file descriptor. It also allows configuring the  max pattern limit. Exclusion patterns can be specified via the <code>exclude</code> parameter which takes a pattern or a list of patterns.It returns a list of all files paths that matched the pattern(s). The same logic used for <code>globmatch</code> is used for <code>globfilter</code>, albeit more efficient for processing multiple files.</p> <p>Path-like Input Support</p> <p>Path-like object input support is only available in Python 3.6+ as the path-like protocol was added in Python 3.6.</p> <pre><code>&gt;&gt;&gt; from wcmatch import glob\n&gt;&gt;&gt; glob.globfilter(['some/path/a.txt', 'b.txt', 'another/path/c.py'], '**/*.txt')\n['some/path/a.txt', 'b.txt']\n</code></pre> <p>Like <code>globmatch</code>, <code>globfilter</code> does not operate directly on the file system, with all the caveats associated. But you can enable the <code>REALPATH</code> flag and <code>globfilter</code> will use the filesystem to gain context such as: whether the file exists, whether it is a directory or not, or whether it has symlinks that should not be traversed by <code>GLOBSTAR</code>. See <code>globmatch</code> for examples.</p> <p>New 5.1</p> <ul> <li><code>root_dir</code> was added in 5.1.0.</li> <li>path-like object support for file path inputs was added in 5.1.0</li> </ul> <p>New 6.0</p> <p><code>limit</code> was added in 6.0.</p> <p>New 8.2</p> <p><code>dir_fd</code> parameter was added in 8.2.</p> <p>New 8.4</p> <p><code>exclude</code> parameter was added.</p>"},{"location":"glob/#translate","title":"<code>glob.translate</code>","text":"<pre><code>def translate(patterns, *, flags=0, limit=1000, exclude=None):\n</code></pre> <p><code>translate</code> takes a file pattern (or list of patterns) and flags. It also allows configuring the max pattern limit. Exclusion patterns can be specified via the <code>exclude</code> parameter which takes a pattern or a list of patterns. It returns two lists: one for inclusion patterns and one for exclusion patterns. The lists contain the regular expressions used for matching the given patterns. It should be noted that a file is considered matched if it matches at least one inclusion pattern and matches none of the exclusion patterns.</p> <pre><code>&gt;&gt;&gt; from wcmatch import glob\n&gt;&gt;&gt; glob.translate('**/*.{py,txt}')\n(['^(?s:(?=[^/])(?!(?:\\\\.{1,2})(?:$|[/]))(?:(?!\\\\.)[^/]*?)?[/]+(?=[^/])(?!(?:\\\\.{1,2})(?:$|[/]))(?:(?!\\\\.)[^/]*?)?\\\\.\\\\{py,txt\\\\}[/]*?)$'], [])\n&gt;&gt;&gt; glob.translate('**|!**/*.{py,txt}', flags=glob.NEGATE | glob.SPLIT)\n(['^(?s:(?=[^/])(?!(?:\\\\.{1,2})(?:$|[/]))(?:(?!\\\\.)[^/]*?)?[/]*?)$'], ['^(?s:(?=[^/])(?!(?:\\\\.{1,2})(?:$|[/]))[^/]*?[/]+(?=[^/])(?!(?:\\\\.{1,2})(?:$|[/]))[^/]*?\\\\.\\\\{py,txt\\\\}[/]*?)$'])\n</code></pre> <p>When using <code>EXTGLOB</code> patterns, patterns will be returned with capturing groups around the groups:</p> <p>While in regex patterns like <code>r'(a)+'</code> would capture only the last character, even though multiple where matched, we wrap the entire group to be captured: <code>'+(a)'</code> \u2192 <code>r'((a)+)'</code>.</p> <pre><code>&gt;&gt;&gt; from wcmatch import glob\n&gt;&gt;&gt; import re\n&gt;&gt;&gt; gpat = glob.translate(\"@(file)+([[:digit:]])@(.*)\", flags=glob.EXTGLOB)\n&gt;&gt;&gt; pat = re.compile(gpat[0][0])\n&gt;&gt;&gt; pat.match('file33.test.txt').groups()\n('file', '33', '.test.txt')\n</code></pre> <p>New 6.0</p> <p><code>limit</code> was added in 6.0.</p> <p>New 7.1</p> <p>Translate patterns now provide capturing groups for <code>EXTGLOB</code> groups.</p> <p>New 8.4</p> <p><code>exclude</code> parameter was added.</p>"},{"location":"glob/#compile","title":"<code>glob.compile</code>","text":"<pre><code>def compile(patterns, *, flags=0, limit=1000, exclude=None):\n</code></pre> <p>The <code>compile</code> function takes a file pattern (or list of patterns) and flags. It also allows configuring the max pattern limit. Exclusion patterns can be specified via the <code>exclude</code> parameter which takes a pattern or a list of patterns. It returns a <code>WcMatcher</code> object which can match or filter file paths depending on which method is called. </p> <pre><code>&gt;&gt;&gt; import wcmatch.glob as glob\n&gt;&gt;&gt; m = glob.compile('**/*.py', flags=glob.GLOBSTAR)\n&gt;&gt;&gt; m.match('wcmatch/__init__.py')\nTrue\n&gt;&gt;&gt; m.filter(['wcmatch/__init__.py', 'wcmatch/glob.py', 'README.md'])\n['wcmatch/__init__.py', 'wcmatch/glob.py']\n</code></pre>"},{"location":"glob/#wcmatcher","title":"<code>glob.WcMatcher</code>","text":"<p>The <code>WcMatcher</code> class is returned when a pattern is precompiled with <code>compile</code>. It has two methods: <code>match</code> and <code>filter</code>.</p> <pre><code>def match(self, filename, *, root_dir=None, dir_fd=None):\n</code></pre> <p>This <code>match</code> method allows for matching against a precompiled pattern.</p> <pre><code>&gt;&gt;&gt; import wcmatch.glob as glob\n&gt;&gt;&gt; m = glob.compile('**/*.py', flags=glob.GLOBSTAR)\n&gt;&gt;&gt; m.match('wcmatch/__init__.py')\nTrue\n</code></pre> <pre><code>def filter(self, filenames, *, root_dir=None, dir_fd=None):\n</code></pre> <p>The <code>filter</code> method allows for filtering paths against a precompiled pattern.</p> <pre><code>&gt;&gt;&gt; import wcmatch.glob as glob\n&gt;&gt;&gt; m = glob.compile('**/*.py', flags=glob.GLOBSTAR)\n&gt;&gt;&gt; m.filter(['wcmatch/__init__.py', 'wcmatch/glob.py', 'README.md'])\n['wcmatch/__init__.py', 'wcmatch/glob.py']\n</code></pre>"},{"location":"glob/#escape","title":"<code>glob.escape</code>","text":"<pre><code>def escape(pattern, unix=None):\n</code></pre> <p>The <code>escape</code> function will conservatively escape <code>-</code>, <code>!</code>, <code>*</code>, <code>?</code>, <code>(</code>, <code>)</code>, <code>[</code>, <code>]</code>, <code>|</code>, <code>{</code>, <code>}</code>, and <code>\\</code> with backslashes, regardless of what feature is or is not enabled. It is meant to escape path parts (filenames, Windows drives, UNC sharepoints) or full paths.</p> <pre><code>&gt;&gt;&gt; from wcmatch import glob\n&gt;&gt;&gt; glob.escape('some/path?/**file**{}.txt')\n'some/path\\\\?/\\\\*\\\\*file\\\\*\\\\*\\\\{}.txt'\n&gt;&gt;&gt; glob.globmatch('some/path?/**file**{}.txt', glob.escape('some/path?/**file**{}.txt'))\nTrue\n</code></pre> <p><code>escape</code> can also handle Windows style paths with <code>/</code> or <code>\\</code> path separators. It is usually recommended to use <code>/</code> as Windows backslashes are only supported via a special escape, but <code>\\</code> will be expanded to an escaped backslash (represented in a raw string as <code>r'\\\\'</code> or a normal string as <code>'\\\\\\\\'</code>).</p> <pre><code>&gt;&gt;&gt; from wmcatch import glob\n&gt;&gt;&gt; glob.escape('some\\\\path?\\\\**file**{}.txt', unix=False)\n'some\\\\\\\\path\\\\?\\\\\\\\\\\\*\\\\*file\\\\*\\\\*\\\\{\\\\}.txt'\n&gt;&gt;&gt; glob.globmatch('some\\\\path?\\\\**file**{}.txt', glob.escape('some\\\\path?\\\\**file**{}.txt'), flags=glob.FORCEWIN)\nTrue\n&gt;&gt;&gt; glob.escape('some/path?/**file**{}.txt', unix=False)\n'some/path\\\\?/\\\\*\\\\*file\\\\*\\\\*\\\\{\\\\}.txt'\n&gt;&gt;&gt; glob.globmatch('some\\\\path?\\\\**file**{}.txt', glob.escape('some/path?/**file**{}.txt'), flags=glob.FORCEWIN)\nTrue\n</code></pre> <p>On a Windows system, meta characters are not processed in drives or UNC sharepoints except for pattern expansion meta characters. <code>{</code> and <code>}</code> (when using <code>BRACE</code>) and <code>|</code> (when using <code>SPLIT</code>) are the only meta characters that can affect drives and UNC sharepoints; therefore, they are the only characters that need to be escaped. <code>escape</code>, when it detects or is informed that it is processing a Windows path, <code>escape</code> will properly find and handle drives and UNC sharepoints.</p> <pre><code>&gt;&gt;&gt; from wmcatch import glob\n&gt;&gt;&gt; glob.escape('//./Volume{b75e2c83-0000-0000-0000-602f00000000}\\Test\\Foo.txt', unix=False)\n'//./Volume\\\\{b75e2c83-0000-0000-0000-602f00000000\\\\}\\\\\\\\Test\\\\\\\\Foo.txt'\n</code></pre> <p><code>escape</code> will detect the system it is running on and pick Windows escape logic or Linux/Unix logic. Since <code>globmatch</code> allows you to match Unix style paths on a Windows system and vice versa, you can force Unix style escaping or Windows style escaping via the <code>unix</code> parameter. When <code>unix</code> is <code>None</code>, the escape style will be detected, when <code>unix</code> is <code>True</code> Linux/Unix style escaping will be used, and when <code>unix</code> is <code>False</code> Windows style escaping will be used.</p> <pre><code>&gt;&gt;&gt; glob.escape('some/path?/**file**{}.txt', unix=True)\n</code></pre> <p>New 5.0</p> <p>The <code>unix</code> parameter is now <code>None</code> by default. Set to <code>True</code> to force Linux/Unix style escaping or set to <code>False</code> to force Windows style escaping.</p> <p>New 7.0</p> <p><code>{</code>, <code>}</code>, and <code>|</code> will be escaped in Windows drives. Additionally, users can escape these characters in Windows drives manually in their match patterns as well.</p>"},{"location":"glob/#is_magic","title":"<code>glob.is_magic</code>","text":"<pre><code>def is_magic(pattern, *, flags=0):\n    \"\"\"Check if the pattern is likely to be magic.\"\"\"\n</code></pre> <p>This checks a given path or <code>pattern</code> or to see if \"magic\" symbols are present or not. The check is based on the enabled features via <code>flags</code>. Paths and patterns are expected to be/target full paths, full filenames, full drive names, or full UNC sharepoints. If <code>is_magic</code> is run on a Windows path it will always flag it as \"magic\" unless you convert the directory separators to <code>/</code> as <code>\\</code> is a \"magic\" symbol.</p> <pre><code>&gt;&gt;&gt; glob.is_magic('test')\nFalse\n&gt;&gt;&gt; glob.is_magic('[test]ing?')\nTrue\n</code></pre> <p>When <code>is_magic</code> is called, the system it is called on is detected automatically and/or inferred from flags such as <code>FORCEUNIX</code> or <code>FORCEWIN</code>. If the pattern is checked against a Windows system, UNC sharepoints will be detected and treated differently. Wildcard Match cannot detect and glob all possible connected sharepoints, so they are treated differently and cannot contain magic except in three cases:</p> <ol> <li>The drive or sharepoint is using backslashes as backslashes are treated as magic.</li> <li><code>BRACE</code> is enabled and either <code>{</code> or <code>}</code> are found in the drive name or UNC sharepoint.</li> <li><code>SPLIT</code> is enabled and <code>|</code> is found in the drive name or UNC sharepoint.</li> </ol> <pre><code>&gt;&gt;&gt; glob.is_magic('//?/UNC/server/mount{}/', flags=glob.FORCEWIN)\nFalse\n&gt;&gt;&gt; glob.is_magic('//?/UNC/server/mount{}/', flags=glob.FORCEWIN | glob.BRACE)\nTrue\n</code></pre> <p>The table below illustrates which symbols are searched for based on the given feature. Each feature adds to the \"default\". In the case of <code>NEGATE</code>, if <code>MINUSNEGATE</code> is also enabled, <code>MINUSNEGATE</code>'s symbols will be searched instead of <code>NEGATE</code>'s symbols.</p> Features Symbols Default <code>?*[]\\</code> <code>EXTMATCH</code> <code>()</code> <code>BRACE</code> <code>{}</code> <code>NEGATE</code> <code>!</code> <code>MINUSNEGATE</code> <code>-</code> <code>SPLIT</code> <code>|</code> <code>GLOBTILDE</code> <code>~</code> <p>New 8.1</p> <p>Added <code>is_magic</code> in 8.1.</p>"},{"location":"glob/#flags","title":"Flags","text":""},{"location":"glob/#case","title":"<code>glob.CASE, glob.C</code>","text":"<p><code>CASE</code> forces case sensitivity. <code>CASE</code> has higher priority than <code>IGNORECASE</code>.</p> <p>On Windows, drive letters (<code>C:</code>) and UNC sharepoints (<code>//host/share</code>) portions of a path will still be treated case insensitively, but the rest of the path will have case sensitive logic applied.</p>"},{"location":"glob/#ignorecase","title":"<code>glob.IGNORECASE, glob.I</code>","text":"<p><code>IGNORECASE</code> forces case insensitivity. <code>CASE</code> has higher priority than <code>IGNORECASE</code>.</p>"},{"location":"glob/#rawchars","title":"<code>glob.RAWCHARS, glob.R</code>","text":"<p><code>RAWCHARS</code> causes string character syntax to be parsed in raw strings: <code>r'\\u0040'</code> \u2192 <code>r'@'</code>. This will handle standard string escapes and Unicode including <code>r'\\N{CHAR NAME}'</code>.</p>"},{"location":"glob/#negate","title":"<code>glob.NEGATE, glob.N</code>","text":"<p><code>NEGATE</code> causes patterns that start with <code>!</code> to be treated as exclusion patterns. A pattern of <code>!*.py</code> exclude any Python files. Exclusion patterns cannot be used by themselves though, and must be paired with a normal, inclusion pattern, either by utilizing the <code>SPLIT</code> flag, or providing multiple patterns in a list. Assuming the <code>SPLIT</code> flag, this means using it in a pattern such as <code>inclusion|!exclusion</code>.</p> <p>If it is desired, you can force exclusion patterns, when no inclusion pattern is provided, to assume all files match unless the file matches the excluded pattern. This is done with the <code>NEGATEALL</code> flag.</p> <p><code>NEGATE</code> enables <code>DOTGLOB</code> in all exclude patterns, this cannot be disabled. This will not affect the inclusion patterns.</p> <p>If <code>NEGATE</code> is set and exclusion patterns are passed via a matching or glob function's <code>exclude</code> parameter, <code>NEGATE</code> will be ignored and the <code>exclude</code> patterns will be used instead. Either <code>exclude</code> or <code>NEGATE</code> should be used, not both.</p>"},{"location":"glob/#negateall","title":"<code>glob.NEGATEALL, glob.A</code>","text":"<p><code>NEGATEALL</code> can force exclusion patterns, when no inclusion pattern is provided, to assume all files match unless the file matches the excluded pattern. Essentially, it means if you use a pattern such as <code>!*.md</code>, it will assume two patterns were given: <code>**</code> and <code>!*.md</code>, where <code>!*.md</code> is applied to the results of <code>**</code>, and <code>**</code> is specifically treated as if <code>GLOBSTAR</code> was enabled.</p> <p>Dot files will not be returned unless <code>DOTGLOB</code> is enabled. Symlinks will also not be traversed unless <code>FOLLOW</code> is enabled.</p>"},{"location":"glob/#minusnegate","title":"<code>glob.MINUSNEGATE, glob.M</code>","text":"<p>When <code>MINUSNEGATE</code> is used with <code>NEGATE</code>, exclusion patterns are recognized by a pattern starting with <code>-</code> instead of <code>!</code>. This plays nice with the extended glob feature which already uses <code>!</code> in patterns such as <code>!(...)</code>.</p>"},{"location":"glob/#globstar","title":"<code>glob.GLOBSTAR, glob.G</code>","text":"<p><code>GLOBSTAR</code> enables the feature where <code>**</code> matches zero or more directories.</p>"},{"location":"glob/#globstarlong","title":"<code>glob.GLOBSTARLONG, glob.GL</code>","text":"<p>New 10.0</p> <p>When <code>GLOBSTARLONG</code> is enabled <code>***</code> will act like <code>**</code>, but will cause symlinks to be traversed as well.</p> <p>Enabling <code>GLOBSTARLONG</code> automatically enables <code>GLOBSTAR</code>.</p> <p><code>FOLLOW</code> will be ignored and <code>***</code> will be required to traverse a symlink. But it should be noted that when using <code>MATCHBASE</code> and <code>FOLLOW</code> with <code>GLOBSTARLONG</code>, that <code>FOLLOW</code> will cause the implicit leading <code>**</code> that <code>MATCHBASE</code> applies to act as an implicit <code>***</code>.</p>"},{"location":"glob/#follow","title":"<code>glob.FOLLOW, glob.L</code>","text":"<p><code>FOLLOW</code> will cause <code>GLOBSTAR</code> patterns (<code>**</code>) to traverse symlink directories.</p> <p><code>FOLLOW</code> will have no affect if using <code>GLOBSTARLONG</code> and an explicit <code>***</code> will be required to traverse a symlink. <code>FOLLOW</code> will have an affect if enabled with <code>GLOBSTARLONG</code> and <code>MATCHBASE</code> and will cause the implicit leading <code>**</code> that <code>MATCHBASE</code> applies to act as an implicit <code>***</code>.</p>"},{"location":"glob/#realpath","title":"<code>glob.REALPATH, glob.P</code>","text":"<p>In the past, only <code>glob</code> and <code>iglob</code> operated on the filesystem, but with <code>REALPATH</code>, other functions will now operate on the filesystem as well: <code>globmatch</code> and <code>globfilter</code>.</p> <p>Normally, functions such as <code>globmatch</code> would simply match a path with regular expression and return the result. The functions were not concerned with whether the path existed or not. It didn't care if it was even valid for the operating system.</p> <p><code>REALPATH</code> forces <code>globmatch</code> and <code>globfilter</code> to treat the string path as a real file path for the given system it is running on. It will augment the patterns used to match files and enable additional logic so that the path must meet the following in order to match:</p> <ul> <li>Path must exist.</li> <li>Directories that are symlinks will not be traversed by <code>GLOBSTAR</code> patterns (<code>**</code>) unless the     <code>FOLLOW</code> flag is enabled.</li> <li>If <code>GLOBSTARLONG</code> is enabled, <code>***</code> will traverse symlinks, <code>FOLLOW</code> will be ignored     except if <code>MATCHBASE</code> is also enabled, in that case, the implicit leading <code>**</code> added by     <code>MATCHBASE</code> will act as <code>***</code>.</li> <li>When presented with a pattern where the match must be a directory, but the file path being compared doesn't indicate     the file is a directory with a trailing slash, the command will look at the filesystem to determine if it is a     directory.</li> <li>Paths must match in relation to the current working directory unless the pattern is constructed in a way to indicates     an absolute path.</li> </ul> <p>Since <code>REALPATH</code> causes the file system to be referenced when matching a path, flags such as <code>FORCEUNIX</code> and <code>FORCEWIN</code> are not allowed with this flag and will be ignored.</p>"},{"location":"glob/#dotglob","title":"<code>glob.DOTGLOB, glob.D</code>","text":"<p>By default, <code>glob</code> and <code>globmatch</code> will not match file or directory names that start with dot <code>.</code> unless matched with a literal dot. <code>DOTGLOB</code> allows the meta characters (such as <code>*</code>) to glob dots like any other character. Dots will not be matched in <code>[]</code>, <code>*</code>, or <code>?</code>.</p> <p>Alternatively <code>DOTMATCH</code> will also be accepted for consistency with the other provided libraries. Both flags are exactly the same and are provided as a convenience in case the user finds one more intuitive than the other since <code>DOTGLOB</code> is often the name used in Bash.</p>"},{"location":"glob/#globnodotdir","title":"<code>glob.NODOTDIR, glob.Z</code>","text":"<p><code>NOTDOTDIR</code> fundamentally changes how glob patterns deal with <code>.</code> and <code>..</code>. This is great if you'd prefer a more Zsh feel when it comes to special directory matching. When <code>NODOTDIR</code> is enabled, \"magic\" patterns, such as <code>.*</code>, will not match the special directories of <code>.</code> and <code>..</code>. In order to match these special directories, you will have to use literal glob patterns of <code>.</code> and <code>..</code>. This can be used in all glob API functions that accept flags, and will affect inclusion patterns as well as exclusion patterns.</p> <pre><code>&gt;&gt;&gt; from wcmatch import glob\n&gt;&gt;&gt; glob.globfilter(['.', '..'], '.*')\n['.', '..']\n&gt;&gt;&gt; glob.globfilter(['.', '..'], '.*', flags=glob.NODOTDIR)\n[]\n&gt;&gt;&gt; glob.globfilter(['.', '..'], '.', flags=glob.NODOTDIR)\n['.']\n&gt;&gt;&gt; glob.globfilter(['.', '..'], '..', flags=glob.NODOTDIR)\n['..']\n</code></pre> <p>Also affects exclusion patterns:</p> <pre><code>&gt;&gt;&gt; from wcmatch import glob\n&gt;&gt;&gt; glob.glob(['..', '!.*'], flags=glob.NEGATE)\n[]\n&gt;&gt;&gt; glob.glob(['..', '!.*'], flags=glob.NEGATE | glob.NODOTDIR)\n['..']\n&gt;&gt;&gt; glob.glob(['..', '!..'], flags=glob.NEGATE | glob.NODOTDIR)\n[]\n</code></pre> <p>New 7.0</p> <p><code>NODOTDIR</code> was added in 7.0.</p>"},{"location":"glob/#scandotdir","title":"<code>glob.SCANDOTDIR, glob.SD</code>","text":"<p><code>SCANDOTDIR</code> controls the directory scanning behavior of <code>glob</code> and <code>iglob</code>. The directory scanner of these functions do not return <code>.</code> and <code>..</code> in their results. This means that unless you use an explicit <code>.</code> or <code>..</code> in your glob pattern, <code>.</code> and <code>..</code> will not be returned. When <code>SCANDOTDIR</code> is enabled, <code>.</code> and <code>..</code> will be returned when a directory is scanned causing \"magic\" patterns, such as <code>.*</code>, to match <code>.</code> and <code>..</code>.</p> <p>This only controls the directory scanning behavior and not how glob patterns behave. Exclude patterns, which filter the returned results via <code>NEGATE</code>, can still match <code>.</code> and <code>..</code> with \"magic\" patterns such as <code>.*</code> regardless of whether <code>SCANDOTDIR</code> is enabled or not. It will also have no affect on <code>globmatch</code>. To fundamentally change how glob patterns behave, you can use <code>NODOTDIR</code>.</p> <pre><code>&gt;&gt;&gt; from wcmatch import glob\n&gt;&gt;&gt; glob.glob('.*')\n['.codecov.yml', '.tox', '.coverage', '.coveragerc', '.gitignore', '.github', '.pyspelling.yml', '.git']\n&gt;&gt;&gt; glob.glob('.*', flags=glob.SCANDOTDIR)\n['.', '..', '.codecov.yml', '.tox', '.coverage', '.coveragerc', '.gitignore', '.github', '.pyspelling.yml', '.git']\n</code></pre> <p>New 7.0</p> <p><code>SCANDOTDIR</code> was added in 7.0.</p>"},{"location":"glob/#extglob","title":"<code>glob.EXTGLOB, glob.E</code>","text":"<p><code>EXTGLOB</code> enables extended pattern matching which includes special pattern lists such as <code>+(...)</code>, <code>*(...)</code>, <code>?(...)</code>, etc. Pattern lists allow for multiple patterns within them separated by <code>|</code>. See the globbing syntax overview for more information.</p> <p>Alternatively <code>EXTMATCH</code> will also be accepted for consistency with the other provided libraries. Both flags are exactly the same and are provided as a convenience in case the user finds one more intuitive than the other since <code>EXTGLOB</code> is often the name used in Bash.</p> <p>EXTGLOB and NEGATE</p> <p>When using <code>EXTGLOB</code> and <code>NEGATE</code> together, if a pattern starts with <code>!(</code>, the pattern will not be treated as a <code>NEGATE</code> pattern (even if <code>!(</code> doesn't yield a valid <code>EXTGLOB</code> pattern). To negate a pattern that starts with a literal <code>(</code>, you must escape the bracket: <code>!\\(</code>.</p>"},{"location":"glob/#brace","title":"<code>glob.BRACE, glob.B</code>","text":"<p><code>BRACE</code> enables Bash style brace expansion: <code>a{b,{c,d}}</code> \u2192 <code>ab ac ad</code>. Brace expansion is applied before anything else. When applied, a pattern will be expanded into multiple patterns. Each pattern will then be parsed separately.</p> <p>Duplicate patterns will be discarded<sup>1</sup> by default, and <code>glob</code> and <code>iglob</code> will return only unique results. If you need <code>glob</code> or <code>iglob</code> to behave more like Bash and return all results, you can set <code>NOUNIQUE</code>. <code>NOUNIQUE</code> has no effect on matching functions such as <code>globmatch</code> and <code>globfilter</code>.</p> <p>For simple patterns, it may make more sense to use <code>EXTGLOB</code> which will only generate a single pattern which will perform much better: <code>@(ab|ac|ad)</code>.</p> <p>Massive Expansion Risk</p> <ol> <li> <p>It is important to note that each pattern is crawled separately, so patterns such as <code>{1..100}</code> would generate     one hundred patterns. In a match function (<code>globmatch</code>), that would cause a hundred compares,     and in a file crawling function (<code>glob</code>), it would cause the file system to be crawled one hundred     times. Sometimes patterns like this are needed, so construct patterns thoughtfully and carefully.</p> </li> <li> <p><code>BRACE</code> and <code>SPLIT</code> both expand patterns into multiple patterns. Using these two syntaxes     simultaneously can exponential increase duplicate patterns:</p> <pre><code>&gt;&gt;&gt; expand('test@(this{|that,|other})|*.py', BRACE | SPLIT | EXTMATCH)\n['test@(this|that)', 'test@(this|other)', '*.py', '*.py']\n</code></pre> <p>This effect is reduced as redundant, identical patterns are optimized away<sup>1</sup>, but when using crawling functions (like <code>glob</code>) and <code>NOUNIQUE</code> that optimization is removed, and all of those patterns will be crawled. For this reason, especially when using functions like <code>glob</code>, it is recommended to use one syntax or the other.</p> </li> </ol>"},{"location":"glob/#split","title":"<code>glob.SPLIT, glob.S</code>","text":"<p><code>SPLIT</code> is used to take a string of multiple patterns that are delimited by <code>|</code> and split them into separate patterns. This is provided to help with some interfaces that might need a way to define multiple patterns in one input. It pairs really well with <code>EXTGLOB</code> and takes into account sequences (<code>[]</code>) and extended patterns (<code>*(...)</code>) and will not parse <code>|</code> within them.  You can also escape the delimiters if needed: <code>\\|</code>.</p> <p>Duplicate patterns will be discarded<sup>1</sup> by default, and <code>glob</code> and <code>iglob</code> will return only unique results. If you need <code>glob</code> or <code>iglob</code> to behave more like Bash and return all results, you can set <code>NOUNIQUE</code>. <code>NOUNIQUE</code> has no effect on matching functions such as <code>globmatch</code> and <code>globfilter</code>.</p> <p>While <code>SPLIT</code> is not as powerful as <code>BRACE</code>, it's syntax is very easy to use, and when paired with <code>EXTGLOB</code>, it feels natural and comes a bit closer. It is also much harder to create massive expansions of patterns with it, except when paired with <code>BRACE</code>. See <code>BRACE</code> and its warnings related to pairing it with <code>SPLIT</code>.</p> <pre><code>&gt;&gt;&gt; from wcmatch import glob\n&gt;&gt;&gt; glob.globmatch('test.txt', '*.txt|*.py', flags=fnmatch.SPLIT)\nTrue\n&gt;&gt;&gt; glob.globmatch('test.py', '*.txt|*.py', flags=fnmatch.SPLIT)\nTrue\n</code></pre>"},{"location":"glob/#nounique","title":"<code>glob.NOUNIQUE, glob.Q</code>","text":"<p><code>NOUNIQUE</code> is used to disable Wildcard Match's unique results return. This mimics Bash's output behavior if that is desired.</p> <pre><code>&gt;&gt;&gt; from wcmatch import glob\n&gt;&gt;&gt; glob.glob('{*,README}.md', flags=glob.BRACE | glob.NOUNIQUE)\n['LICENSE.md', 'README.md', 'README.md']\n&gt;&gt;&gt; glob.glob('{*,README}.md', flags=glob.BRACE )\n['LICENSE.md', 'README.md']\n</code></pre> <p>By default, only unique paths are returned in <code>glob</code> and <code>iglob</code>. Normally this is what a programmer would want from such a library, so input patterns are reduced to unique patterns<sup>1</sup> to reduce excessive matching with redundant patterns and excessive crawls through the file system. Also, as two different patterns that have been fed into <code>glob</code> may match the same file, the results are also filtered as to not return the duplicates.</p> <p>Unique results is are accomplished by filtering out duplicate patterns and by retaining an internal set of returned files to determine duplicates. The internal set of files is not retained if only a single, inclusive pattern is provided. Exclusive patterns via <code>NEGATE</code> will not trigger the logic. Singular inclusive patterns that use pattern expansions due to <code>BRACE</code> or <code>SPLIT</code> will act as if multiple patterns were provided, and will trigger the duplicate filtering logic. This is mentioned as functions such as <code>iglob</code>, which normally are expected to not retain results in memory, will be forced to retain a set to ensure unique results if multiple inclusive patterns are provided.</p> <p><code>NOUNIQUE</code> disables all of the aforementioned \"unique\" optimizations, but only for <code>glob</code> and <code>iglob</code>. Functions like <code>globmatch</code> and <code>globfilter</code> would get no benefit from disabling \"unique\" optimizations as they only match what they are given.</p> <p>New in 6.0</p> <p>\"Unique\" optimizations were added in 6.0, along with <code>NOUNIQUE</code>.</p>"},{"location":"glob/#globtilde","title":"<code>glob.GLOBTILDE, glob.T</code>","text":"<p><code>GLOBTILDE</code> allows for user path expansion via <code>~</code>. You can get the current user path by using <code>~</code> at the start of a path. <code>~</code> can be used as the entire pattern, or it must be followed by a directory slash: <code>~/more-pattern</code>.</p> <p>To specify a specific user, you can explicitly specify a user name via <code>~user</code>. If additional pattern is needed, the user name must be followed by a directory slash: <code>~user/more-pattern</code>.</p> <pre><code>&gt;&gt;&gt; from wcmatch import glob\n&gt;&gt;&gt; glob.glob('~', flags=glob.GLOBTILDE)\n['/home/facelessuser']\n&gt;&gt;&gt; glob.glob('~root', flags=glob.GLOBTILDE)\n['/root']\n</code></pre> <p><code>GLOBTILDE</code> can also be used in things like <code>globfilter</code> or <code>globmatch</code>, but you must be using <code>REALPATH</code> or the user path will not be expanded.</p> <pre><code>from wcmatch import glob\n&gt;&gt;&gt; glob.globmatch('/home/facelessuser/', '~', flags=glob.GLOBTILDE | glob.REALPATH)\nTrue\n</code></pre> <p>New 6.0</p> <p>Tilde expansion with <code>GLOBTILDE</code> was added in version 6.0.</p>"},{"location":"glob/#mark","title":"<code>glob.MARK, glob.K</code>","text":"<p><code>MARK</code> ensures that <code>glob</code> and <code>iglob</code> to return all directories with a trailing slash. This makes it very clear which paths are directories and allows you to save calling <code>os.path.isdir</code> as you can simply check for a path separator at the end of the path. This flag only applies to calls to <code>glob</code> or <code>iglob</code>.</p> <p>If you are passing the returned files from <code>glob</code> to <code>globfilter</code> or <code>globmatch</code>, it is important to ensure directory paths have trailing slashes as these functions have no way of telling the path is a directory otherwise (except when <code>REALPATH</code> is enabled). If you have <code>REALPATH</code> enabled, ensuring the files have trailing slashes can still save you a call to <code>os.path.isdir</code> as <code>REALPATH</code> resorts to calling it if there is no trailing slash.</p> <pre><code>&gt;&gt;&gt; from wcmatch import glob\n&gt;&gt;&gt; glob.glob('*', flags=glob.MARK)\n['appveyor.yml', 'base.patch', 'basematch.diff', 'docs/', 'LICENSE.md', 'MANIFEST.in', 'mkdocs.yml', 'README.md', 'requirements/', 'setup.cfg', 'setup.py', 'tests/', 'tools/', 'tox.ini', 'wcmatch/']\n&gt;&gt;&gt; glob.glob('*')\n['appveyor.yml', 'base.patch', 'basematch.diff', 'docs', 'LICENSE.md', 'MANIFEST.in', 'mkdocs.yml', 'README.md', 'requirements', 'setup.cfg', 'setup.py', 'tests', 'tools', 'tox.ini', 'wcmatch']\n</code></pre>"},{"location":"glob/#matchbase","title":"<code>glob.MATCHBASE, glob.X</code>","text":"<p><code>MATCHBASE</code>, when a pattern has no slashes in it, will cause <code>glob</code> and <code>iglob</code> to seek for any file anywhere in the tree with a matching basename. When enabled for <code>globfilter</code> and <code>globmatch</code>, any path whose basename matches. <code>MATCHBASE</code> is sensitive to files and directories that start with <code>.</code> and will not match such files and directories if <code>DOTGLOB</code> is not enabled.</p> <pre><code>&gt;&gt;&gt; from wcmatch import glob\n&gt;&gt;&gt; glob.glob('*.txt', flags=glob.MATCHBASE)\n['docs/src/dictionary/en-custom.txt', 'docs/src/markdown/_snippets/abbr.txt', 'docs/src/markdown/_snippets/links.txt', 'docs/src/markdown/_snippets/posix.txt', 'docs/src/markdown/_snippets/refs.txt', 'requirements/docs.txt', 'requirements/lint.txt', 'requirements/setup.txt', 'requirements/test.txt', 'requirements/tools.txt']\n</code></pre>"},{"location":"glob/#nodir","title":"<code>glob.NODIR, glob.O</code>","text":"<p><code>NODIR</code> will cause <code>glob</code>, <code>iglob</code>, <code>globmatch</code>, and <code>globfilter</code> to return only matched files.</p> <pre><code>&gt;&gt;&gt; from wcmatch import glob\n&gt;&gt;&gt; glob.glob('*', flags=glob.NODIR)\n['appveyor.yml', 'LICENSE.md', 'MANIFEST.in', 'mkdocs.yml', 'README.md', 'setup.cfg', 'setup.py', 'spell.log', 'tox.ini']\n&gt;&gt;&gt; glob.glob('*')\n['appveyor.yml', 'docs', 'LICENSE.md', 'MANIFEST.in', 'mkdocs.yml', 'README.md', 'requirements', 'setup.cfg', 'setup.py', 'spell.log', 'tests', 'tools', 'tox.ini', 'wcmatch']\n</code></pre>"},{"location":"glob/#forcewin","title":"<code>glob.FORCEWIN, glob.W</code>","text":"<p><code>FORCEWIN</code> will force Windows path and case logic to be used on Linux/Unix systems. It will also cause slashes to be normalized and Windows drive syntax to be handled special. This is great if you need to match Windows specific paths on a Linux/Unix system. This will only work on commands that do not access the file system: <code>translate</code>, <code>globmatch</code>, <code>globfilter</code>, etc. These flags will not work with <code>glob</code> or <code>iglob</code>. It also will not work when using the <code>REALPATH</code> flag with things like <code>globmatch</code> and <code>globfilter</code>.</p> <p>If <code>FORCEWIN</code> is used along side <code>FORCEUNIX</code>, both will be ignored.</p>"},{"location":"glob/#forceunix","title":"<code>glob.FORCEUNIX, glob.U</code>","text":"<p><code>FORCEUNIX</code> will force Linux/Unix path and case logic to be used on Windows systems. This is great if you need to match Linux/Unix specific paths on a Windows system. This will only work on commands that do not access the file system: <code>translate</code>, <code>globmatch</code>, <code>globfilter</code>, etc. These flags will not work with <code>glob</code> or <code>iglob</code>. It also will not work when using the <code>REALPATH</code> flag with things like <code>globmatch</code> and <code>globfilter</code>.</p> <p>When using <code>FORCEUNIX</code>, the paths are assumed to be case sensitive, but you can use <code>IGNORECASE</code> to use case insensitivity.</p> <p>If <code>FORCEUNIX</code> is used along side <code>FORCEWIN</code>, both will be ignored.</p> <ol> <li> <p>Identical patterns are only reduced by comparing case sensitively as POSIX character classes are case sensitive: <code>[[:alnum:]]</code> \u2260 <code>[[:ALNUM:]]</code>.\u00a0\u21a9\u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"pathlib/","title":"<code>wcmatch.pathlib</code>","text":"<pre><code>from wcmatch import pathlib\n</code></pre> <p>New 5.0</p> <p><code>wcmatch.pathlib</code> was added in <code>wcmatch</code> 5.0.</p>"},{"location":"pathlib/#overview","title":"Overview","text":"<p><code>pathlib</code> is a library that contains subclasses of Python's <code>pathlib</code> <code>Path</code> and <code>PurePath</code> classes, and their Posix and Windows subclasses, with the purpose of overriding the default <code>glob</code> behavior with Wildcard Match's very own <code>glob</code>. This allows a user of <code>pathlib</code> to use all of the glob enhancements that Wildcard Match provides. This includes features such as extended glob patterns, brace expansions, and more.</p> <p>This documentation does not mean to exhaustively describe the <code>pathlib</code> library, just the differences introduced by Wildcard Match's implementation. Please check out Python's <code>pathlib</code> documentation to learn more about <code>pathlib</code> in general. Also, to learn more about the underlying glob library being used, check out the documentation for Wildcard Match's <code>glob</code>.</p>"},{"location":"pathlib/#multi-pattern-limits","title":"Multi-Pattern Limits","text":"<p>Many of the API functions allow passing in multiple patterns or using either <code>BRACE</code> or <code>SPLIT</code> to expand a pattern in to more patterns. The number of allowed patterns is limited <code>1000</code>, but you can raise or lower this limit via the keyword option <code>limit</code>. If you set <code>limit</code> to <code>0</code>, there will be no limit.</p> <p>New 6.0</p> <p>The imposed pattern limit and corresponding <code>limit</code> option was introduced in 6.0.</p>"},{"location":"pathlib/#differences","title":"Differences","text":"<p>The API is the same as Python's default <code>pathlib</code> except for the few differences related to file globbing and matching:</p> <ul> <li> <p>Each <code>pathlib</code> object's <code>glob</code>, <code>rglob</code>, and <code>match</code> methods are now     driven by the <code>wcmatch.glob</code> library. As a result, some of the defaults and accepted parameters are     different. Also, many new optional features can be enabled via flags.</p> </li> <li> <p><code>glob</code>, <code>rglob</code>, and  <code>match</code> can take a single string pattern or a list     of patterns. They also accept flags via the <code>flags</code> keyword. This matches the interfaces found detailed in     our <code>glob</code> documentation.</p> </li> <li> <p><code>glob</code>, <code>rglob</code>, and <code>match</code> do not enable <code>GLOBSTAR</code>     or <code>DOTGLOB</code> by default. These flags must be passed in to take advantage of this functionality.</p> </li> <li> <p>A <code>globmatch</code> function has been added to <code>PurePath</code> classes (and <code>Path</code> classes which are derived from     <code>PurePath</code>) which is like <code>match</code> except performs a \"full\" match. Python 3.13 added a similar     function called <code>full_match</code> which came long after our <code>globmatch</code> support was added.     In recent versions we've also added <code>full_match</code> as an alias to our <code>globmatch</code>     function. See <code>match</code>, <code>globmatch</code>, and <code>full_match</code> for more information.</p> </li> <li> <p>If file searching methods (<code>glob</code> and <code>rglob</code>) are given multiple patterns, they will     ensure duplicate results are filtered out. This only occurs when more than one inclusive pattern is given, or a     pattern is expanded into multiple, inclusive patterns via <code>BRACE</code> or <code>SPLIT</code>. When     this occurs, an internal set is kept to track the results returned so that duplicates can be filtered. This will not     occur if only a single, inclusive pattern is given or the <code>NOUNIQUE</code> flag is specified.</p> </li> <li> <p>Python's <code>pathlib</code> has logic to ignore <code>.</code> when used as a directory in both the file path and glob     pattern. We do not alter how <code>pathlib</code> stores paths, but our implementation allows explicit use of <code>.</code> as     a literal directory and will match accordingly. With that said, since <code>pathlib</code> normalizes paths by     removing <code>.</code> directories, in most cases, you won't notice the difference, except when it comes to a path that is     literally just <code>.</code>.</p> <p>Python's default glob:</p> <pre><code>&gt;&gt;&gt; import pathlib\n&gt;&gt;&gt; list(pathlib.Path('.').glob('docs/./src'))\n[PosixPath('docs/src')]\n</code></pre> <p>Ours:</p> <pre><code>&gt;&gt;&gt; form wcmatch import pathlib\n&gt;&gt;&gt; list(pathlib.Path('.').glob('docs/./src'))\n[PosixPath('docs/src')]\n</code></pre> <p>Python's default glob:</p> <pre><code>&gt;&gt;&gt; import pathlib\n&gt;&gt;&gt; pathlib.Path('.').match('.')\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n  File \"/usr/local/Cellar/python@3.8/3.8.3/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pathlib.py\", line 976, in match\n    raise ValueError(\"empty pattern\")\nValueError: empty pattern\n</code></pre> <p>Ours:</p> <pre><code>&gt;&gt;&gt; from wcmatch import pathlib\n&gt;&gt;&gt; pathlib.Path('.').match('.')\nTrue\n</code></pre> </li> </ul>"},{"location":"pathlib/#similarities","title":"Similarities","text":"<ul> <li> <p><code>glob</code>, <code>rglob</code>, and <code>match</code> should mimic the basic behavior of     Python's original <code>pathlib</code> library, just with the enhancements and configurability that Wildcard     Match's <code>glob</code> provides.</p> </li> <li> <p><code>glob</code> and <code>rglob</code> will yield an iterator of the results.</p> </li> <li> <p><code>rglob</code> will exhibit the same recursive behavior.</p> </li> <li> <p><code>match</code> will match using the same recursive behavior as <code>rglob</code>.</p> </li> </ul>"},{"location":"pathlib/#classes","title":"Classes","text":""},{"location":"pathlib/#purepath","title":"<code>pathlib.PurePath</code>","text":"<p><code>PurePath</code> is Wildcard Match's version of Python's <code>PurePath</code> class. Depending on the system, it will create either a <code>PureWindowsPath</code> or a <code>PurePosixPath</code> object. Both objects will utilize <code>wcmatch.glob</code> for all glob related actions.</p> <p><code>PurePath</code> objects do not touch the filesystem. They include the methods <code>match</code> and <code>globmatch</code> (amongst others). You can force the path to access the filesystem if you give either function the <code>REALPATH</code> flag. We do not restrict this, but we do not enable it by default. <code>REALPATH</code> simply forces the match to check the filesystem to see if the file exists and is a directory or not.</p> <pre><code>&gt;&gt;&gt; from wcmatch import pathlib\n&gt;&gt;&gt; pathlib.PurePath('docs/src')\nPurePosixPath('docs/src')\n</code></pre> <p><code>PurePath</code> classes implement the <code>match</code> and <code>globmatch</code> methods:</p> <pre><code>&gt;&gt;&gt; from wcmatch import pathlib\n&gt;&gt;&gt; p = pathlib.PurePath('docs/src')\n&gt;&gt;&gt; p.match('src')\nTrue\n&gt;&gt;&gt; p.globmatch('**/src', flags=pathlib.GLOBSTAR)\nTrue\n</code></pre>"},{"location":"pathlib/#purewindowspath","title":"<code>pathlib.PureWindowsPath</code>","text":"<p><code>PureWindowsPath</code> is Wildcard Match's version of Python's <code>PureWindowsPath</code>. The <code>PureWindowsPath</code> class is useful if you'd like to have the ease that <code>pathlib</code> offers when working with a path, but don't want it to access the filesystem. This is also useful if you'd like to manipulate Windows path strings on a Posix system. This class will utilize Wildcard Match's <code>glob</code> for all glob related actions. The class is subclassed from <code>PurePath</code>.</p> <pre><code>&gt;&gt;&gt; from wcmatch import pathlib\n&gt;&gt;&gt; os.name\n'posix'\n&gt;&gt;&gt; pathlib.PureWindowsPath('c:/some/path')\nPureWindowsPath('c:/some/path')\n</code></pre>"},{"location":"pathlib/#pureposixpath","title":"<code>pathlib.PurePosixPath</code>","text":"<p><code>PurePosixPath</code> is Wildcard Match's version of Python's <code>PurePosixPath</code>. The <code>PurePosixPath</code> class is useful if you'd like to have the ease that <code>pathlib</code> offers when working with a path, but don't want it to access the filesystem. This is also useful if you'd like to manipulate Posix path strings on a Windows system. This class will utilize Wildcard Match's <code>glob</code> for all glob related actions. The class is subclassed from <code>PurePath</code>.</p> <pre><code>&gt;&gt;&gt; from wcmatch import pathlib\n&gt;&gt;&gt; os.name\n'nt'\n&gt;&gt;&gt; pathlib.PureWindowsPath('/usr/local/bin')\nPurePosixPath('/usr/local/bin')\n</code></pre>"},{"location":"pathlib/#path","title":"<code>pathlib.Path</code>","text":"<p><code>Path</code> is Wildcard Match's version of Python's <code>Path</code> class. Depending on the system, it will create either a <code>WindowsPath</code> or a <code>PosixPath</code> object. Both objects will utilize <code>wcmatch.glob</code> for all glob related actions.</p> <p><code>Path</code> classes are subclassed from the <code>PurePath</code> objects, so you get all the features of the <code>Path</code> class in addition to the <code>PurePath</code> class features. <code>Path</code> objects have access to the filesystem. They include the <code>PurePath</code> methods <code>match</code> and <code>globmatch</code> (amongst others). Since these methods are <code>PurePath</code> methods, they do not touch the filesystem. But, you can force them to access the filesystem if you give either function the <code>REALPATH</code> flag. We do not restrict this, but we do not enable it by default. <code>REALPATH</code> simply forces the match to check the filesystem to see if the file exists and is a directory or not.</p> <pre><code>&gt;&gt;&gt; from wcmatch import pathlib\n&gt;&gt;&gt; pathlib.PurePath('docs/src')\nPosixPath('docs/src')\n</code></pre> <p><code>Path</code> classes implement the <code>glob</code> and <code>globmatch</code> methods:</p> <pre><code>&gt;&gt;&gt; from wcmatch import pathlib\n&gt;&gt;&gt; p = pathlib.Path('docs/src')\n&gt;&gt;&gt; p.match('src')\nTrue\n&gt;&gt;&gt; p.globmatch('**/src', flags=pathlib.GLOBSTAR)\nTrue\n&gt;&gt;&gt; list(p.glob('**/*.txt', flags=pathlib.GLOBSTAR))\n[PosixPath('docs/src/dictionary/en-custom.txt'), PosixPath('docs/src/markdown/_snippets/links.txt'), PosixPath('docs/src/markdown/_snippets/refs.txt'), PosixPath('docs/src/markdown/_snippets/abbr.txt'), PosixPath('docs/src/markdown/_snippets/posix.txt')]\n&gt;&gt;&gt; list(p.rglob('*.txt'))\n[PosixPath('docs/src/dictionary/en-custom.txt'), PosixPath('docs/src/markdown/_snippets/links.txt'), PosixPath('docs/src/markdown/_snippets/refs.txt'), PosixPath('docs/src/markdown/_snippets/abbr.txt'), PosixPath('docs/src/markdown/_snippets/posix.txt')]\n</code></pre>"},{"location":"pathlib/#windowspath","title":"<code>pathlib.WindowsPath</code>","text":"<p><code>WindowsPath</code> is Wildcard Match's version of Python's <code>WindowsPath</code>. The <code>WindowsPath</code> class is useful if you'd like to have the ease that <code>pathlib</code> offers when working with a path and be able to manipulate or gain access to information about that file. You cannot instantiate this class on a Posix system. This class will utilize Wildcard Match's <code>glob</code> for all glob related actions. The class is subclassed from <code>Path</code>.</p> <pre><code>&gt;&gt;&gt; from wcmatch import pathlib\n&gt;&gt;&gt; os.name\n'posix'\n&gt;&gt;&gt; pathlib.Path('c:/some/path')\nWindowsPath('c:/some/path')\n</code></pre>"},{"location":"pathlib/#posixpath","title":"<code>pathlib.PosixPath</code>","text":"<p><code>PosixPath</code> is Wildcard Match's version of Python's <code>PosixPath</code>. The <code>PosixPath</code> class is useful if you'd like to have the ease that <code>pathlib</code> offers when working with a path and be able to manipulate or gain access to information about that file. You cannot instantiate this class on a Windows system. This class will utilize Wildcard Match's <code>glob</code> for all glob related actions. The class is subclassed from <code>Path</code>.</p> <pre><code>&gt;&gt;&gt; from wcmatch import pathlib\n&gt;&gt;&gt; os.name\n'posix'\n&gt;&gt;&gt; pathlib.Path('/usr/local/bin')\nPosixPath('/usr/local/bin')\n</code></pre>"},{"location":"pathlib/#methods","title":"Methods","text":""},{"location":"pathlib/#match","title":"<code>PurePath.match</code>","text":"<pre><code>def match(self, patterns, *, flags=0, limit=1000, exclude=None):\n</code></pre> <p><code>match</code> takes a pattern (or list of patterns), and flags.  It also allows configuring the max pattern limit. Exclusion patterns can be specified via the <code>exclude</code> parameter which takes a pattern or a list of patterns. It will return a boolean indicating whether the object's file path was matched by the pattern(s).</p> <p><code>match</code> mimics Python's <code>pathlib</code> version of <code>match</code>. Python's <code>match</code> uses a right to left evaluation that behaves like <code>rglob</code> but as a matcher instead of a globbing function. Wildcard Match emulates this behavior as well. What this means is that when provided with a path <code>some/path/name</code>, the patterns <code>name</code>, <code>path/name</code> and <code>some/path/name</code> will all match. Essentially, it matches what <code>rglob</code> returns.</p> <p><code>match</code> does not access the filesystem, but you can force the path to access the filesystem if you give it the <code>REALPATH</code> flag. We do not restrict this, but we do not enable it by default. <code>REALPATH</code> simply forces the match to check the filesystem to see if the file exists, if it is a directory or not, and whether it is a symlink.</p> <p>Since <code>Path</code> is derived from <code>PurePath</code>, this method is also available in <code>Path</code> objects.</p> <pre><code>&gt;&gt;&gt; from wcmatch import pathlib\n&gt;&gt;&gt; p = pathlib.PurePath('docs/src')\n&gt;&gt;&gt; p.match('src')\nTrue\n</code></pre> <p>New 6.0</p> <p><code>limit</code> was added in 6.0.</p> <p>New 8.4</p> <p><code>exclude</code> parameter was added.</p>"},{"location":"pathlib/#globmatch","title":"<code>PurePath.globmatch</code>","text":"<pre><code>def globmatch(self, patterns, *, flags=0, limit=1000, exclude=None):\n</code></pre> <p><code>globmatch</code> takes a pattern (or list of patterns), and flags.  It also allows configuring the max pattern limit. Exclusion patterns can be specified via the <code>exclude</code> parameter which takes a pattern or a list of patterns. It will return a boolean indicating whether the objects file path was matched by the pattern(s).</p> <p><code>globmatch</code> is similar to <code>match</code> except it does not use the same recursive logic that <code>match</code> does. In all other respects, it behaves the same.</p> <p><code>globmatch</code> does not access the filesystem, but you can force the path to access the filesystem if you give it the <code>REALPATH</code> flag. We do not restrict this, but we do not enable it by default. <code>REALPATH</code> simply forces the match to check the filesystem to see if the file exists, if it is a directory or not, and whether it is a symlink.</p> <p>Since <code>Path</code> is derived from  <code>PurePath</code>, this method is also available in <code>Path</code> objects.</p> <pre><code>&gt;&gt;&gt; from wcmatch import pathlib\n&gt;&gt;&gt; p = pathlib.PurePath('docs/src')\n&gt;&gt;&gt; p.globmatch('**/src', flags=pathlib.GLOBSTAR)\nTrue\n</code></pre> <p>New 6.0</p> <p><code>limit</code> was added in 6.0.</p> <p>New 8.4</p> <p><code>exclude</code> parameter was added.</p>"},{"location":"pathlib/#full_match","title":"<code>PurePath.full_match</code>","text":"<p>new 10.0</p> <pre><code>def full_match(self, patterns, *, flags=0, limit=1000, exclude=None):\n</code></pre> <p>Python 3.13 added the new <code>full_match</code> method to <code>PurePath</code> objects. Essentially, this does for normal <code>pathlib</code> what our existing <code>PurePath.globmatch</code> has been doing prior to Python 3.13. We've added an alias for <code>PurePath.full_match</code> that redirects to <code>PurePath.globmatch</code> for completeness.</p>"},{"location":"pathlib/#glob","title":"<code>Path.glob</code>","text":"<pre><code>def glob(self, patterns, *, flags=0, limit=1000, exclude=None):\n</code></pre> <p><code>glob</code> takes a pattern (or list of patterns) and flags. It also allows configuring the max pattern limit. It will crawl the file system, relative to the current <code>Path</code> object, returning a generator of <code>Path</code> objects. If a file/folder matches any regular, inclusion pattern, it is considered a match.  If a file matches any exclusion pattern (specified via <code>exclude</code> or using negation patterns when enabling the <code>NEGATE</code> flag), then it will not be returned.</p> <p>This method calls our own <code>iglob</code> implementation, and as such, should behave in the same manner in respect to features, the one exception being that instead of returning path strings in the generator, it will return <code>Path</code> objects.</p> <p>The one difference between this <code>glob</code> and the <code>iglob</code> API is that this function does not accept the <code>root_dir</code> parameter. All searches are relative to the object's path, which is evaluated relative to the current working directory.</p> <pre><code>&gt;&gt;&gt; from wcmatch import pathlib\n&gt;&gt;&gt; p = pathlib.Path('docs/src')\n&gt;&gt;&gt; list(p.glob('**/*.txt', flags=pathlib.GLOBSTAR))\n[PosixPath('docs/src/dictionary/en-custom.txt'), PosixPath('docs/src/markdown/_snippets/links.txt'), PosixPath('docs/src/markdown/_snippets/refs.txt'), PosixPath('docs/src/markdown/_snippets/abbr.txt'), PosixPath('docs/src/markdown/_snippets/posix.txt')]\n</code></pre> <p>New 6.0</p> <p><code>limit</code> was added in 6.0.</p> <p>New 8.4</p> <p><code>exclude</code> parameter was added.</p>"},{"location":"pathlib/#rglob","title":"<code>Path.rglob</code>","text":"<pre><code>def rglob(self, patterns, *, flags=0, path_limit=1000, exclude=None):\n</code></pre> <p><code>rglob</code> takes a pattern (or list of patterns) and flags. It also allows configuring the max pattern limit. It will crawl the file system, relative to the current <code>Path</code> object, returning a generator of <code>Path</code> objects. If a file/folder matches any regular patterns, it is considered a match.  If a file matches any exclusion pattern (specified via <code>exclude</code> or using negation patterns when enabling the <code>NEGATE</code> flag), then it will be not be returned.</p> <p><code>rglob</code> mimics Python's <code>pathlib</code> version of <code>rglob</code> in that it uses a recursive logic. What this means is that when you are matching a path in the form <code>some/path/name</code>, the patterns <code>name</code>, <code>path/name</code> and <code>some/path/name</code> will all match. Essentially, the pattern behaves as if a <code>GLOBSTAR</code> pattern of <code>**/</code> was added at the beginning of the pattern.</p> <p><code>rglob</code> is similar to <code>glob</code> except for the use of recursive logic. In all other respects, it behaves the same.</p> <pre><code>&gt;&gt;&gt; from wcmatch import pathlib\n&gt;&gt;&gt; p = pathlib.Path('docs/src')\n&gt;&gt;&gt; list(p.rglob('*.txt'))\n[PosixPath('docs/src/dictionary/en-custom.txt'), PosixPath('docs/src/markdown/_snippets/links.txt'), PosixPath('docs/src/markdown/_snippets/refs.txt'), PosixPath('docs/src/markdown/_snippets/abbr.txt'), PosixPath('docs/src/markdown/_snippets/posix.txt')]\n</code></pre> <p>New 6.0</p> <p><code>limit</code> was added in 6.0.</p> <p>New 8.4</p> <p><code>exclude</code> parameter was added.</p>"},{"location":"pathlib/#flags","title":"Flags","text":""},{"location":"pathlib/#case","title":"<code>pathlib.CASE, pathlib.C</code>","text":"<p><code>CASE</code> forces case sensitivity. <code>CASE</code> has higher priority than <code>IGNORECASE</code>.</p> <p>On Windows, drive letters (<code>C:</code>) and UNC sharepoints (<code>//host/share</code>) portions of a path will still be treated case insensitively, but the rest of the path will have case sensitive logic applied.</p>"},{"location":"pathlib/#ignorecase","title":"<code>pathlib.IGNORECASE, pathlib.I</code>","text":"<p><code>IGNORECASE</code> forces case insensitivity. <code>CASE</code> has higher priority than <code>IGNORECASE</code>.</p>"},{"location":"pathlib/#rawchars","title":"<code>glob.RAWCHARS, glob.R</code>","text":"<p><code>RAWCHARS</code> causes string character syntax to be parsed in raw strings: <code>r'\\u0040'</code> \u2192 <code>r'@'</code>. This will handle standard string escapes and Unicode including <code>r'\\N{CHAR NAME}'</code>.</p>"},{"location":"pathlib/#negate","title":"<code>pathlib.NEGATE, pathlib.N</code>","text":"<p><code>NEGATE</code> causes patterns that start with <code>!</code> to be treated as exclusion patterns. A pattern of <code>!*.py</code> would exclude any Python files. Exclusion patterns cannot be used by themselves though, and must be paired with a normal, inclusion pattern, either by utilizing the <code>SPLIT</code> flag, or providing multiple patterns in a list. Assuming the <code>SPLIT</code> flag, this means using it in a pattern such as <code>inclusion|!exclusion</code>.</p> <p>If it is desired, you can force exclusion patterns, when no inclusion pattern is provided, to assume all files match unless the file matches the excluded pattern. This is done with the <code>NEGATEALL</code> flag.</p> <p><code>NEGATE</code> enables <code>DOTGLOB</code> in all exclude patterns, this cannot be disabled. This will not affect the inclusion patterns.</p> <p>If <code>NEGATE</code> is set and exclusion patterns are passed via a matching or glob function's <code>exclude</code> parameter, <code>NEGATE</code> will be ignored and the <code>exclude</code> patterns will be used instead. Either <code>exclude</code> or <code>NEGATE</code> should be used, not both.</p>"},{"location":"pathlib/#negateall","title":"<code>pathlib.NEGATEALL, pathlib.A</code>","text":"<p><code>NEGATEALL</code> can force exclusion patterns, when no inclusion pattern is provided, to assume all files match unless the file matches the excluded pattern. Essentially, it means if you use a pattern such as <code>!*.md</code>, it will assume two patterns were given: <code>**</code> and <code>!*.md</code>, where <code>!*.md</code> is applied to the results of <code>**</code>, and <code>**</code> is specifically treated as if <code>GLOBSTAR</code> was enabled.</p> <p>Dot files will not be returned unless <code>DOTGLOB</code> is enabled. Symlinks will also be ignored in the return unless <code>FOLLOW</code> is enabled.</p>"},{"location":"pathlib/#minusnegate","title":"<code>pathlib.MINUSNEGATE, pathlib.M</code>","text":"<p>When <code>MINUSNEGATE</code> is used with <code>NEGATE</code>, exclusion patterns are recognized by a pattern starting with <code>-</code> instead of <code>!</code>. This plays nice with the extended glob feature which already uses <code>!</code> in patterns such as <code>!(...)</code>.</p>"},{"location":"pathlib/#globstar","title":"<code>pathlib.GLOBSTAR, pathlib.G</code>","text":"<p><code>GLOBSTAR</code> enables the feature where <code>**</code> matches zero or more directories.</p>"},{"location":"pathlib/#globstarlong","title":"<code>glob.GLOBSTARLONG, glob.GL</code>","text":"<p>New 10.0</p> <p>When <code>GLOBSTARLONG</code> is enabled <code>***</code> will act like <code>**</code>, but will cause symlinks to be traversed as well.</p> <p>Enabling <code>GLOBSTARLONG</code> automatically enables <code>GLOBSTAR</code>.</p> <p><code>FOLLOW</code> will be ignored and <code>***</code> will be required to traverse a symlink. But it should be noted that when using <code>MATCHBASE</code> and <code>FOLLOW</code> with <code>GLOBSTARLONG</code>, that <code>FOLLOW</code> will cause the implicit leading <code>**</code> that <code>MATCHBASE</code> applies to act as an implicit <code>***</code>.</p>"},{"location":"pathlib/#follow","title":"<code>pathlib.FOLLOW, pathlib.L</code>","text":"<p><code>FOLLOW</code> will cause <code>GLOBSTAR</code> patterns (<code>**</code>) to match and traverse symlink directories.</p> <p><code>FOLLOW</code> will have no affect if using <code>GLOBSTARLONG</code> and an explicit <code>***</code> will be required to traverse a symlink. <code>FOLLOW</code> will have an affect if enabled with <code>GLOBSTARLONG</code> and <code>MATCHBASE</code> and will cause the implicit leading <code>**</code> that <code>MATCHBASE</code> applies to act as an implicit <code>***</code>.</p>"},{"location":"pathlib/#realpath","title":"<code>pathlib.REALPATH, pathlib.P</code>","text":"<p>In the past, only <code>glob</code> and <code>iglob</code> operated on the filesystem, but with <code>REALPATH</code>, other functions will now operate on the filesystem as well: <code>globmatch</code> and <code>match</code>.</p> <p>Normally, functions such as <code>globmatch</code> would simply match a path with regular expression and return the result. The functions were not concerned with whether the path existed or not. It didn't care if it was even valid for the operating system.</p> <p><code>REALPATH</code> forces <code>globmatch</code> and <code>match</code> to treat the path as a real file path for the given system it is running on. It will augment the patterns used to match files and enable additional logic so that the path must meet the following in order to match:</p> <ul> <li>Path must exist.</li> <li>Directories that are symlinks will not be matched by <code>GLOBSTAR</code> patterns (<code>**</code>) unless the     <code>FOLLOW</code> flag is enabled.</li> <li>If <code>GLOBSTARLONG</code> is enabled, <code>***</code> will traverse symlinks, <code>FOLLOW</code> will be ignored     except if <code>MATCHBASE</code> is also enabled, in that case, the implicit leading <code>**</code> added by     <code>MATCHBASE</code> will act as <code>***</code>. This also affects the implicit leading <code>**</code> adding by     <code>rglob</code>.</li> <li>When presented with a pattern where the match must be a directory, but the file path being compared doesn't indicate     the file is a directory with a trailing slash, the command will look at the filesystem to determine if it is a     directory.</li> <li>Paths must match in relation to the current working directory unless the pattern is constructed in a way to     indicates an absolute path.</li> </ul>"},{"location":"pathlib/#dotglob","title":"<code>pathlib.DOTGLOB, pathlib.D</code>","text":"<p>By default, globbing and matching functions will not match file or directory names that start with dot <code>.</code> unless matched with a literal dot. <code>DOTGLOB</code> allows the meta characters (such as <code>*</code>) to glob dots like any other character. Dots will not be matched in <code>[]</code>, <code>*</code>, or <code>?</code>.</p> <p>Alternatively <code>DOTMATCH</code> will also be accepted for consistency with the other provided libraries. Both flags are exactly the same and are provided as a convenience in case the user finds one more intuitive than the other since <code>DOTGLOB</code> is often the name used in Bash.</p>"},{"location":"pathlib/#nodotdir","title":"<code>pathlib.NODOTDIR, glob.Z</code>","text":"<p><code>NOTDOTDIR</code> fundamentally changes how glob patterns deal with <code>.</code> and <code>..</code>. This is great if you'd prefer a more Zsh feel when it comes to special directory matching. When <code>NODOTDIR</code> is enabled, \"magic\" patterns, such as <code>.*</code>, will not match the special directories of <code>.</code> and <code>..</code>. In order to match these special directories, you will have to use literal glob patterns of <code>.</code> and <code>..</code>. This can be used in all glob API functions that accept flags, and will affect inclusion patterns as well as exclusion patterns.</p> <pre><code>&gt;&gt;&gt; from wcmatch import pathlib\n&gt;&gt;&gt; pathlib.Path('..').match('.*')\nTrue\n&gt;&gt;&gt; pathlib.Path('..').match('.*', flags=pathlib.NODOTDIR)\nFalse\n&gt;&gt;&gt; pathlib.Path('..').match('..', flags=pathlib.NODOTDIR)\nTrue\n</code></pre> <p>Also affects exclusion patterns:</p> <pre><code>&gt;&gt;&gt; from wcmatch import pathlib\n&gt;&gt;&gt; list(pathlib.Path('.').glob(['docs/..', '!*/.*'], flags=pathlib.NEGATE))\n[]\n&gt;&gt;&gt; list(pathlib.Path('.').glob(['docs/..', '!*/.*'], flags=pathlib.NEGATE | pathlib.NODOTDIR))\n[PosixPath('docs/..')]\n&gt;&gt;&gt; list(pathlib.Path('.').glob(['docs/..', '!*/..'], flags=pathlib.NEGATE | pathlib.NODOTDIR))\n[]\n</code></pre> <p>New 7.0</p> <p><code>NODOTDIR</code> was added in 7.0.</p>"},{"location":"pathlib/#scandotdir","title":"<code>pathlib.SCANDOTDIR, pathlib.SD</code>","text":"<p>Not recommended for <code>pathlib</code></p> <p><code>pathlib</code> supports all of the same flags that the <code>wcmatch.glob</code> library does. But due to how <code>pathlib</code> normalizes the paths that get returned, enabling <code>SCANDOTDIR</code> will only give confusing duplicates if using patterns such as <code>.*</code>. This is not a bug, but is something to be aware of.</p> <p><code>SCANDOTDIR</code> controls the directory scanning behavior of <code>glob</code> and <code>rglob</code>. The directory scanner of these functions do not return <code>.</code> and <code>..</code> in their results. This means unless you use an explicit <code>.</code> or <code>..</code> in your glob pattern, <code>.</code> and <code>..</code> will not be returned. When <code>SCANDOTDIR</code> is enabled, <code>.</code> and <code>..</code> will be returned when a directory is scanned causing \"magic\" patterns, such as <code>.*</code>, to match <code>.</code> and <code>..</code>.</p> <p>This only controls the directory scanning behavior and not how glob patterns behave. Exclude patterns, which filter, the returned results via <code>NEGATE</code>, can still match <code>.</code> and <code>..</code> with \"magic\" patterns such as <code>.*</code> regardless of whether <code>SCANDOTDIR</code> is enabled or not. It will also have no affect on <code>globmatch</code>. To fundamentally change how glob patterns behave, you can use <code>NODOTDIR</code>.</p> <pre><code>&gt;&gt;&gt; from wcmatch import pathlib\n&gt;&gt;&gt; list(pathlib.Path('temp').glob('**/.*', flags=glob.GLOBSTAR | glob.DOTGLOB))\n[PosixPath('temp/.hidden'), PosixPath('temp/.DS_Store')]\n&gt;&gt;&gt; list(pathlib.Path('temp').glob('**/.*', flags=pathlib.GLOBSTAR | pathlib.DOTGLOB | pathlib.SCANDOTDIR))\n[PosixPath('temp'), PosixPath('temp/..'), PosixPath('temp/.hidden'), PosixPath('temp/.hidden/..'), PosixPath('temp/.DS_Store')]\n</code></pre> <p>Notice when we turn off unique result filtering how we get multiple <code>temp/.hidden</code> results. This is due to how <code>pathlib</code> normalizes directories. When comparing the results to a non-<code>pathlib</code> glob, the results make a bit more sense.</p> <pre><code>&gt;&gt;&gt; list(pathlib.Path('temp').glob('**/.*', flags=pathlib.GLOBSTAR | pathlib.DOTGLOB | pathlib.SCANDOTDIR | pathlib.NOUNIQUE))\n[PosixPath('temp'), PosixPath('temp/..'), PosixPath('temp/.hidden'), PosixPath('temp/.hidden'), PosixPath('temp/.hidden/..'), PosixPath('temp/.DS_Store')]\n&gt;&gt;&gt; list(glob.glob('**/.*', flags=glob.GLOBSTAR | glob.DOTGLOB | glob.SCANDOTDIR, root_dir=\"temp\"))\n['.', '..', '.hidden', '.hidden/.', '.hidden/..', '.DS_Store']\n</code></pre> <p>New 7.0</p> <p><code>SCANDOTDIR</code> was added in 7.0.</p>"},{"location":"pathlib/#extglob","title":"<code>pathlib.EXTGLOB, pathlib.E</code>","text":"<p><code>EXTGLOB</code> enables extended pattern matching which includes special pattern lists such as <code>+(...)</code>, <code>*(...)</code>, <code>?(...)</code>, etc. Pattern lists allow for multiple patterns within them separated by <code>|</code>. See the globbing syntax overview for more information.</p> <p>Alternatively <code>EXTMATCH</code> will also be accepted for consistency with the other provided libraries. Both flags are exactly the same and are provided as a convenience in case the user finds one more intuitive than the other since <code>EXTGLOB</code> is often the name used in Bash.</p> <p>EXTGLOB and NEGATE</p> <p>When using <code>EXTGLOB</code> and <code>NEGATE</code> together, if a pattern starts with <code>!(</code>, the pattern will not be treated as a <code>NEGATE</code> pattern (even if <code>!(</code> doesn't yield a valid <code>EXTGLOB</code> pattern). To negate a pattern that starts with a literal <code>(</code>, you must escape the bracket: <code>!\\(</code>.</p>"},{"location":"pathlib/#brace","title":"<code>pathlib.BRACE, pathlib.B</code>","text":"<p><code>BRACE</code> enables Bash style brace expansion: <code>a{b,{c,d}}</code> \u2192 <code>ab ac ad</code>. Brace expansion is applied before anything else. When applied, a pattern will be expanded into multiple patterns. Each pattern will then be parsed separately.</p> <p>Duplicate patterns will be discarded<sup>1</sup> by default, and <code>glob</code> and <code>rglob</code> will return only unique results. If you need <code>glob</code> or <code>rglob</code> to behave more like Bash and return all results, you can set <code>NOUNIQUE</code>. <code>NOUNIQUE</code> has no effect on matching functions such as <code>globmatch</code> and <code>match</code>.</p> <p>For simple patterns, it may make more sense to use <code>EXTGLOB</code> which will only generate a single pattern which will perform much better: <code>@(ab|ac|ad)</code>.</p> <p>Massive Expansion Risk</p> <ol> <li> <p>It is important to note that each pattern is crawled separately, so patterns such as <code>{1..100}</code> would generate     one hundred patterns. In a match function (<code>globmatch</code>), that would cause a hundred     compares, and in a file crawling function (<code>glob</code>), it would cause the file system to be crawled one     hundred times. Sometimes patterns like this are needed, so construct patterns thoughtfully and carefully.</p> </li> <li> <p><code>BRACE</code> and <code>SPLIT</code> both expand patterns into multiple patterns. Using these two syntaxes     simultaneously can exponential increase duplicate patterns:</p> <pre><code>&gt;&gt;&gt; expand('test@(this{|that,|other})|*.py', BRACE | SPLIT | EXTMATCH)\n['test@(this|that)', 'test@(this|other)', '*.py', '*.py']\n</code></pre> <p>This effect is reduced as redundant, identical patterns are optimized away<sup>1</sup>, but when using crawling functions (like in <code>glob</code>) and <code>NOUNIQUE</code> that optimization is removed, and all of those patterns will be crawled. For this reason, especially when using functions like <code>glob</code>, it is recommended to use one syntax or the other.</p> </li> </ol>"},{"location":"pathlib/#split","title":"<code>pathlib.SPLIT, pathlib.S</code>","text":"<p><code>SPLIT</code> is used to take a string of multiple patterns that are delimited by <code>|</code> and split them into separate patterns. This is provided to help with some interfaces that might need a way to define multiple patterns in one input. It pairs really well with <code>EXTGLOB</code> and takes into account sequences (<code>[]</code>) and extended patterns (<code>*(...)</code>) and will not parse <code>|</code> within them.  You can also escape the delimiters if needed: <code>\\|</code>.</p> <p>Duplicate patterns will be discarded<sup>1</sup> by default, and <code>glob</code> and <code>rglob</code> will return only unique results. If you need <code>glob</code> or <code>rglob</code> to behave more like Bash and return all results, you can set <code>NOUNIQUE</code>. <code>NOUNIQUE</code> has no effect on matching functions such as <code>globmatch</code> and <code>match</code>.</p> <p>While <code>SPLIT</code> is not as powerful as <code>BRACE</code>, it's syntax is very easy to use, and when paired with <code>EXTGLOB</code>, it feels natural and comes a bit closer. It is also much harder to create massive expansions of patterns with it, except when paired with <code>BRACE</code>. See <code>BRACE</code> and its warnings related to pairing it with <code>SPLIT</code>.</p> <pre><code>&gt;&gt;&gt; from wcmatch import pathlib\n&gt;&gt;&gt; list(pathlib.Path('.').glob('README.md|LICENSE.md', flags=pathlib.SPLIT))\n[WindowsPath('README.md'), WindowsPath('LICENSE.md')]\n</code></pre>"},{"location":"pathlib/#nounique","title":"<code>pathlib.NOUNIQUE, pathlib.Q</code>","text":"<p><code>NOUNIQUE</code> is used to disable Wildcard Match's unique results return. This mimics Bash's output behavior if that is desired.</p> <pre><code>&gt;&gt;&gt; from wcmatch import glob\n&gt;&gt;&gt; glob.glob('{*,README}.md', flags=glob.BRACE | glob.NOUNIQUE)\n['LICENSE.md', 'README.md', 'README.md']\n&gt;&gt;&gt; glob.glob('{*,README}.md', flags=glob.BRACE )\n['LICENSE.md', 'README.md']\n</code></pre> <p>By default, only unique paths are returned in <code>glob</code> and <code>rglob</code>. Normally this is what a programmer would want from such a library, so input patterns are reduced to unique patterns<sup>1</sup> to reduce excessive matching with redundant patterns and excessive crawls through the file system. Also, as two different patterns that have been fed into <code>glob</code> may match the same file, the results are also filtered as to not return the duplicates.</p> <p>Unique results are accomplished by filtering out duplicate patterns and by retaining an internal set of returned files to determine duplicates. The internal set of files is not retained if only a single, inclusive pattern is provided. Exclusive patterns via <code>NEGATE</code> will not trigger the logic, but singular inclusive patterns that use pattern expansions due to <code>BRACE</code> or <code>SPLIT</code> will act as if multiple patterns were provided, and will trigger the duplicate filtering logic. Lastly, if <code>SCANDOTDIR</code> is enabled, even singular inclusive patterns will trigger duplicate filtering logic to protect against cases where <code>pathlib</code> will normalize two unique results to be the same path, such as <code>.hidden</code> and <code>.hidden/.</code> which get normalized to <code>.hidden</code>.</p> <p><code>NOUNIQUE</code> disables all of the aforementioned \"unique\" optimizations, but only for <code>glob</code> and <code>rglob</code>. Functions like <code>globmatch</code> and <code>match</code> would get no benefit from disabling \"unique\" optimizations as they only match what they are given.</p> <p>New in 6.0</p> <p>\"Unique\" optimizations were added in 6.0, along with <code>NOUNIQUE</code>.</p>"},{"location":"pathlib/#matchbase","title":"<code>pathlib.MATCHBASE, pathlib.X</code>","text":"<p><code>MATCHBASE</code>, when a pattern has no slashes in it, will cause all glob related functions to seek for any file anywhere in the tree with a matching basename, or in the case of <code>match</code> and <code>globmatch</code>, path whose basename matches. <code>MATCHBASE</code> is sensitive to files and directories that start with <code>.</code> and will not match such files and directories if <code>DOTGLOB</code> is not enabled.</p> <pre><code>&gt;&gt;&gt; from wcmatch import pathlib\n&gt;&gt;&gt; list(pathlib.Path('.').glob('*.txt', flags=pathlib.MATCHBASE))\n[WindowsPath('docs/src/dictionary/en-custom.txt'), WindowsPath('docs/src/markdown/_snippets/abbr.txt'), WindowsPath('docs/src/markdown/_snippets/links.txt'), WindowsPath('docs/src/markdown/_snippets/posix.txt'), WindowsPath('docs/src/markdown/_snippets/refs.txt'), WindowsPath('requirements/docs.txt'), WindowsPath('requirements/lint.txt'), WindowsPath('requirements/setup.txt'), WindowsPath('requirements/test.txt'), WindowsPath('requirements/tools.txt'), WindowsPath('site/_snippets/abbr.txt'), WindowsPath('site/_snippets/links.txt'), WindowsPath('site/_snippets/posix.txt'), WindowsPath('site/_snippets/refs.txt')]\n</code></pre>"},{"location":"pathlib/#nodir","title":"<code>pathlib.NODIR, pathlib.O</code>","text":"<p><code>NODIR</code> will cause all glob related functions to return only matched files. In the case of <code>PurePath</code> classes, this may not be possible as those classes do not access the file system, nor will they retain trailing slashes.</p> <pre><code>&gt;&gt;&gt; from wcmatch import pathlib\n&gt;&gt;&gt; list(pathlib.Path('.').glob('*', flags=pathlib.NODIR))\n[WindowsPath('appveyor.yml'), WindowsPath('LICENSE.md'), WindowsPath('MANIFEST.in'), WindowsPath('mkdocs.yml'), WindowsPath('README.md'), WindowsPath('setup.cfg'), WindowsPath('setup.py'), WindowsPath('tox.ini')] \n&gt;&gt;&gt; list(pathlib.Path('.').glob('*'))\n[WindowsPath('appveyor.yml'), WindowsPath('docs'), WindowsPath('LICENSE.md'), WindowsPath('MANIFEST.in'), WindowsPath('mkdocs.yml'), WindowsPath('README.md'), WindowsPath('requirements'), WindowsPath('setup.cfg'), WindowsPath('setup.py'), WindowsPath('site'), WindowsPath('tests'), WindowsPath('tox.ini'), WindowsPath('wcmatch')]\n</code></pre> <ol> <li> <p>Identical patterns are only reduced by comparing case sensitively as POSIX character classes are case sensitive: <code>[[:alnum:]]</code> \u2260 <code>[[:ALNUM:]]</code>.\u00a0\u21a9\u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"wcmatch/","title":"<code>wcmatch.wcmatch</code>","text":"<pre><code>from wcmatch import wcmatch\n</code></pre>"},{"location":"wcmatch/#overview","title":"Overview","text":"<p><code>wcmatch.WcMatch</code> was originally written to provide a simple user interface for searching specific files in Rummage. A class was needed to facilitate a user interface where a user could select a root directory, define one or more file patterns they wanted to search for, and provide folders to exclude if needed. It needed to be aware of hidden files on different systems, not just ignoring files that start with <code>.</code>. It also needed to be extendable so we could further filter returned files by size, creation date, or whatever else was decided. While <code>glob</code> is a fantastic file and folder search tool, it just didn't make sense for such a user interface.</p>"},{"location":"wcmatch/#wcmatch","title":"<code>wcmatch.WcMatch</code>","text":"<pre><code>class WcMatch:\n    \"\"\"Finds files by wildcard.\"\"\"\n\n    def __init__(self, root_dir=\".\", file_pattern=None, **kwargs):\n        \"\"\"Initialize the directory walker object.\"\"\"\n</code></pre> <p><code>WcMatch</code> is an extendable file search class. It allows you to specify a root directory path, file patterns, and optional folder exclude patterns. You can specify whether you want to see hidden files and whether the search should be recursive. You can also derive from the class and tap into specific hooks to change what is returned or done when a file is matched, skipped, or when there is an error. There are also hooks where you can inject additional, custom filtering.</p> Parameter Default Description <code>root_dir</code> The root directory to search. <code>file_pattern</code> <code>''</code> One or more patterns separated by <code>|</code>. You can define exceptions by starting a pattern with <code>!</code> (or <code>-</code> if <code>MINUSNEGATE</code> is set). The default is an empty string, but if an empty string is used, all files will be matched. <code>exclude_pattern</code> <code>''</code> Zero or more folder exclude patterns separated by <code>|</code>. You can define exceptions by starting a pattern with <code>!</code> (or <code>-</code> if <code>MINUSNEGATE</code> is set). <code>flags</code> <code>0</code> Flags to alter behavior of folder and file matching. See Flags for more info. <code>limit</code> <code>1000</code> Allows configuring the max pattern limit. <p>Note</p> <p>Dots are not treated special in <code>wcmatch</code>. When the <code>HIDDEN</code> flag is not included, all hidden files (system and dot files) are excluded from the crawling processes, so there is no risk of <code>*</code> matching a dot file as it will not show up in the crawl. If the <code>HIDDEN</code> flag is included, <code>*</code>, <code>?</code>, and <code>[.]</code> will then match dot files.</p> <p>New 6.0</p> <p><code>limit</code> was added in 6.0.</p>"},{"location":"wcmatch/#multi-pattern-limits","title":"Multi-Pattern Limits","text":"<p>The <code>WcMatch</code> class allow expanding a pattern into multiple patterns by using <code>|</code> and by using <code>BRACE</code>. The number of allowed patterns is limited <code>1000</code>, but you can raise or lower this limit via the keyword option <code>limit</code>. If you set <code>limit</code> to <code>0</code>, there will be no limit.</p> <p>New 6.0</p> <p>The imposed pattern limit and corresponding <code>limit</code> option was introduced in 6.0.</p>"},{"location":"wcmatch/#examples","title":"Examples","text":"<p>Searching for files:</p> <pre><code>&gt;&gt;&gt; from wcmatch import wcmatch\n&gt;&gt;&gt; wcmatch.WcMatch('.', '*.md|*.txt').match()\n['./LICENSE.md', './README.md']\n</code></pre> <p>Recursively searching for files:</p> <pre><code>&gt;&gt;&gt; from wcmatch import wcmatch\n&gt;&gt;&gt; wcmatch.WcMatch('.', '*.md|*.txt', flags=wcmatch.RECURSIVE).match()\n['./LICENSE.md', './README.md', './docs/src/markdown/changelog.md', './docs/src/markdown/fnmatch.md', './docs/src/markdown/glob.md', './docs/src/markdown/index.md', './docs/src/markdown/installation.md', './docs/src/markdown/license.md', './docs/src/markdown/wcmatch.md', './docs/src/markdown/_snippets/abbr.md', './docs/src/markdown/_snippets/links.md', './docs/src/markdown/_snippets/refs.md', './requirements/docs.txt', './requirements/lint.txt', './requirements/setup.txt', './requirements/test.txt']\n</code></pre> <p>Excluding directories:</p> <pre><code>&gt;&gt;&gt; from wcmatch import wcmatch\n&gt;&gt;&gt; wcmatch.WcMatch('.', '*.md|*.txt', exclude_pattern='docs', flags=wcmatch.RECURSIVE).match()\n['./LICENSE.md', './README.md', './requirements/docs.txt', './requirements/lint.txt', './requirements/setup.txt', './requirements/test.txt']\n</code></pre> <p>Using file negation patterns:</p> <pre><code>&gt;&gt;&gt; from wcmatch import wcmatch\n&gt;&gt;&gt; wcmatch.WcMatch('.', '*.md|*.txt|!README*', exclude_pattern='docs', flags=wcmatch.RECURSIVE).match()\n['./LICENSE.md', './requirements/docs.txt', './requirements/lint.txt', './requirements/setup.txt', './requirements/test.txt']\n</code></pre> <p>You can also use negation patterns in directory exclude. Here we avoid all folders with <code>*</code>, but add an exception for <code>requirements</code>. It should be noted that you cannot add an exception for the child of an excluded folder.</p> <pre><code>&gt;&gt;&gt; from wcmatch import wcmatch\n&gt;&gt;&gt; wcmatch.WcMatch('.', '*.md|*.txt', exclude_pattern='*|!requirements', flags=wcmatch.RECURSIVE).match()\n['./LICENSE.md', './README.md', './requirements/docs.txt', './requirements/lint.txt', './requirements/setup.txt', './requirements/test.txt']\n</code></pre> <p>Negative patterns can be given by themselves.</p> <pre><code>&gt;&gt;&gt; from wcmatch import wcmatch\n&gt;&gt;&gt; wcmatch.WcMatch('.', '*.md|*.txt', exclude_pattern='!requirements', flags=wcmatch.RECURSIVE).match()\n['./LICENSE.md', './README.md', './requirements/docs.txt', './requirements/lint.txt', './requirements/setup.txt', './requirements/test.txt']\n</code></pre> <p>Enabling hidden files:</p> <pre><code>&gt;&gt;&gt; from wcmatch import wcmatch\n&gt;&gt;&gt; wcmatch.WcMatch('.', '*.yml').match()\n['./appveyor.yml', './mkdocs.yml']\n&gt;&gt;&gt; wcmatch.WcMatch('.', '*.yml', flags=wcmatch.HIDDEN).match()\n['./.codecov.yml', './.travis.yml', './appveyor.yml', './mkdocs.yml']\n</code></pre>"},{"location":"wcmatch/#methods","title":"Methods","text":""},{"location":"wcmatch/#match","title":"<code>WcMatch.match</code>","text":"<p>Perform match returning files that match the patterns.</p> <pre><code>&gt;&gt;&gt; from wcmatch import wcmatch\n&gt;&gt;&gt; wcmatch.WcMatch('.', '*.md|*.txt').match()\n['./LICENSE.md', './README.md']\n</code></pre>"},{"location":"wcmatch/#imatch","title":"<code>WcMatch.imatch</code>","text":"<p>Perform match returning an iterator of files that match the patterns.</p> <pre><code>&gt;&gt;&gt; from wcmatch import wcmatch\n&gt;&gt;&gt; list(wcmatch.WcMatch('.', '*.md|*.txt').imatch())\n['./LICENSE.md', './README.md']\n</code></pre>"},{"location":"wcmatch/#kill","title":"<code>WcMatch.kill</code>","text":"<p>If searching with <code>imatch</code>, this provides a way to gracefully kill the internal searching. Internally, you can call <code>is_aborted</code> to check if a request to abort has been made. So if work on a file is being done in an <code>on_match</code>, you can check if there has been a request to kill the process, and tie up loose ends gracefully.</p> <pre><code>&gt;&gt;&gt; from wcmatch import wcmatch\n&gt;&gt;&gt; wcm = wcmatch.WcMatch('.', '*.md|*.txt')\n&gt;&gt;&gt; for f in wcm.imatch():\n...     print(f)\n...     wcm.kill()\n...\n./LICENSE.md\n</code></pre> <p>Once a \"kill\" has been issued, the class will remain in an aborted state. To clear the \"kill\" state, you must call <code>reset</code>. This allows a process to define a <code>Wcmatch</code> class and reuse it. If a process receives an early kill and sets it before the match is started, when the match is started, it will immediately abort. This helps with race conditions depending on how you are using <code>WcMatch</code>.</p>"},{"location":"wcmatch/#reset","title":"<code>WcMatch.reset</code>","text":"<p>Resets the abort state after running <code>kill</code>.</p> <pre><code>&gt;&gt;&gt; from wcmatch import wcmatch\n&gt;&gt;&gt; wcm = wcmatch.WcMatch('.', '*.md|*.txt')\n&gt;&gt;&gt; for f in wcm.imatch():\n...     print(f)\n...     wcm.kill()\n...\n./LICENSE.md\n&gt;&gt;&gt; wcm.reset()\n&gt;&gt;&gt; list(wcm.imatch())\n['./LICENSE.md', './README.md']\n</code></pre>"},{"location":"wcmatch/#is_aborted","title":"<code>WcMatch.is_aborted</code>","text":"<p>Checks if an abort has been issued.</p> <pre><code>&gt;&gt;&gt; from wcmatch import wcmatch\n&gt;&gt;&gt; wcm = wcmatch.WcMatch('.', '*.md|*.txt')\n&gt;&gt;&gt; for f in wcm.imatch():\n...     wcm.kill()\n...\n&gt;&gt;&gt; wcm.is_aborted()\nTrue\n</code></pre>"},{"location":"wcmatch/#get_skipped","title":"<code>WcMatch.get_skipped</code>","text":"<p>Returns the number of skipped files. Files in skipped folders are not included in the count.</p> <pre><code>&gt;&gt;&gt; from wcmatch import wcmatch\n&gt;&gt;&gt; wcm = wcmatch.WcMatch('.', '*.md|*.txt')\n&gt;&gt;&gt; list(wcm.imatch())\n['./LICENSE.md', './README.md']\n&gt;&gt;&gt; wcm.get_skipped()\n10\n</code></pre>"},{"location":"wcmatch/#hooks","title":"Hooks","text":""},{"location":"wcmatch/#on_init","title":"<code>WcMatch.on_init</code>","text":"<pre><code>   def on_init(self, **kwargs):\n        \"\"\"Handle custom init.\"\"\"\n</code></pre> <p>Any keyword arguments not processed by the main initializer are sent to <code>on_init</code>. This allows you to specify additional arguments when deriving from <code>WcMatch</code>.</p> <p>Changed 8.0</p> <p>Starting in 8.0, <code>on_init</code> only accepts keyword arguments as now <code>WcMatch</code> requires all parameters (except <code>root_dir</code> and <code>file_pattern</code>) to be keyword parameters and must explicitly be specified in the form <code>key=value</code>.</p>"},{"location":"wcmatch/#on_validate_directory","title":"<code>WcMatch.on_validate_directory</code>","text":"<pre><code>    def on_validate_directory(self, base, name):\n        \"\"\"Validate folder override.\"\"\"\n\n        return True\n</code></pre> <p>When validating a directory, if the directory passes validation, it will be sent to <code>on_validate_directory</code> which can be overridden to provide additional validation if required.</p>"},{"location":"wcmatch/#on_validate_file","title":"<code>WcMatch.on_validate_file</code>","text":"<pre><code>    def on_validate_file(self, base, name):\n        \"\"\"Validate file override.\"\"\"\n\n        return True\n</code></pre> <p>When validating a file, if the file passes validation, it will be sent to <code>on_validate_file</code> which can be overridden to provide additional validation if required.</p>"},{"location":"wcmatch/#on_skip","title":"<code>WcMatch.on_skip</code>","text":"<pre><code>    def on_skip(self, base, name):\n        \"\"\"On skip.\"\"\"\n\n        return None\n</code></pre> <p>When a file that must be skipped is encountered (a file that doesn't pass validation), it is sent to <code>on_skip</code>. Here you could abort the search, store away information, or even create a special skip record to return. It is advised to create a special type for skip returns so that you can identify them when they are returned via <code>match</code> or <code>imatch</code>.</p>"},{"location":"wcmatch/#on_error","title":"<code>WcMatch.on_error</code>","text":"<pre><code>    def on_error(self, base, name):\n        \"\"\"On error.\"\"\"\n\n        return None\n</code></pre> <p>When accessing or processing a file throws an error, it is sent to <code>on_error</code>. Here you could abort the search, store away information, or even create a special error record to return. It is advised to create a special type for error returns so that you can identify them when they are returned via <code>match</code> or <code>imatch</code>.</p>"},{"location":"wcmatch/#on_match","title":"<code>WcMatch.on_match</code>","text":"<pre><code>    def on_match(self, base, name):\n        \"\"\"On match.\"\"\"\n\n        return os.path.join(base, name)\n</code></pre> <p>On match returns the path of the matched file.  You can override <code>on_match</code> and change what is returned.  You could return just the base, you could parse the file and return the content, or return a special match record with additional file meta data. <code>on_match</code> must return something, and all results will be returned via <code>match</code> or <code>imatch</code>.</p>"},{"location":"wcmatch/#on_reset","title":"<code>WcMatch.on_reset</code>","text":"<pre><code>    def on_reset(self):\n        \"\"\"On reset.\"\"\"\n        pass\n</code></pre> <p><code>on_reset</code> is a hook to provide a way to reset any custom logic in classes that have derived from <code>WcMatch</code>. <code>on_reset</code> is called on every new <code>match</code> call.</p>"},{"location":"wcmatch/#flags","title":"Flags","text":""},{"location":"wcmatch/#recursive","title":"<code>wcmatch.RECURSIVE, wcmatch.RV</code>","text":"<p><code>RECURSIVE</code> forces a recursive search that will crawl all subdirectories.</p>"},{"location":"wcmatch/#hidden","title":"<code>wcmatch.HIDDEN, wcmatch.HD</code>","text":"<p><code>HIDDEN</code> enables the crawling of hidden directories and will return hidden files if the wildcard pattern matches. This enables not just dot files, but system hidden files as well.</p>"},{"location":"wcmatch/#symlinks","title":"<code>wcmatch.SYMLINKS, wcmatch.SL</code>","text":"<p><code>SYMLINKS</code> enables the crawling of symlink directories. By default, symlink directories are ignored during the file crawl.</p>"},{"location":"wcmatch/#case","title":"<code>wcmatch.CASE, wcmatch.C</code>","text":"<p><code>CASE</code> forces case sensitivity. <code>CASE</code> has higher priority than <code>IGNORECASE</code>.</p>"},{"location":"wcmatch/#ignorecase","title":"<code>wcmatch.IGNORECASE, wcmatch.I</code>","text":"<p><code>IGNORECASE</code> forces case insensitive searches. <code>CASE</code> has higher priority than <code>IGNORECASE</code>.</p>"},{"location":"wcmatch/#rawchars","title":"<code>wcmatch.RAWCHARS, wcmatch.R</code>","text":"<p><code>RAWCHARS</code> causes string character syntax to be parsed in raw strings: <code>r'\\u0040'</code> \u2192 <code>r'@'</code>. This will handle standard string escapes and Unicode (including <code>r'\\N{CHAR NAME}'</code>).</p>"},{"location":"wcmatch/#extmatch","title":"<code>wcmatch.EXTMATCH, wcmatch.E</code>","text":"<p><code>EXTMATCH</code> enables extended pattern matching which includes special pattern lists such as <code>+(...)</code>, <code>*(...)</code>, <code>?(...)</code>, etc.</p> <p>EXTMATCH and NEGATE</p> <p>When using <code>EXTMATCH</code> and <code>NEGATE</code> together, if a pattern starts with <code>!(</code>, the pattern will not be treated as a <code>NEGATE</code> pattern (even if <code>!(</code> doesn't yield a valid <code>EXTMATCH</code> pattern). To negate a pattern that starts with a literal <code>(</code>, you must escape the bracket: <code>!\\(</code>.</p>"},{"location":"wcmatch/#brace","title":"<code>wcmatch.BRACE, wcmatch.B</code>","text":"<p><code>BRACE</code> enables Bash style brace expansion: <code>a{b,{c,d}}</code> \u2192 <code>ab ac ad</code>. Brace expansion is applied before anything else. When applied, a pattern will be expanded into multiple patterns. Each pattern will then be parsed separately. Redundant, identical patterns are discarded<sup>1</sup> by default.</p> <p>For simple patterns, it may make more sense to use <code>EXTMATCH</code> which will only generate a single pattern which will perform much better: <code>@(ab|ac|ad)</code>.</p> <p>Massive Expansion Risk</p> <ol> <li> <p>It is important to note that each pattern is matched separately, so patterns such as <code>{1..100}</code> would generate     one hundred patterns. Since <code>WcMatch</code> class is able to crawl the file system one pass     accounting for all the patterns, the performance isn't as bad as it may be with <code>glob</code>, but it can     still impact performance as each file must get compared against many patterns until one is matched. Sometimes     patterns like this are needed, so construct patterns thoughtfully and carefully.</p> </li> <li> <p>Splitting patterns with <code>|</code> is built into <code>WcMatch</code>. <code>BRACE</code> and splitting with <code>|</code> both expand     patterns into multiple patterns. Using these two syntaxes simultaneously can exponential increase in duplicate     patterns:</p> <pre><code>&gt;&gt;&gt; expand('test@(this{|that,|other})|*.py', BRACE | SPLIT | EXTMATCH)\n['test@(this|that)', 'test@(this|other)', '*.py', '*.py']\n</code></pre> <p>This effect is reduced as redundant, identical patterns are optimized away<sup>1</sup>. But it is useful to know if trying to construct efficient patterns.</p> </li> </ol>"},{"location":"wcmatch/#minusnegate","title":"<code>wcmatch.MINUSNEGATE, wcmatch.M</code>","text":"<p><code>MINUSNEGATE</code> requires negation patterns to use <code>-</code> instead of <code>!</code>.</p>"},{"location":"wcmatch/#dirpathname","title":"<code>wcmatch.DIRPATHNAME, wcmatch.DP</code>","text":"<p><code>DIRPATHNAME</code> will enable path name searching for excluded folder patterns, but it will not apply to file patterns. This is mainly provided for cases where you may have multiple folders with the same name, but you want to target a specific folder to exclude. The path name compared will be the entire path relative to the root directory.  So if the provided root directory folder was <code>.</code>, and the folder under evaluation is <code>./some/folder</code>, <code>some/folder</code> will be matched against the pattern.</p> <pre><code>&gt;&gt;&gt; from wcmatch import wcmatch\n&gt;&gt;&gt; wcmatch.WcMatch('.', '*.md|*.txt', 'docs/src/markdown', flags=wcmatch.DIRPATHNAME | wcmatch.RECURSIVE).match()\n['./LICENSE.md', './README.md', './requirements/docs.txt', './requirements/lint.txt', './requirements/setup.txt', './requirements/test.txt']\n</code></pre>"},{"location":"wcmatch/#filepathname","title":"<code>wcmatch.FILEPATHNAME, wcmatch.FP</code>","text":"<p><code>FILEPATHNAME</code> will enable path name searching for the file patterns, but it will not apply to directory exclude patterns. The path name compared will be the entire path relative to the root directory path.  So if the provided root directory was <code>.</code>, and the file under evaluation is <code>./some/file.txt</code>, <code>some/file.txt</code> will be matched against the pattern.</p> <pre><code>&gt;&gt;&gt; from wcmatch import wcmatch\n&gt;&gt;&gt; wcmatch.WcMatch('.', '**/*.md|!**/_snippets/*', flags=wcmatch.FILEPATHNAME | wcmatch.GLOBSTAR | wcmatch.RECURSIVE).match()\n['./LICENSE.md', './README.md', './docs/src/markdown/changelog.md', './docs/src/markdown/fnmatch.md', './docs/src/markdown/glob.md', './docs/src/markdown/index.md', './docs/src/markdown/license.md', './docs/src/markdown/wcmatch.md']\n</code></pre>"},{"location":"wcmatch/#pathname","title":"<code>wcmatch.PATHNAME, wcmatch.P</code>","text":"<p><code>PATHNAME</code> enables both <code>DIRPATHNAME</code> and <code>FILEPATHNAME</code>. It is provided for convenience.</p>"},{"location":"wcmatch/#matchbase","title":"<code>wcmatch.MATCHBASE, wcmatch.X</code>","text":"<p>When <code>FILEPATHNAME</code> or <code>DIRPATHNAME</code> is enabled, <code>MATCHBASE</code> will ensure that the respective file or directory pattern, when there are no slashes in the pattern, seeks for any file anywhere in the tree with a matching basename. This is essentially the behavior when <code>FILEPATHNAME</code> and <code>DIRPATHNAME</code> is disabled, but with <code>MATCHBASE</code>, you can toggle the behavior by including slashes in your pattern.</p> <p>When we include no slashes:</p> <pre><code>&gt;&gt;&gt; wcmatch.WcMatch('.', '*.md', flags=wcmatch.FILEPATHNAME | wcmatch.GLOBSTAR | wcmatch.MATCHBASE | wcmatch.RECURSIVE).match()\n['./LICENSE.md', './README.md', './docs/src/markdown/changelog.md', './docs/src/markdown/fnmatch.md', './docs/src/markdown/glob.md', './docs/src/markdown/index.md', './docs/src/markdown/license.md', './docs/src/markdown/wcmatch.md']\n</code></pre> <p>If we include slashes in the pattern, the path, not the basename, must match the pattern:</p> <pre><code>&gt;&gt;&gt; wcmatch.WcMatch('.', 'docs/**/*.md', flags=wcmatch.FILEPATHNAME | wcmatch.GLOBSTAR | wcmatch.MATCHBASE | wcmatch.RECURSIVE).match()\n['./docs/src/markdown/changelog.md', './docs/src/markdown/fnmatch.md', './docs/src/markdown/glob.md', './docs/src/markdown/index.md', './docs/src/markdown/license.md', './docs/src/markdown/wcmatch.md']\n</code></pre> <p>If we have a leading slash, the pattern will not perform a match on the basename, but will instead be a normal path pattern that is anchored to the current base path, in this case <code>.</code>.</p> <pre><code>&gt;&gt;&gt; wcmatch.WcMatch('.', '/*.md', flags=wcmatch.FILEPATHNAME | wcmatch.GLOBSTAR | wcmatch.MATCHBASE | wcmatch.RECURSIVE).match()\n['./LICENSE.md', './README.md']\n</code></pre>"},{"location":"wcmatch/#globstar","title":"<code>wcmatch.GLOBSTAR, wcmatch.G</code>","text":"<p>When the <code>PATHNAME</code> flag is provided, you can also enable <code>GLOBSTAR</code> to enable the recursive directory pattern matches with <code>**</code>.</p> <pre><code>&gt;&gt;&gt; from wcmatch import wcmatch\n&gt;&gt;&gt; wcmatch.WcMatch('.', '*.md|*.txt', '**/markdown', flags=wcmatch.DIRPATHNAME | wcmatch.GLOBSTAR | wcmatch.RECURSIVE).match()\n['./LICENSE.md', './README.md', './requirements/docs.txt', './requirements/lint.txt', './requirements/setup.txt', './requirements/test.txt']\n</code></pre> <ol> <li> <p>Identical patterns are only reduced by comparing case sensitively as POSIX character classes are case sensitive: <code>[[:alnum:]]</code> \u2260 <code>[[:ALNUM:]]</code>.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"about/changelog/","title":"Changelog","text":""},{"location":"about/changelog/#101","title":"10.1","text":"<ul> <li>NEW: Drop support for Python 3.8 which is \"end of life\".</li> <li>NEW: Add support for Python 3.14.</li> <li>NEW: Add <code>wcmatch.glob.compile(pattern)</code> and <code>wcmatch.fnmatch.compile(pattern)</code> to allow for precompiled matcher     objects that can be reused.</li> </ul>"},{"location":"about/changelog/#100","title":"10.0","text":"<ul> <li>NEW: Added <code>GLOBSTARLONG</code> which adds support for the Zsh style <code>***</code> which acts like <code>**</code> with <code>GLOBSTAR</code> but     traverses symlinks.</li> <li>NEW: <code>pathlib.match</code> will respect symlink rules (when the <code>REALPATH</code> flag is given). Hidden file rules will     be respected at all times. Enable <code>DOTALL</code> to match hidden files.</li> <li>NEW: Symlinks should not be traversed when <code>GLOBSTAR</code> is enabled unless <code>FOLLOW</code> is also enabled, but they     should still be matched. Prior to this change, symlinks were not traversed and they were ignored from matching     which contradicts how Bash works and could be confusing to users.</li> <li>FIX: Fix some inconsistencies with <code>globmatch</code> and symlink handling when <code>REALPATH</code> is enabled.</li> </ul>"},{"location":"about/changelog/#90","title":"9.0","text":"<ul> <li>NEW: Remove deprecated function <code>glob.raw_escape</code>.</li> <li>NEW: Officially support Python 3.13.</li> </ul>"},{"location":"about/changelog/#852","title":"8.5.2","text":"<ul> <li>FIX: Fix <code>pathlib</code> issue with inheritance on Python versions greater than 3.12.</li> <li>FIX: Fix <code>EXTMATCH</code> case with <code>!(...)</code> patterns.</li> </ul>"},{"location":"about/changelog/#851","title":"8.5.1","text":"<ul> <li>FIX: Fix issue with type check failure in <code>wcmatch.glob</code>.</li> </ul>"},{"location":"about/changelog/#85","title":"8.5","text":"<ul> <li>NEW: Formally support Python 3.11 (no change).</li> <li>NEW: Add support for Python 3.12 (<code>pathlib</code> changes).</li> <li>NEW: Drop Python 3.7 support.</li> <li>FIX: Fix handling of current directory when magic and non-magic patterns are mixed in <code>glob</code> pattern list.</li> </ul>"},{"location":"about/changelog/#841","title":"8.4.1","text":"<ul> <li>FIX: Windows drive path separators should normalize like other path separators.</li> <li>FIX: Fix a Windows pattern parsing issue that caused absolute paths with ambiguous drives to not parse     correctly.</li> </ul>"},{"location":"about/changelog/#84","title":"8.4","text":"<ul> <li>NEW: Drop support for Python 3.6.</li> <li>NEW: Switch to Hatch backend instead of Setuptools.</li> <li>NEW: Add new <code>exclude</code> option to <code>fnmatch</code>, <code>pathlib</code>, and <code>glob</code> methods that allows exclusion patterns to be     specified directly without needing to enable <code>NEGATE</code> and prepend patterns with <code>!</code>. <code>exclude</code> accepts a separate     pattern or pattern list. <code>exclude</code> should not be used in conjunction with <code>NEGATE</code>. One or the other should be used.</li> </ul>"},{"location":"about/changelog/#83","title":"8.3","text":"<ul> <li>NEW: Officially support Python 3.10.</li> <li>NEW: Provide type hints for API.</li> <li>FIX: Gracefully handle calls with an empty pattern list.</li> </ul>"},{"location":"about/changelog/#82","title":"8.2","text":"<ul> <li>NEW: Add support for <code>dir_fd</code> in glob patterns.</li> <li>FIX: Small fix for Python 3.10 Beta 1 and <code>pathlib</code>.</li> </ul>"},{"location":"about/changelog/#812","title":"8.1.2","text":"<ul> <li>FIX: <code>fnmatch.translate</code> no longer requires user to normalize their Windows paths for comparison. Previously,     portions of the <code>translate</code> regex handled both <code>/</code> and <code>\\\\</code>, while other portions did not. This inconsistent     handling forced users to normalize paths for reliable matching. Now all of the generated regex should handle both     <code>/</code> and <code>\\\\</code>.</li> <li>FIX: On Linux/Unix systems, a backslash should not be assumed literal if it is followed by a forward slash.     Backslash is magic on all systems, and an escaped forward slash is still counted as a forward slash, not a backslash     and forward slash.</li> <li>FIX: A trailing backslash that is not escaped via another backslash should not be assumed as a backslash. Since     it is escaping nothing, it will be ignored. Literal backslashes on any system must be escaped.</li> </ul>"},{"location":"about/changelog/#811","title":"8.1.1","text":"<ul> <li>FIX: When tracking unique glob paths, the unique cache had inverted logic for case sensitive vs case insensitive     comparison. (#164)</li> </ul>"},{"location":"about/changelog/#81","title":"8.1","text":"<ul> <li>NEW: Add <code>is_magic</code> function to the <code>glob</code> and <code>fnmatch</code> library.</li> <li>NEW: <code>fnmatch</code> now has <code>escape</code> available via its API. The <code>fnmatch</code> variant uses filename logic instead of path     logic.</li> <li>NEW: Deprecate <code>raw_escape</code> in <code>glob</code> as it is very niche and the same can be accomplished simply by using     <code>codecs.decode(string, 'unicode_escape')</code> and then using <code>escape</code>.</li> <li>FIX: Use <code>os.fspath</code> to convert path-like objects to string/bytes, whatever the return from <code>__fspath__</code> is what     Wildcard Match will accept. Don't try to convert paths via <code>__str__</code> or <code>__bytes__</code> as not all path-like objects may     implement both.</li> <li>FIX: Better checking of types to ensure consistent failure if the path, pattern, or root directory of are not     all of type <code>str</code> or <code>bytes</code>.</li> <li>FIX: Some internal fixes and refactoring.</li> <li>FIX: Refactor code to take advantage of <code>bracex</code>'s ability to abort parsing on extremely large pattern     expansions. Patterns like <code>{1..10000000}</code> will now abort dramatically quicker. Require <code>bracex</code> 2.1.1 which aborts     much quicker.</li> <li>FIX: Fix some corner cases where limit would not abort correctly.</li> </ul>"},{"location":"about/changelog/#801","title":"8.0.1","text":"<ul> <li>FIX: Small bug in <code>[:alpha:]</code> range.</li> </ul>"},{"location":"about/changelog/#80","title":"8.0","text":"<ul> <li>NEW: <code>WcMatch</code>'s <code>on_init</code> hook now only accepts <code>kwargs</code> and not <code>args</code>.</li> <li>NEW: Cosmetic change of referring to the first <code>__init__</code> parameter as <code>root_dir</code> instead of <code>base</code>. This is to     make it more clear when we are talking about the overall root directory that all paths are relative to vs the base     path of a file which is relative to the root directory and the actual file name.</li> <li>NEW: Internal attribute of <code>WcMatch</code> changed from <code>base</code> to <code>_root_dir</code>. This attribute is not really meant to be     referenced by users and as been marked as private.</li> <li>NEW: Drop requirement for <code>backrefs</code> and update documentation to note that POSIX properties never actually     enabled the use of Unicode properties. While the documentation stated this and it was probably intended, it was     never actually enabled. Currently, Wildcard match has chosen to keep with the ASCII definition for now as it has     been since the feature was introduced. This may change in the future if there is demand for it.</li> <li>NEW: Add <code>[:word:]</code> POSIX character class.</li> </ul>"},{"location":"about/changelog/#72","title":"7.2","text":"<ul> <li>NEW: Drop Python 3.5 support.</li> <li>NEW: Formally support Python 3.9 support.</li> <li>FIX: Small fix for regular expression output to ensure <code>NODIR</code> pattern looks at both <code>/</code> and <code>\\\\</code> on Windows.</li> </ul>"},{"location":"about/changelog/#71","title":"7.1","text":"<ul> <li>NEW: Translate functions will now use capturing groups for <code>EXTGLOB</code>/<code>EXTMATCH</code> groups in the returned regular     expression patterns.</li> </ul>"},{"location":"about/changelog/#701","title":"7.0.1","text":"<ul> <li>FIX: Ensure that when using <code>REALPATH</code> that all symlinks are evaluated.</li> <li>FIX: Fix issue where an extended pattern can't follow right behind an inverse extended pattern.</li> <li>FIX: Fix issues related to nested inverse glob patterns.</li> </ul>"},{"location":"about/changelog/#70","title":"7.0","text":"<p>Check out Release Notes to learn more about upgrading to 7.0.</p> <ul> <li>NEW: Recognize extended UNC paths.</li> <li>NEW: Allow escaping any character in Windows drives for better compatibility with <code>SPLIT</code> and <code>BRACE</code> which     requires a user to escape <code>{</code>, <code>}</code> and <code>|</code> to avoid expanding a pattern.</li> <li>NEW: <code>raw_escape</code> now accepts the <code>raw_chars</code> parameter so that translation of Python character back references     can be disabled.</li> <li>NEW: Search functions that use <code>scandir</code> will not return <code>.</code> and <code>..</code> for wildcard patterns that require     iterating over a directory to match the files against a pattern. This matches Python's glob and is most likely what     most users expect. Pattern matching logic is unaffected.</li> <li>NEW: Add <code>SCANDOTDIR</code> flag to enable previous behavior of injecting <code>.</code> and <code>..</code> in <code>scandir</code> results.     <code>SCANDOTDIR</code> has no affect on match functions such as <code>globmatch</code> which don't use directory scanning.</li> <li>NEW: Flag <code>NODOTDIR</code> has been added to disable patterns such as <code>.*</code> from matching <code>.</code> and <code>..</code>. When enabled,     matching logic is changed to require a literal pattern of <code>.</code> and <code>..</code> to match the special directories <code>.</code> and <code>..</code>.     This is more Zsh like.</li> <li>FIX: Negative extended glob patterns (<code>!(...)</code>) incorrectly allowed for hidden files to be returned when one of     the subpatterns started with <code>.</code>, even when <code>DOTMATCH</code>/<code>DOTGLOB</code> was not enabled.</li> <li>FIX: When <code>NOUNIQUE</code> is enabled and <code>pathlib</code> is being used, you could still get non-unique results across     patterns expanded with <code>BRACE</code> or <code>SPLIT</code> (or even by simply providing a list of patterns). Ensure that unique     results are only returned when <code>NOUNIQUE</code> is not enabled.</li> <li>FIX: Fix corner cases with <code>escape</code> and <code>raw_escape</code> with back slashes.</li> <li>FIX: Ensure that <code>globmatch</code> does not match <code>test//</code> with pattern <code>test/*</code>.</li> <li>FIX: <code>pathlib.match</code> should not evaluate symlinks that are on the left hand side of what was matched.</li> </ul>"},{"location":"about/changelog/#61","title":"6.1","text":"<ul> <li>NEW: <code>EXTMATCH</code>/<code>EXTGLOB</code> can now be used with <code>NEGATE</code> without needing <code>MINUSNEGATE</code>. If a pattern starts with     <code>!(</code>, and <code>NEGATE</code> and <code>EXTMATCH</code>/<code>EXTGLOB</code> are both enabled, the pattern will not be treated as a <code>NEGATE</code> pattern     (even if <code>!(</code> doesn't yield a valid <code>EXTGLOB</code> pattern). To negate a pattern that starts with a literal <code>(</code>, you must     escape the bracket: <code>!\\(</code>.</li> <li>FIX: Support Python 3.9.</li> <li>FIX: Adjust pattern limit logic of <code>glob</code> to be consistent with other functions.</li> </ul>"},{"location":"about/changelog/#603","title":"6.0.3","text":"<ul> <li>FIX: Fix issue where when <code>FOLLOW</code> and <code>GLOBSTAR</code> were used, a pattern like <code>**/*</code> would not properly match     a directory which was a symlink. While Bash does not return a symlinked folder with <code>**</code>, <code>*</code> (and other patterns),     should properly find the symlinked directory.</li> <li>FIX: <code>pathlib</code> clearly states that the <code>match</code> method, if the pattern is relative, matches from the right.     Wildcard Match used the same implementation that <code>rglob</code> used, which prepends <code>**/</code> to a relative pattern. This is     essentially like <code>MATCHBASE</code>, but allows for multiple directory levels. This means that dot files (and special     folders such as <code>.</code> and <code>..</code>) on the left side could prevent the path from matching depending on flags that were     set. <code>match</code> will now be evaluated in such a way as to give the same right to left matching feel that Python's     <code>pathlib</code> uses.</li> </ul>"},{"location":"about/changelog/#602","title":"6.0.2","text":"<ul> <li>FIX: Fix logic related to dot files and <code>GLOBSTAR</code>. Recursive directory search should return all dot files,     which should then be filtered by the patterns. They should not be excluded before being filtered by the pattern.</li> </ul>"},{"location":"about/changelog/#601","title":"6.0.1","text":"<ul> <li>FIX: If we only have one pattern (exclusion patterns not included) we can disable unique path filtering on     returns as you cannot have a duplicate path with only one inclusion pattern.</li> </ul>"},{"location":"about/changelog/#60","title":"6.0","text":"<ul> <li>NEW: Tilde user expansion support via the new <code>GLOBTILDE</code> flag.</li> <li>NEW: <code>glob</code> by default now returns only unique results, regardless of whether multiple patterns that match the     same file were provided, or even when <code>BRACE</code> or <code>SPLIT</code> expansion produces new patterns that match the same file.</li> <li>NEW: A new flag called <code>NOUNIQUE</code> has been added that makes <code>glob</code> act like Bash, which will return the same     file multiple times if multiple patterns match it, whether provided directly or due to the result of <code>BRACE</code> or     <code>SPLIT</code> expansion.</li> <li>NEW: Limit number of patterns that can be processed (expanded and otherwise) to 1000. Allow user to change this     value via an optional <code>limit</code> parameter in related API functions.</li> <li>FIX: Matching functions that receive multiple patterns, or that receive a single pattern that expands to     multiple, will filter out duplicate patterns in order avoid redundant matching. While the <code>WcMatch</code> class crawls the     file system, it utilizes the aforementioned matching functions in it's operation, and indirectly takes advantage of     this. <code>glob</code> (and related functions: <code>rglob</code>, <code>iglob</code>, etc.) will also filter redundant patterns except when     <code>NOUNIQUE</code> is enabled, this is so they can better act like Bash when <code>NOUNIQUE</code> is enabled.</li> <li>FIX: <code>BRACE</code> is now processed before <code>SPLIT</code> in order to fix a number of edge cases.</li> <li>FIX: <code>RAWCHARS</code> was inconsistently applied at different times depending on what was calling it. It is now     applied first followed by <code>BRACE</code>, <code>SPLIT</code>, and finally <code>GLOBTILDE</code>.</li> </ul>"},{"location":"about/changelog/#510","title":"5.1.0","text":"<ul> <li>NEW: Add new parameter to <code>glob</code> related functions (except in <code>pathlib</code>) called <code>root_dir</code> that allows a user to     specify a different working directory with either a string or path-like object. Path-like inputs are only supported     on Python 3.6+.</li> <li>NEW: Support path-like objects for <code>globmatch</code> and <code>globfilter</code> path inputs. Path-like inputs are only supported     on Python 3.6+.</li> <li>FIX: Filter functions should not alter the slashes of files it filters. Filtered strings and paths should be     returned unaltered.</li> </ul>"},{"location":"about/changelog/#503","title":"5.0.3","text":"<ul> <li>FIX: Rework <code>glob</code> relative path handling so internally it is indistinguishable from when it is given no     relative path and uses the current working directory. This fixes an issue where <code>pathlib</code> couldn't handle negate     patterns properly (<code>!negate</code>).</li> </ul>"},{"location":"about/changelog/#502","title":"5.0.2","text":"<ul> <li>FIX: Fix case where a <code>GLOBSTAR</code> pattern, followed by a slash, was not disabling <code>MATCHBASE</code>.</li> <li>FIX: Fix <code>pathlib</code> relative path resolution in glob implementations.</li> </ul>"},{"location":"about/changelog/#501","title":"5.0.1","text":"<ul> <li>FIX: In <code>glob</code>, avoid using up too many file descriptors by acquiring all file/folder names under a directory in     one batch before recursing into other folders.</li> </ul>"},{"location":"about/changelog/#50","title":"5.0","text":"<ul> <li>NEW: Add <code>wcmatch.pathlib</code> which contains <code>pathlib</code> variants that uses <code>wcmatch.glob</code> instead of the default     Python glob.</li> <li>NEW: <code>escape</code> and <code>raw_escape</code> can manually be forced to use Windows or Linux/Unix logic via the keyword only     argument by setting to <code>False</code> or <code>True</code> respectively. The default is <code>None</code> which will auto detect the system.</li> <li>NEW: The deprecated flag <code>FORCECASE</code> has now been removed.</li> <li>NEW: The deprecated functions <code>globsplit</code> and <code>fnsplit</code> have been removed.</li> <li>NEW: The deprecated variables <code>version</code> and <code>version_info</code> have been removed.</li> </ul>"},{"location":"about/changelog/#431","title":"4.3.1","text":"<ul> <li>FIX: Regression for root level literal matches in <code>glob</code>.</li> <li>FIX: Bug where <code>glob</code> would mistakenly abort if a pattern started with a literal file or directory and could not     match a file or directory. This caused subsequent patterns in the chain to not get evaluated.</li> </ul>"},{"location":"about/changelog/#430","title":"4.3.0","text":"<ul> <li>NEW: Add <code>CASE</code> flag which allows for case sensitive paths on Linux, macOS, and Windows. Windows drive letters     and UNC <code>//host-name/share-name/</code> portion are still treated insensitively, but all directories will be treated with     case sensitivity.</li> <li>NEW: With the recent addition of <code>CASE</code> and <code>FORCEUNIX</code>, <code>FORCECASE</code> is no longer needed. Deprecate <code>FORCECASE</code>     which will be removed at some future point.</li> </ul>"},{"location":"about/changelog/#420","title":"4.2.0","text":"<ul> <li>NEW: Drop Python 3.4 support.</li> <li>NEW: Add flags <code>FORCEWIN</code> and <code>FORCEUNIX</code> to force Windows or Linux/Unix path logic on commands that do not     access the file system: <code>translate</code>, <code>fnmatch</code>, <code>filter</code>, <code>globmatch</code>, <code>globfilter</code>, etc. These flags will not work     with <code>glob</code>, <code>iglob</code> or with the <code>WcMatch</code> class. It also will not work when using the <code>REALPATH</code> flag with things     like <code>fnmatch</code>, <code>filter</code>, <code>globmatch</code>, <code>globfilter</code>.</li> <li>FIX: <code>glob</code> corner case where the first folder, if defined as a literal name (not a magic pattern), would not be     treated properly if <code>IGNORECASE</code> was enabled in Linux.</li> </ul>"},{"location":"about/changelog/#410","title":"4.1.0","text":"<ul> <li>NEW: Add <code>WcMatch.is_aborted</code>.</li> <li>FIX: Remove deprecation of <code>kill</code> and <code>reset</code> in <code>WcMatch</code>. There are legitimate reasons to not deprecate     killing via <code>kill</code> instead of simply breaking.</li> <li>FIX: If for any reason, a file exists, but fails \"is directory\" check, consider it as a file.</li> </ul>"},{"location":"about/changelog/#401","title":"4.0.1","text":"<ul> <li>FIX: Fix regression with exclusion patterns that use braces in <code>glob</code>.</li> <li>FIX: Translate functions should have <code>NODIR</code> patterns exclude if matched not exclude if not matched.</li> </ul>"},{"location":"about/changelog/#40","title":"4.0","text":"<ul> <li>NEW: Deprecated <code>WcMatch</code> class methods <code>kill</code> and <code>reset</code>. <code>WcMatch</code> should be broken with a simple <code>break</code>     statement instead.</li> <li>NEW: Add a new flag <code>MARK</code> to force <code>glob</code> to return directories with a trailing slash.</li> <li>NEW: Add <code>MATCHBASE</code> that causes glob related functions and <code>WcMatch</code>, when the pattern has no slashes in it, to     seek for any file anywhere in the tree with a matching basename.</li> <li>NEW: Add <code>NODIR</code> that causes <code>glob</code> matchers and crawlers to only match and return files.</li> <li>NEW: Exclusion patterns (enabled with <code>NEGATE</code>) now always enable <code>DOTALL</code> in the exclusion patterns. They also     will match symlinks in <code>**</code> patterns. Only non <code>NEGATE</code> patterns that are paired with a <code>NEGATE</code> pattern are subject     to symlinks and dot rules. Exclusion patterns themselves allow dots and symlinks to make filtering easier.</li> <li>NEW: Exclusion patterns no longer provide a default inclusion pattern if one is not specified. Exclusion     patterns are meant to filter the results of inclusion patterns. You can either use the <code>SPLIT</code> flag and provide an     inclusion pattern with your default ('default_pattern|!exclusion'), or feed in a list of multiple patterns instead     of a single string (<code>['inclusion', '!exclusion']</code>). If you really need the old behavior, you can use the <code>NEGATEALL</code>     flag which will provide a default inclusion pattern that matches all files.</li> <li>NEW: Translate now outputs exclusion patterns so that if they match, the file is excluded. This is opposite     logic to how it used to be, but is more efficient.</li> <li>FIX: An empty pattern in <code>glob</code> should not match slashes.</li> </ul>"},{"location":"about/changelog/#302","title":"3.0.2","text":"<ul> <li>FIX: Fix an offset issue when processing an absolute path pattern in <code>glob</code> on Linux or macOS.</li> <li>FIX: Fix an issue where the <code>glob</code> command would use <code>GLOBSTAR</code> logic on <code>**</code> even when <code>GLOBSTAR</code> was disabled.</li> </ul>"},{"location":"about/changelog/#301","title":"3.0.1","text":"<ul> <li>FIX: In the <code>WcMatch</code> class, defer hidden file check until after the file or directory is compared against     patterns to potentially avoid calling hidden if the pattern doesn't match. The reduced <code>lstat</code> calls improve     performance.</li> </ul>"},{"location":"about/changelog/#30","title":"3.0","text":"<ul> <li>NEW: <code>globsplit</code> and <code>fnsplit</code> have been deprecated. Users are encouraged to use the new <code>SPLIT</code> flag to allow     functions to use multiple wildcard paths delimited by <code>|</code>.</li> <li>NEW: <code>globmatch</code> and <code>globfilter</code> will now parse provided paths as real paths if the new <code>REALPATH</code> flag is set.     This has the advantage of allowing the commands to be aware of symlinks and properly apply related logic (whether to     follow the links or not). It also helps to clarify ambiguous cases where it isn't clear if a file path references a     directory because the trailing slash was omitted. It also allows the command to be aware of Windows drives evaluate     the path in proper context compared to the current working directory.</li> <li>NEW: <code>WcMatch</code> class no longer accepts the <code>recursive</code> or <code>show_hidden</code> parameter, instead the <code>RECURSIVE</code> or     <code>HIDDEN</code> flag must be used.</li> <li>NEW: <code>WcMatch</code> class now can search symlink directories with the new <code>SYMLINK</code> flag.</li> <li>NEW: <code>glob</code> and <code>iglob</code> functions now behave like Bash 5.0 in regards to symlinks in <code>GLOBSTAR</code> (<code>**</code>).     <code>GLOBSTAR</code> will ignore symlink directories. This affects other functions such as <code>globmatch</code> and <code>globfilter</code> when     the <code>REALPATH</code> flag is enabled.</li> <li>NEW: New flag called <code>FOLLOW</code> was added to force related <code>glob</code> commands to recognize and follow symlink     directories.</li> <li>FIX: Fix <code>glob</code> regression where inverse patterns such as <code>!**/test/**</code> would allow a directory <code>base/test</code> to     match when it should have excluded it.</li> <li>FIX: <code>glob</code> should handle root paths (<code>/</code>) properly, and on Windows, it should assume the drive of the current     working directory.</li> </ul>"},{"location":"about/changelog/#221","title":"2.2.1","text":"<ul> <li>FIX: <code>EXTMATCH</code>/<code>EXTGLOB</code> should allow literal dots and should not treat dots like sequences do.</li> <li>FIX: Fix <code>!(...)</code> extended match patterns in <code>glob</code> and <code>globmatch</code> so that they properly match <code>.</code> and <code>..</code> if     their pattern starts with <code>.</code>.</li> <li>FIX: Fix <code>!(...)</code> extended match patterns so that they handle path separators correctly.</li> <li>FIX: Patterns such as <code>?</code> or <code>[.]</code> should not trigger matching directories <code>.</code> and <code>..</code> in <code>glob</code> and     <code>globmatch</code>.</li> </ul>"},{"location":"about/changelog/#220","title":"2.2.0","text":"<ul> <li>NEW: Officially support Python 3.8.</li> </ul>"},{"location":"about/changelog/#210","title":"2.1.0","text":"<ul> <li>NEW: Deprecate <code>version</code> and <code>version_info</code> in favor of the more standard <code>__version__</code> and <code>__version_info__</code>.</li> <li>FIX: Fix issue where exclusion patterns would trigger before end of path.</li> <li>FIX: Fix <code>GLOBSTAR</code> regular expression pattern issues.</li> </ul>"},{"location":"about/changelog/#203","title":"2.0.3","text":"<ul> <li>FIX: In <code>glob</code>, properly handle files in the current working directory when give a literal pattern that matches     it.</li> </ul>"},{"location":"about/changelog/#202","title":"2.0.2","text":"<ul> <li>FIX: <code>wcmatch</code> override events (<code>on_error</code> and <code>on_skip</code>) should verify the return  is not None and not     not falsy.</li> </ul>"},{"location":"about/changelog/#201","title":"2.0.1","text":"<ul> <li>FIX: Can't install due to requirements being assigned to setup opposed to install.</li> </ul>"},{"location":"about/changelog/#20","title":"2.0","text":"<p>Breaking Changes</p> <p>Version 2.0 introduces breaking changes in regards to flags.  This is meant to bring about consistency amongst the provided libraries. Flag names have been changed in some cases, and logic has been inverted in some cases.</p> <ul> <li>NEW: Glob's <code>NOBRACE</code>, <code>NOGLOBSTAR</code>, and <code>NOEXTGLOB</code> flags are now <code>BRACE</code>, <code>GLOBSTAR</code>, and <code>EXTGLOB</code> and now     enable the features instead of disabling the features. This logic matches the provided <code>fnmatch</code> and <code>wcmatch</code>.</li> <li>NEW: Glob's <code>DOTGLOB</code> and <code>EXTGLOB</code> also have the respective aliases <code>DOTMATCH</code> and <code>EXTMATCH</code> to provide     consistent flags across provided libraries, but the <code>GLOB</code> variants that match Bash's feature names can still be     used.</li> <li>NEW: <code>fnmatch</code>'s <code>PERIOD</code> flag has been replaced with <code>DOTMATCH</code> with inverted logic from what was originally     provided.</li> <li>NEW: Documentation exposes the shorthand form of flags: <code>FORCECASE</code> \u2192 <code>F</code>, etc.</li> <li>FIX: Wcmatch always documented that it had the flag named <code>EXTMATCH</code>, but internally it was actually <code>EXTGLOB</code>,     this was a bug though. <code>EXTMATCH</code> is now the documented and the actual flag to use.</li> </ul>"},{"location":"about/changelog/#102","title":"1.0.2","text":"<ul> <li>FIX: Officially support Python 3.7.</li> </ul>"},{"location":"about/changelog/#101_1","title":"1.0.1","text":"<ul> <li>FIX: Ensure that all patterns in <code>glob</code> that have a directory preceding <code>**</code> but also end with <code>**</code> returns the     preceding directory.</li> <li>FIX: Fix byte conversion in path normalization.</li> <li>FIX: Ensure POSIX character classes, when at the start of a sequence, properly have hyphens escaped following     it. <code>[[:ascii:]-z]</code> should convert to <code>[\\x00-\\x7f\\\\-b]</code> not <code>[\\x00-\\x7f-b]</code>.</li> <li>FIX: Fix an issue where we would fail because we couldn't covert raw characters even though raw character     parsing was disabled.</li> <li>FIX: Better default for file patterns.  Before if no pattern was provided for files, <code>'*'</code> was assumed, now it     is <code>''</code>, and if <code>''</code> is used, all files will be matched. This works better for when full path is enabled as you get     the same file matching logic.</li> </ul>"},{"location":"about/changelog/#10","title":"1.0","text":"<ul> <li>NEW: Initial release</li> </ul>"},{"location":"about/contributing/","title":"Contributing &amp; Support","text":""},{"location":"about/contributing/#become-a-sponsor","title":"Become a Sponsor","text":"<p>Open source projects take time and money. Help support the project by becoming a sponsor. You can add your support at any tier you feel comfortable with. No amount is too little. We also accept one time contributions via PayPal.</p> <p> GitHub Sponsors  PayPal</p>"},{"location":"about/contributing/#bug-reports","title":"Bug Reports","text":"<ol> <li> <p>Please read the documentation and search the issue tracker to try and find the answer to your question     before posting an issue.</p> </li> <li> <p>When creating an issue on the repository, please provide as much info as possible:</p> <ul> <li>Version being used.</li> <li>Operating system.</li> <li>Version of Python.</li> <li>Errors in console.</li> <li>Detailed description of the problem.</li> <li>Examples for reproducing the error.  You can post pictures, but if specific text or code is required to     reproduce the issue, please provide the text in a plain text format for easy copy/paste.</li> </ul> <p>The more info provided, the greater the chance someone will take the time to answer, implement, or fix the issue.</p> </li> <li> <p>Be prepared to answer questions and provide additional information if required.  Issues in which the creator refuses     to respond to follow up questions will be marked as stale and closed.</p> </li> </ol>"},{"location":"about/contributing/#reviewing-code","title":"Reviewing Code","text":"<p>Take part in reviewing pull requests and/or reviewing direct commits.  Make suggestions to improve the code and discuss solutions to overcome weakness in the algorithm.</p>"},{"location":"about/contributing/#answer-questions-in-issues","title":"Answer Questions in Issues","text":"<p>Take time and answer questions and offer suggestions to people who've created issues in the issue tracker. Often people will have questions that you might have an answer for.  Or maybe you know how to help them accomplish a specific task they are asking about. Feel free to share your experience to help others out.</p>"},{"location":"about/contributing/#pull-requests","title":"Pull Requests","text":"<p>Pull requests are welcome, and a great way to help fix bugs and add new features.</p>"},{"location":"about/contributing/#documentation-improvements","title":"Documentation Improvements","text":"<p>A ton of time has been spent not only creating and supporting this tool and related extensions, but also spent making this documentation.  If you feel it is still lacking, show your appreciation for the tool and/or extensions by helping to improve the documentation.</p>"},{"location":"about/license/","title":"License","text":""},{"location":"about/license/#wildcard-match","title":"Wildcard Match","text":"<p>MIT License</p> <p>Copyright \u00a9 2018 - 2025 Isaac Muse</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"about/release/","title":"Release Notes","text":""},{"location":"about/release/#upgrade-to-8.0","title":"Upgrade to 8.0","text":"<p>Notable changes are minor and will affect very few. This should clarify breaking changes and how to migrate if applicable.</p>"},{"location":"about/release/#wcmatch-class-initialization-hook","title":"<code>WcMatch</code> class Initialization Hook","text":"<p>The <code>WcMatch</code> class <code>on_init</code> hook was cleaned up. Prior to 8.0, it accepted both <code>*args</code> and <code>**kwargs</code> which is quite difficult to maintain and honestly for users to use.</p> <p>Moving forward, the <code>WcMatch</code> class will restrict all parameters to <code>**kwargs</code>. If you are using the <code>on_init</code> hook, you will simply need to change your override to accept arguments as <code>**kwargs</code>:</p> <pre><code># Excplicitly named\ndef on_init(self, key1=value, key2=value):\n\n# Or just use `**kwargs`\ndef on_init(self, **kwargs):\n</code></pre> <p>Lastly, only pass your custom variables in as keyword arguments:</p> <pre><code>CustomWcmatch('.', '*.md|*.txt', flags=wcmatch.RECURSIVE, custom_key=value)\n</code></pre>"},{"location":"about/release/#upgrade-to-7.0","title":"Upgrade to 7.0","text":"<p>Notable changes will be highlighted here to help with migration to 7.0.</p>"},{"location":"about/release/#globbing-special-directories","title":"Globbing Special Directories","text":"<p>File globbing with <code>glob.glob</code>,  <code>glob.iglob</code>, <code>pathlib.path.glob</code>, and <code>pathlib.Path.rglob</code> no longer inject <code>.</code> and <code>..</code> into results when scanning directories. This only affects the results of a scanned directory and does not fundamentally change how glob patterns evaluate a path.</p> <p>Python's default glob does not return <code>.</code> or <code>..</code> for any \"magic\" (non-literal) patterns in <code>glob</code>. This is because magic patterns trigger glob to iterate over a directory in an attempt to find a file that can match the given \"magic\" pattern. Since <code>.</code> and <code>..</code> are not returned by Python's implementation of <code>scandir</code>, <code>.</code> and <code>..</code> never get evaluated. Literal patterns can side step the directory iteration with a simple check to see if the file exists. What this means is that a \"magic\" pattern of <code>.*</code> will not match <code>.</code> or <code>..</code>, because it is not returned in the scan, but a literal pattern of <code>.</code> or <code>..</code> will as the literal patterns are simply checked to see if they exist.</p> <p>This is common behavior for a number of libraries, Python, [node-glob], etc., but not all. Moving forward, we have chosen to adopt the Python's behavior as our default behavior, with the option of forcing Bash's behavior of returning <code>.</code> and <code>..</code> in a directory scan if desired.</p> <p>These examples will illustrate the behavior. In the first example, Python's <code>pathlib</code> is used to glob a directory. We can note that not a single entry in the results is <code>.</code> or <code>..</code>.</p> <pre><code>&gt;&gt;&gt; import pathlib\n&gt;&gt;&gt; list(pathlib.Path('.').glob('.*'))\n[PosixPath('.DS_Store'), PosixPath('.codecov.yml'), PosixPath('.tox'), PosixPath('.coverage'), PosixPath('.coveragerc'), PosixPath('.gitignore'), PosixPath('.github'), PosixPath('.pyspelling.yml'), PosixPath('.git')]\n</code></pre> <p>We can also show that if we search for the literal pattern of <code>..</code> that glob will then return <code>..</code> in the results.</p> <pre><code>&gt;&gt;&gt; import pathlib\n&gt;&gt;&gt; list(pathlib.Path('.').glob('..'))\n[PosixPath('..')]\n</code></pre> <p>When using the <code>match</code> function, we see that the pattern can match <code>..</code> just fine. This illustrates that it is not the pattern logic that restricts this, but a result of the behavior exhibited by <code>scandir</code>.</p> <pre><code>&gt;&gt;&gt; import pathlib\n&gt;&gt;&gt; pathlib.Path('..').match('.*')\nTrue\n</code></pre> <p>While our algorithm is different due to some of the features we support, and it may oversimplify things to say we now turn off injecting <code>.</code> and <code>..</code> into <code>scandir</code> results, but for all intents and purposes, all of our file system globbing functions exhibit the same behavior as Python's default glob now.</p> <pre><code>&gt;&gt;&gt; from wcmatch import glob\n&gt;&gt;&gt; glob.glob('.*')\n['.DS_Store', '.codecov.yml', '.tox', '.coverage', '.coveragerc', '.gitignore', '.github', '.pyspelling.yml', '.git']\n&gt;&gt;&gt; glob.glob('..')\n['..']\n&gt;&gt;&gt; glob.globmatch('..', '.*')\nTrue\n</code></pre> <p>Because this change only affects how files are returned when iterating the directories, we can notice that exclude patterns, which are used to filter the results, can match <code>.</code> or <code>..</code> with <code>.*</code>:</p> <pre><code>&gt;&gt;&gt; from wcmatch import glob\n&gt;&gt;&gt; glob.glob('..')\n['..']\n&gt;&gt;&gt; glob.glob(['..', '!.*'], flags=glob.NEGATE)\n[]\n</code></pre> <p>If we want to modify the pattern matcher, and not just the directory scanner, we can use the flag <code>NODITDIR</code>.</p> <pre><code>&gt;&gt;&gt; from wcmatch import glob\n&gt;&gt;&gt; glob.glob(['..', '!.*'], flags=glob.NEGATE | glob.NODOTDIR)\n['..']\n&gt;&gt;&gt; glob.glob(['..', '!..'], flags=glob.NEGATE | glob.NODOTDIR)\n[]\n</code></pre> <p>These changes were done for a couple of reasons:</p> <ol> <li> <p>Generally, it is rare to specifically want <code>.</code> and <code>..</code>, so often when people glob with something like <code>**/.*</code>, they     are just trying to get hidden files. While we generally model our behavior off Bash, there are many alternative     shells (such as Zsh) that do not return or match <code>.</code> and <code>..</code> with magic patterns by design, regardless of what     directory scanner returns.</p> </li> <li> <p>Many people who come to use our library are probably coming from having experience with Python's glob. By mirroring     this behavior out of the box, it may help people adapt to the library easier.</p> </li> <li> <p>Python's <code>pathlib</code>, which Wildcard Match's <code>pathlib</code> is derived from, normalizes paths by stripping out <code>.</code>     directories and trimming off trailing slashes.  This means patterns such as <code>**/.*</code>, which would normally match both     <code>.hidden</code> and <code>.hidden/.</code>, would normalize those results to return two <code>.hidden</code> results. Mirroring this behavior     helps provide more sane results and prevent confusing duplicates when using <code>pathlib</code>.</p> </li> <li> <p>This is not unique behavior to Python's glob and our implementation. For example, let's take a look at     <code>node-glob</code> and its underlying match library called     <code>minimatch</code>.</p> <pre><code>&gt; glob('.*', {}, function (er, files) {\n... console.log(files)\n... })\n&gt; [\n  '.codecov.yml',\n  '.coverage',\n  '.coveragerc',\n  '.DS_Store',\n  '.git',\n  '.github',\n  '.gitignore',\n  '.pyspelling.yml',\n  '.tox'\n]\n</code></pre> <p>We also see that the file matching library has no issues matching <code>.</code> or <code>..</code> with <code>.*</code>.</p> <pre><code>&gt; minimatch(\"..\", \".*\")\ntrue\n</code></pre> <p>We can also see that ignore patterns, just like our ignore patterns, are applied to the results, and are unaffected by the underlying behavior of the directory scanner:</p> <pre><code>&gt; glob('..', {}, function (er, files) {\n... console.log(files)\n... })\n&gt; [ '..' ]\n&gt; glob('..', {ignore: ['.*']}, function (er, files) {\n... console.log(files)\n... })\n&gt; []\n</code></pre> </li> </ol> <p>For the majority of people, this is most likely an improvement rather than a hindrance, but if the old behavior is desired, you can use the new option <code>SCANDOTDIR</code> which restores the logic that emulates the feel of <code>scandir</code> returning <code>.</code> and <code>..</code> when iterating a directory.</p> <p>Due to the way <code>pathlib</code> normalizes paths, <code>SCANDOTDIR</code> is not recommended to be used with <code>pathlib</code>.</p>"},{"location":"about/release/#windows-drive-handling","title":"Windows Drive Handling","text":"<p>It is not practical to scan a system for all mounted drives and available network paths. Just like with Python's default globbing, we do not scan all available drives, and so wildcard patterns do not apply to these drives. Unfortunately, our implementation used to only handle very basic UNC cases, and if patterns with extended UNC paths were attempted, failure was likely.</p> <p>7.0 brings improvements related to Windows drives and UNC paths. Glob patterns will now properly respect extended UNC paths such as <code>//?/UNC/LOCALHOST/c$</code> and others. This means you can use these patterns without issues. And just like simple cases (<code>//server/mount</code>), extended cases do not require escaping meta characters, except when using pattern expansion syntax that is available via <code>BRACE</code> and <code>SPLIT</code>.</p>"},{"location":"about/release/#glob-escaping","title":"Glob Escaping","text":"<p>Because it can be problematic trying to mix Windows drives that use characters such as <code>{</code> and <code>}</code> with the <code>BRACE</code> flag, you can now escape these meta characters in drives if required. Prior to 7.0, such escaping was disallowed, but now you can safely escape <code>{</code> and <code>}</code> to ensure optimal brace handling. While you can safely escape other meta characters in drives as well, it is never actually needed.</p> <p>Additionally, <code>glob.escape</code> and <code>glob.raw_escape</code> will automatically escape <code>{</code>, <code>}</code> and <code>|</code> to avoid complications with <code>BRACE</code> and <code>SPLIT</code>.</p> <p>In general, a lot of corner cases with <code>glob.escape</code> and <code>glob.raw_escape</code> were cleaned up.</p> <p><code>glob.escape</code> is meant to handle the escaping of normal paths so that they can be used in patterns.</p> <p><pre><code>&gt;&gt;&gt; glob.escape(r'my\\file-[work].txt', unix=False)\n'my\\\\\\\\file\\\\-\\\\[work\\\\].txt'\n</code></pre> If you are accepting an input from a source that is giving you a representation of a Python string (where <code>\\</code> is represented by two <code>\\</code>), then <code>glob.raw_escape</code> is what you want:</p> <pre><code>&gt;&gt;&gt; glob.raw_escape(r'my\\\\file-[work].txt', unix=False)\n'my\\\\\\\\file\\\\-\\\\[work\\\\].txt'\n</code></pre> <p>By default, <code>glob.raw_escape</code> always translates Python character back references into actual characters, but if this is not needed, a new option called <code>raw_chars</code> (<code>True</code> by default) has been added to disable this behavior:</p> <pre><code>&gt;&gt;&gt; glob.raw_escape(r'my\\\\file-\\x31.txt', unix=False)\n'my\\\\\\\\file\\\\-1.txt'\n&gt;&gt;&gt; glob.raw_escape(r'my\\\\file-\\x31.txt', unix=False, raw_chars=False)\n'my\\\\\\\\file\\\\-\\\\\\\\x31.txt'\n</code></pre>"},{"location":"about/release/#reduction-of-pathlib-duplicate-results","title":"Reduction of <code>pathlib</code> Duplicate Results","text":"<p>In general, glob should return only unique results for a single inclusive pattern (exclusion patterns are not considered). If given multiple patterns, or if given a pattern that is expanded into multiple via <code>BRACE</code> or <code>SPLIT</code>, then duplicate results are actually possible.</p> <p>In 6.0, logic to strip redundant patterns and to filter out duplicate results was added. This deduping is performed by default if more than a single inclusive pattern is provided, even if they are indirectly provided via pattern expansion. The <code>NOUNIQUE</code> flag disables this behavior if desired.</p> <p>In general, this works well, but due to <code>pathlib</code>'s path normalization quirks, there were cases where duplicate results would still be returned for multiple patterns, and even a case where duplicates were returned for a single pattern.</p> <p>Due to <code>pathlib</code> file path normalization, <code>.</code> directories are stripped out, and trailing slashes are stripped off paths. With the changes noted in Globbing single pattern cases no longer return duplicate paths, but results across multiple patterns still could. For instance, it is possible that three different patterns, provided at the same time (or through pattern expansion) could match the following paths: <code>file/./path</code>, <code>file/path/.</code>, and <code>file/path</code>. Each of these results are unique as far as glob is concerned, but due to the <code>pathlib</code> normalization of <code>.</code> and trailing slashes, <code>pathlib</code> glob will return all three of these results as <code>file/path</code>, giving three identical results.</p> <p>In 7.0, logic was added to detect <code>pathlib</code> normalization cases and ensure that redundant results are not returned.</p> <pre><code>&gt;&gt;&gt; glob.glob(['docs/./src', 'docs/src/.', 'docs/src'])\n['docs/./src', 'docs/src/.', 'docs/src']\n&gt;&gt;&gt; list(pathlib.Path('.').glob(['docs/./src', 'docs/src/.', 'docs/src']))\n[PosixPath('docs/src')]\n&gt;&gt;&gt; list(pathlib.Path('.').glob(['docs/./src', 'docs/src/.', 'docs/src'], flags=pathlib.NOUNIQUE))\n[PosixPath('docs/src'), PosixPath('docs/src'), PosixPath('docs/src')]\n</code></pre>"}]}