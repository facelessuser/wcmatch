{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Wildcard Match Overview Wildcard Match provides an enhanced fnmatch , glob , and pathlib library in order to provide file matching and globbing that more closely follows the features found in Bash. In some ways these libraries are similar to Python's builtin libraries as they provide a similar interface to match, filter, and glob the file system. But they also include a number of features found in Bash's globbing such as backslash escaping, brace expansion, extended glob pattern groups, etc. They also add a number of new useful functions as well, such as globmatch which functions like fnmatch , but for paths. Wildcard Match also adds a file search utility called wcmatch that is built on top of fnmatch and globmatch . It was originally written for Rummage , but split out into this project to be used by other projects that may find its approach useful. Bash is used as a guide when making decisions on behavior for fnmatch and glob . Behavior may differ from Bash version to Bash version, but an attempt is made to keep Wildcard Match up with the latest relevant changes. With all of this said, there may be a few corner cases in which we've intentionally chosen to not exactly mirror Bash. If an issue is found where Wildcard Match seems to deviate in an illogical way, we'd love to hear about it in the issue tracker . Features A quick overview of Wildcard Match's Features: Provides an interface comparable to Python's builtin in fnmatch , glob , and pathlib . Allows for a much more configurable experience when matching or globbing with many more features. Adds support for ** in glob. Adds support for escaping characters with \\ . Add support for POSIX style character classes inside sequences: [[:alnum:]] , etc. The C locale is used. Adds support for brace expansion: a{b,{c,d}} \u2192 ab ac ad . Adds support for expanding ~ or ~username to the appropriate user path. Adds support for extended match patterns: @(...) , +(...) , *(...) , ?(...) , and !(...) . Adds ability to match path names via the path centric globmatch . Provides a pathlib variant that uses Wildcard Match's glob library instead of Python's default. Provides an alternative file crawler called wcmatch . And more\u2026 Installation Installation is easy with pip: $ pip install wcmatch Libraries fnmatch : A file name matching library. glob : A file system searching and file path matching library. pathlib : A implementation of Python's pathlib that uses our own glob implementation. wcmatch : An alternative file search library built on fnmatch and globmatch .","title":"Introduction"},{"location":"#wildcard-match","text":"","title":"Wildcard Match"},{"location":"#overview","text":"Wildcard Match provides an enhanced fnmatch , glob , and pathlib library in order to provide file matching and globbing that more closely follows the features found in Bash. In some ways these libraries are similar to Python's builtin libraries as they provide a similar interface to match, filter, and glob the file system. But they also include a number of features found in Bash's globbing such as backslash escaping, brace expansion, extended glob pattern groups, etc. They also add a number of new useful functions as well, such as globmatch which functions like fnmatch , but for paths. Wildcard Match also adds a file search utility called wcmatch that is built on top of fnmatch and globmatch . It was originally written for Rummage , but split out into this project to be used by other projects that may find its approach useful. Bash is used as a guide when making decisions on behavior for fnmatch and glob . Behavior may differ from Bash version to Bash version, but an attempt is made to keep Wildcard Match up with the latest relevant changes. With all of this said, there may be a few corner cases in which we've intentionally chosen to not exactly mirror Bash. If an issue is found where Wildcard Match seems to deviate in an illogical way, we'd love to hear about it in the issue tracker .","title":"Overview"},{"location":"#features","text":"A quick overview of Wildcard Match's Features: Provides an interface comparable to Python's builtin in fnmatch , glob , and pathlib . Allows for a much more configurable experience when matching or globbing with many more features. Adds support for ** in glob. Adds support for escaping characters with \\ . Add support for POSIX style character classes inside sequences: [[:alnum:]] , etc. The C locale is used. Adds support for brace expansion: a{b,{c,d}} \u2192 ab ac ad . Adds support for expanding ~ or ~username to the appropriate user path. Adds support for extended match patterns: @(...) , +(...) , *(...) , ?(...) , and !(...) . Adds ability to match path names via the path centric globmatch . Provides a pathlib variant that uses Wildcard Match's glob library instead of Python's default. Provides an alternative file crawler called wcmatch . And more\u2026","title":"Features"},{"location":"#installation","text":"Installation is easy with pip: $ pip install wcmatch","title":"Installation"},{"location":"#libraries","text":"fnmatch : A file name matching library. glob : A file system searching and file path matching library. pathlib : A implementation of Python's pathlib that uses our own glob implementation. wcmatch : An alternative file search library built on fnmatch and globmatch .","title":"Libraries"},{"location":"fnmatch/","text":"wcmatch.fnmatch from wcmatch import fnmatch Syntax The fnmatch library is similar to the builtin fnmatch , but with some enhancements and some differences. It is mainly used for matching filenames with glob patterns. For path names, Wildcard Match's globmatch is a more appropriate choice. Not all of the features listed below are enabled by default. See flags for more information. Backslashes When using backslashes, it is helpful to use raw strings. In a raw string, a single backslash is used to escape a character r '\\?' . If you want to represent a literal backslash, you must use two: r 'some \\\\ path' . Pattern Meaning * Matches everything. ? Matches any single character. [seq] Matches any character in seq. [!seq] Matches any character not in seq. Will also accept character exclusions in the form of [^seq] . [[:alnum:]] POSIX style character classes inside sequences. See POSIX Character Classes for more info. \\ Escapes characters. If applied to a meta character or non-meta characters, the character will be treated as a literal character. If applied to another escape, the backslash will be a literal backslash. ! When used at the start of a pattern, the pattern will be an exclusion pattern. Requires the NEGATE flag. If also using the MINUSNEGATE flag, - will be used instead of ! . ?(pattern_list) The pattern matches if zero or one occurrences of any of the patterns in the pattern_list match the input string. Requires the EXTMATCH flag. *(pattern_list) The pattern matches if zero or more occurrences of any of the patterns in the pattern_list match the input string. Requires the EXTMATCH flag. +(pattern_list) The pattern matches if one or more occurrences of any of the patterns in the pattern_list match the input string. Requires the EXTMATCH flag. @(pattern_list) The pattern matches if exactly one occurrence of any of the patterns in the pattern_list match the input string. Requires the EXTMATCH flag. !(pattern_list) The pattern matches if the input string cannot be matched with any of the patterns in the pattern_list . Requires the EXTMATCH flag. {} Bash style brace expansions. This is applied to patterns before anything else. Requires the BRACE flag. Slashes are generally treated as normal characters, but on windows they are normalized. On Windows, / will match both / and \\\\ . There is no need to explicitly use \\\\ in patterns on Windows, but if you do, they must be escaped to specify a literal \\\\ . If a backslash is escaped, it will match all valid windows separators, just like / does. By default, . is not matched by * , ? , and [] . See the DOTMATCH flag to match . at the start of a filename without a literal . . POSIX Character Classes A number of POSIX style character classes are available in the form [:alnum:] . They must be used inside sequences: [[:digit:]] . The C locale is used, and the values for each character class are found in the table below. Property Pattern alnum [a-zA-Z0-9] alpha [a-zA-Z] ascii [\\x00-\\x7F] blank [ \\t] cntrl [\\x00-\\x1F\\x7F] digit [0-9] graph [\\x21-\\x7E] lower [a-z] print [\\x20-\\x7E] punct [!\\\"\\#$%&'()*+,\\-./:;<=>?@\\[\\\\\\]^_`{}~] space [ \\t\\r\\n\\v\\f] upper [A-Z] word [a-zA-Z0-9_] xdigit [A-Fa-f0-9] Multi-Pattern Limits Many of the API functions allow passing in multiple patterns or using either BRACE or SPLIT to expand a pattern in to more patterns. The number of allowed patterns is limited 1000 , but you can raise or lower this limit via the keyword option limit . If you set limit to 0 , there will be no limit. New 6.0 The imposed pattern limit and corresponding limit option was introduced in 6.0. API fnmatch.fnmatch def fnmatch ( filename , patterns , * , flags = 0 , limit = 1000 , exclude = None ) fnmatch takes a file name, a pattern (or list of patterns), and flags. It also allows configuring the max pattern limit . Exclusion patterns can be specified via the exclude parameter which takes a pattern or a list of patterns. It will return a boolean indicating whether the file name was matched by the pattern(s). >>> from wcmatch import fnmatch >>> fnmatch . fnmatch ( 'test.txt' , '@(*.txt|*.py)' , flags = fnmatch . EXTMATCH ) True When applying multiple patterns, a file matches if it matches any of the patterns: >>> from wcmatch import fnmatch >>> fnmatch . fnmatch ( 'test.txt' , [ '*.txt' , '*.py' ], flags = fnmatch . EXTMATCH ) True Exclusions can be used by taking advantage of the exclude parameter. It takes a single exclude pattern or a list of patterns. Files that match the exclude pattern will not be matched. >>> from wcmatch import fnmatch >>> fnmatch . fnmatch ( 'test.py' , '*' , exclude = '*.py' ) False >>> fnmatch . fnmatch ( 'test.txt' , '*' , exclude = '*.py' ) True Inline exclusion patterns are allowed as well. When exclusion patterns are used in conjunction with inclusion patterns, a file will be considered matched if one of the inclusion patterns match and none of the exclusion patterns match. If an exclusion pattern is given without any inclusion patterns, the pattern will match nothing. Exclusion patterns are meant to filter other patterns, not match anything by themselves. >>> from wcmatch import fnmatch >>> fnmatch . fnmatch ( 'test.py' , '*|!*.py' , flags = fnmatch . NEGATE | fnmatch . SPLIT ) False >>> fnmatch . fnmatch ( 'test.txt' , '*|!*.py' , flags = fnmatch . NEGATE | fnmatch . SPLIT ) True >>> fnmatch . fnmatch ( 'test.txt' , [ '*.txt' , '!avoid.txt' ], flags = fnmatch . NEGATE ) True >>> fnmatch . fnmatch ( 'avoid.txt' , [ '*.txt' , '!avoid.txt' ], flags = fnmatch . NEGATE ) False As mentioned, exclusion patterns need to be applied to a inclusion pattern to work, but if it is desired, you can force exclusion patterns to assume all files should be filtered with the exclusion pattern(s) with the NEGATEALL flag. Essentially, it means if you use a pattern such as !*.md , it will assume two pattern were given: * and !*.md . >>> from wcmatch import fnmatch >>> fnmatch . fnmatch ( 'test.py' , '!*.py' , flags = fnmatch . NEGATE | fnmatch . NEGATEALL ) False >>> fnmatch . fnmatch ( 'test.txt' , '!*.py' , flags = fnmatch . NEGATE | fnmatch . NEGATEALL ) True New 6.0 limit was added in 6.0. New 8.4 exclude parameter was added. fnmatch.filter def filter ( filenames , patterns , * , flags = 0 , limit = 1000 , exclude = None ): filter takes a list of filenames, a pattern (or list of patterns), and flags. It also allows configuring the max pattern limit . Exclusion patterns can be specified via the exclude parameter which takes a pattern or a list of patterns.It returns a list of all files that matched the pattern(s). The same logic used for fnmatch is used for filter , albeit more efficient for processing multiple files. >>> from wcmatch import fnmatch >>> fnmatch . filter ([ 'a.txt' , 'b.txt' , 'c.py' ], '*.txt' ) ['a.txt', 'b.txt'] New 6.0 limit was added in 6.0. New 8.4 exclude parameter was added. fnmatch.translate def translate ( patterns , * , flags = 0 , limit = 1000 , exclude = None ): translate takes a file pattern (or list of patterns) and flags. It also allows configuring the max pattern limit . Exclusion patterns can be specified via the exclude parameter which takes a pattern or a list of patterns. It returns two lists: one for inclusion patterns and one for exclusion patterns. The lists contain the regular expressions used for matching the given patterns. It should be noted that a file is considered matched if it matches at least one inclusion pattern and matches none of the exclusion patterns. >>> from wcmatch import fnmatch >>> fnmatch . translate ( '*.{a,{b,c}}' , flags = fnmatch . BRACE ) (['^(?s:(?=.)(?![.]).*?\\\\.a)$', '^(?s:(?=.)(?![.]).*?\\\\.b)$', '^(?s:(?=.)(?![.]).*?\\\\.c)$'], []) >>> fnmatch . translate ( '**|!*.{a,{b,c}}' , flags = fnmatch . BRACE | fnmatch . NEGATE | fnmatch . SPLIT ) (['^(?s:(?=.)(?![.]).*?)$'], ['^(?s:(?=.).*?\\\\.a)$', '^(?s:(?=.).*?\\\\.b)$', '^(?s:(?=.).*?\\\\.c)$']) When using EXTMATCH patterns, patterns will be returned with capturing groups around the groups: While in regex patterns like r '(a)+' would capture only the last character, even though multiple where matched, we wrap the entire group to be captured: '+(a)' \u2192 r '((a)+)' . >>> from wcmatch import fnmatch >>> import re >>> gpat = fnmatch . translate ( \"@(file)+([[:digit:]])@(.*)\" , flags = fnmatch . EXTMATCH ) >>> pat = re . compile ( gpat [ 0 ][ 0 ]) >>> pat . match ( 'file33.test.txt' ) . groups () ('file', '33', '.test.txt') New 6.0 limit was added in 6.0. New 7.1 Translate patterns now provide capturing groups for EXTMATCH groups. New 8.4 exclude parameter was added. fnmatch.escape def escape ( pattern ): The escape function will conservatively escape - , ! , * , ? , ( , ) , [ , ] , | , { , } . and \\ with backslashes, regardless of what feature is or is not enabled. It is meant to escape filenames. >>> from wcmatch import fnmatch >>> fnmatch . escape ( '**file** {} .txt' ) '\\\\*\\\\*file\\\\*\\\\*\\\\{\\\\}.txt' >>> fnmatch . fnmatch ( '**file** {} .txt' , fnmatch . escape ( '**file** {} .txt' )) True New 8.1 An escape variant for fnmatch was made available in 8.1. fnmatch.is_magic def is_magic ( pattern , * , flags = 0 ): \"\"\"Check if the pattern is likely to be magic.\"\"\" This checks a given filename or pattern to see if it is \"magic\" or not. The check is based on the enabled features via flags . Filenames or patterns are expected to be/target full names. This variant of is_magic is meant to be run on filenames or patterns for file names only. If you need to check patterns with full paths, particularly Windows paths that include drive names or UNC sharepoints (which require special logic), it is recommended to use the glob.escape function. >>> fnmatch . is_magic ( 'test' ) False >>> fnmatch . is_magic ( '[test]ing?' ) True The table below illustrates which symbols are searched for based on the given feature. Each feature adds to the \"default\". In the case of NEGATE , if MINUSNEGATE is also enabled, MINUSNEGATE 's symbols will be searched instead of NEGATE 's symbols. Features Symbols Default ?*[]\\ EXTMATCH () BRACE {} NEGATE ! MINUSNEGATE - SPLIT | New 8.1 Added is_magic in 8.1. Flags fnmatch.CASE, fnmatch.C CASE forces case sensitivity. CASE has higher priority than IGNORECASE . fnmatch.IGNORECASE, fnmatch.I IGNORECASE forces case insensitivity. CASE has higher priority than IGNORECASE . fnmatch.RAWCHARS, fnmatch.R RAWCHARS causes string character syntax to be parsed in raw strings: r '\\u0040' \u2192 r '@' . This will handle standard string escapes and Unicode including r '\\N{CHAR NAME}' . fnmatch.NEGATE, fnmatch.N NEGATE causes patterns that start with ! to be treated as exclusion patterns. A pattern of !*.py would match any file but Python files. Exclusion patterns cannot be used by themselves though, and must be paired with a normal, inclusion pattern, either by utilizing the SPLIT flag, or providing multiple patterns in a list. Assuming the SPLIT flag, this means using it in a pattern such as inclusion|!exclusion . If it is desired, you can force exclusion patterns, when no inclusion pattern is provided, to assume all files match unless the file matches the excluded pattern. This is done with the NEGATEALL flag. NEGATE enables DOTMATCH in all exclude patterns, this cannot be disabled. This will not affect the inclusion patterns. If NEGATE is set and exclusion patterns are passed via a matching function's exclude parameter, NEGATE will be ignored and the exclude patterns will be used instead. Either exclude or NEGATE should be used, not both. fnmatch.NEGATEALL, fnmatch.A NEGATEALL can force exclusion patterns, when no inclusion pattern is provided, to assume all files match unless the file matches the excluded pattern. Essentially, it means if you use a pattern such as !*.md , it will assume two patterns were given: * and !*.md , where !*.md is applied to the results of * . Dot files will not be returned unless DOTMATCH . fnmatch.MINUSNEGATE, fnmatch.M When MINUSNEGATE is used with NEGATE , exclusion patterns are recognized by a pattern starting with - instead of ! . This plays nice with the EXTMATCH option. fnmatch.DOTMATCH, fnmatch.D By default, fnmatch and related functions will not match file or directory names that start with dot . unless matched with a literal dot. DOTMATCH allows the meta characters (such as * ) to match dots like any other character. Dots will not be matched in [] , * , or ? . fnmatch.EXTMATCH, fnmatch.E EXTMATCH enables extended pattern matching. This includes special pattern lists such as +(...) , *(...) , ?(...) , etc. See the syntax overview for more information. EXTMATCH and NEGATE When using EXTMATCH and NEGATE together, if a pattern starts with !( , the pattern will not be treated as a NEGATE pattern (even if !( doesn't yield a valid EXTMATCH pattern). To negate a pattern that starts with a literal ( , you must escape the bracket: !\\( . fnmatch.BRACE, fnmatch.B BRACE enables Bash style brace expansion: a{b,{c,d}} \u2192 ab ac ad . Brace expansion is applied before anything else. When applied, a pattern will be expanded into multiple patterns. Each pattern will then be parsed separately. Redundant, identical patterns are discarded 1 by default. For simple patterns, it may make more sense to use EXTMATCH which will only generate a single pattern which will perform much better: @(ab|ac|ad) . Massive Expansion Risk It is important to note that each pattern is matched separately, so patterns such as {1..100} would generate one hundred patterns. Sometimes patterns like this are needed, so construct patterns thoughtfully and carefully. BRACE and SPLIT both expand patterns into multiple patterns. Using these two syntaxes simultaneously can exponential increase in duplicate patterns: >>> expand ( 'test@(this{|that,|other})|*.py' , BRACE | SPLIT | EXTMATCH ) ['test@(this|that)', 'test@(this|other)', '*.py', '*.py'] This effect is reduced as redundant, identical patterns are optimized away 1 . But it is useful to know if trying to construct efficient patterns. fnmatch.SPLIT, fnmatch.S SPLIT is used to take a string of multiple patterns that are delimited by | and split them into separate patterns. This is provided to help with some interfaces that might need a way to define multiple patterns in one input. It pairs really well with EXTMATCH and takes into account sequences ( [] ) and extended patterns ( *(...) ) and will not parse | within them. You can also escape the delimiters if needed: \\| . While SPLIT is not as powerful as BRACE , it's syntax is very easy to use, and when paired with EXTMATCH , it feels natural and comes a bit closer. It also much harder to create massive expansions of patterns with it, except when paired with BRACE . See BRACE and it's warnings related to pairing it with SPLIT . >>> from wcmatch import fnmatch >>> fnmatch . fnmatch ( 'test.txt' , '*.txt|*.py' , flags = fnmatch . SPLIT ) True >>> fnmatch . fnmatch ( 'test.py' , '*.txt|*.py' , flags = fnmatch . SPLIT ) True fnmatch.FORCEWIN, fnmatch.W FORCEWIN will force Windows name and case logic to be used on Linux/Unix systems. It will also cause slashes to be normalized. This is great if you need to match Windows specific names on a Linux/Unix system. If FORCEWIN is used along side FORCEUNIX , both will be ignored. fnmatch.FORCEUNIX, fnmatch.U FORCEUNIX will force Linux/Unix name and case logic to be used on Windows systems. This is great if you need to match Linux/Unix specific names on a Windows system. When using FORCEUNIX , the names are assumed to be case sensitive, but you can use IGNORECASE to use case insensitivity. If FORCEUNIX is used along side FORCEWIN , both will be ignored. Identical patterns are only reduced by comparing case sensitively as POSIX character classes are case sensitive: [[:alnum:]] \u2260 [[:ALNUM:]] . \u21a9 \u21a9","title":"Usage"},{"location":"fnmatch/#wcmatchfnmatch","text":"from wcmatch import fnmatch","title":"wcmatch.fnmatch"},{"location":"fnmatch/#syntax","text":"The fnmatch library is similar to the builtin fnmatch , but with some enhancements and some differences. It is mainly used for matching filenames with glob patterns. For path names, Wildcard Match's globmatch is a more appropriate choice. Not all of the features listed below are enabled by default. See flags for more information. Backslashes When using backslashes, it is helpful to use raw strings. In a raw string, a single backslash is used to escape a character r '\\?' . If you want to represent a literal backslash, you must use two: r 'some \\\\ path' . Pattern Meaning * Matches everything. ? Matches any single character. [seq] Matches any character in seq. [!seq] Matches any character not in seq. Will also accept character exclusions in the form of [^seq] . [[:alnum:]] POSIX style character classes inside sequences. See POSIX Character Classes for more info. \\ Escapes characters. If applied to a meta character or non-meta characters, the character will be treated as a literal character. If applied to another escape, the backslash will be a literal backslash. ! When used at the start of a pattern, the pattern will be an exclusion pattern. Requires the NEGATE flag. If also using the MINUSNEGATE flag, - will be used instead of ! . ?(pattern_list) The pattern matches if zero or one occurrences of any of the patterns in the pattern_list match the input string. Requires the EXTMATCH flag. *(pattern_list) The pattern matches if zero or more occurrences of any of the patterns in the pattern_list match the input string. Requires the EXTMATCH flag. +(pattern_list) The pattern matches if one or more occurrences of any of the patterns in the pattern_list match the input string. Requires the EXTMATCH flag. @(pattern_list) The pattern matches if exactly one occurrence of any of the patterns in the pattern_list match the input string. Requires the EXTMATCH flag. !(pattern_list) The pattern matches if the input string cannot be matched with any of the patterns in the pattern_list . Requires the EXTMATCH flag. {} Bash style brace expansions. This is applied to patterns before anything else. Requires the BRACE flag. Slashes are generally treated as normal characters, but on windows they are normalized. On Windows, / will match both / and \\\\ . There is no need to explicitly use \\\\ in patterns on Windows, but if you do, they must be escaped to specify a literal \\\\ . If a backslash is escaped, it will match all valid windows separators, just like / does. By default, . is not matched by * , ? , and [] . See the DOTMATCH flag to match . at the start of a filename without a literal . .","title":"Syntax"},{"location":"fnmatch/#posix-character-classes","text":"A number of POSIX style character classes are available in the form [:alnum:] . They must be used inside sequences: [[:digit:]] . The C locale is used, and the values for each character class are found in the table below. Property Pattern alnum [a-zA-Z0-9] alpha [a-zA-Z] ascii [\\x00-\\x7F] blank [ \\t] cntrl [\\x00-\\x1F\\x7F] digit [0-9] graph [\\x21-\\x7E] lower [a-z] print [\\x20-\\x7E] punct [!\\\"\\#$%&'()*+,\\-./:;<=>?@\\[\\\\\\]^_`{}~] space [ \\t\\r\\n\\v\\f] upper [A-Z] word [a-zA-Z0-9_] xdigit [A-Fa-f0-9]","title":"POSIX Character Classes"},{"location":"fnmatch/#multi-pattern-limits","text":"Many of the API functions allow passing in multiple patterns or using either BRACE or SPLIT to expand a pattern in to more patterns. The number of allowed patterns is limited 1000 , but you can raise or lower this limit via the keyword option limit . If you set limit to 0 , there will be no limit. New 6.0 The imposed pattern limit and corresponding limit option was introduced in 6.0.","title":"Multi-Pattern Limits"},{"location":"fnmatch/#api","text":"","title":"API"},{"location":"fnmatch/#fnmatch","text":"def fnmatch ( filename , patterns , * , flags = 0 , limit = 1000 , exclude = None ) fnmatch takes a file name, a pattern (or list of patterns), and flags. It also allows configuring the max pattern limit . Exclusion patterns can be specified via the exclude parameter which takes a pattern or a list of patterns. It will return a boolean indicating whether the file name was matched by the pattern(s). >>> from wcmatch import fnmatch >>> fnmatch . fnmatch ( 'test.txt' , '@(*.txt|*.py)' , flags = fnmatch . EXTMATCH ) True When applying multiple patterns, a file matches if it matches any of the patterns: >>> from wcmatch import fnmatch >>> fnmatch . fnmatch ( 'test.txt' , [ '*.txt' , '*.py' ], flags = fnmatch . EXTMATCH ) True Exclusions can be used by taking advantage of the exclude parameter. It takes a single exclude pattern or a list of patterns. Files that match the exclude pattern will not be matched. >>> from wcmatch import fnmatch >>> fnmatch . fnmatch ( 'test.py' , '*' , exclude = '*.py' ) False >>> fnmatch . fnmatch ( 'test.txt' , '*' , exclude = '*.py' ) True Inline exclusion patterns are allowed as well. When exclusion patterns are used in conjunction with inclusion patterns, a file will be considered matched if one of the inclusion patterns match and none of the exclusion patterns match. If an exclusion pattern is given without any inclusion patterns, the pattern will match nothing. Exclusion patterns are meant to filter other patterns, not match anything by themselves. >>> from wcmatch import fnmatch >>> fnmatch . fnmatch ( 'test.py' , '*|!*.py' , flags = fnmatch . NEGATE | fnmatch . SPLIT ) False >>> fnmatch . fnmatch ( 'test.txt' , '*|!*.py' , flags = fnmatch . NEGATE | fnmatch . SPLIT ) True >>> fnmatch . fnmatch ( 'test.txt' , [ '*.txt' , '!avoid.txt' ], flags = fnmatch . NEGATE ) True >>> fnmatch . fnmatch ( 'avoid.txt' , [ '*.txt' , '!avoid.txt' ], flags = fnmatch . NEGATE ) False As mentioned, exclusion patterns need to be applied to a inclusion pattern to work, but if it is desired, you can force exclusion patterns to assume all files should be filtered with the exclusion pattern(s) with the NEGATEALL flag. Essentially, it means if you use a pattern such as !*.md , it will assume two pattern were given: * and !*.md . >>> from wcmatch import fnmatch >>> fnmatch . fnmatch ( 'test.py' , '!*.py' , flags = fnmatch . NEGATE | fnmatch . NEGATEALL ) False >>> fnmatch . fnmatch ( 'test.txt' , '!*.py' , flags = fnmatch . NEGATE | fnmatch . NEGATEALL ) True New 6.0 limit was added in 6.0. New 8.4 exclude parameter was added.","title":"fnmatch.fnmatch"},{"location":"fnmatch/#filter","text":"def filter ( filenames , patterns , * , flags = 0 , limit = 1000 , exclude = None ): filter takes a list of filenames, a pattern (or list of patterns), and flags. It also allows configuring the max pattern limit . Exclusion patterns can be specified via the exclude parameter which takes a pattern or a list of patterns.It returns a list of all files that matched the pattern(s). The same logic used for fnmatch is used for filter , albeit more efficient for processing multiple files. >>> from wcmatch import fnmatch >>> fnmatch . filter ([ 'a.txt' , 'b.txt' , 'c.py' ], '*.txt' ) ['a.txt', 'b.txt'] New 6.0 limit was added in 6.0. New 8.4 exclude parameter was added.","title":"fnmatch.filter"},{"location":"fnmatch/#translate","text":"def translate ( patterns , * , flags = 0 , limit = 1000 , exclude = None ): translate takes a file pattern (or list of patterns) and flags. It also allows configuring the max pattern limit . Exclusion patterns can be specified via the exclude parameter which takes a pattern or a list of patterns. It returns two lists: one for inclusion patterns and one for exclusion patterns. The lists contain the regular expressions used for matching the given patterns. It should be noted that a file is considered matched if it matches at least one inclusion pattern and matches none of the exclusion patterns. >>> from wcmatch import fnmatch >>> fnmatch . translate ( '*.{a,{b,c}}' , flags = fnmatch . BRACE ) (['^(?s:(?=.)(?![.]).*?\\\\.a)$', '^(?s:(?=.)(?![.]).*?\\\\.b)$', '^(?s:(?=.)(?![.]).*?\\\\.c)$'], []) >>> fnmatch . translate ( '**|!*.{a,{b,c}}' , flags = fnmatch . BRACE | fnmatch . NEGATE | fnmatch . SPLIT ) (['^(?s:(?=.)(?![.]).*?)$'], ['^(?s:(?=.).*?\\\\.a)$', '^(?s:(?=.).*?\\\\.b)$', '^(?s:(?=.).*?\\\\.c)$']) When using EXTMATCH patterns, patterns will be returned with capturing groups around the groups: While in regex patterns like r '(a)+' would capture only the last character, even though multiple where matched, we wrap the entire group to be captured: '+(a)' \u2192 r '((a)+)' . >>> from wcmatch import fnmatch >>> import re >>> gpat = fnmatch . translate ( \"@(file)+([[:digit:]])@(.*)\" , flags = fnmatch . EXTMATCH ) >>> pat = re . compile ( gpat [ 0 ][ 0 ]) >>> pat . match ( 'file33.test.txt' ) . groups () ('file', '33', '.test.txt') New 6.0 limit was added in 6.0. New 7.1 Translate patterns now provide capturing groups for EXTMATCH groups. New 8.4 exclude parameter was added.","title":"fnmatch.translate"},{"location":"fnmatch/#escape","text":"def escape ( pattern ): The escape function will conservatively escape - , ! , * , ? , ( , ) , [ , ] , | , { , } . and \\ with backslashes, regardless of what feature is or is not enabled. It is meant to escape filenames. >>> from wcmatch import fnmatch >>> fnmatch . escape ( '**file** {} .txt' ) '\\\\*\\\\*file\\\\*\\\\*\\\\{\\\\}.txt' >>> fnmatch . fnmatch ( '**file** {} .txt' , fnmatch . escape ( '**file** {} .txt' )) True New 8.1 An escape variant for fnmatch was made available in 8.1.","title":"fnmatch.escape"},{"location":"fnmatch/#is_magic","text":"def is_magic ( pattern , * , flags = 0 ): \"\"\"Check if the pattern is likely to be magic.\"\"\" This checks a given filename or pattern to see if it is \"magic\" or not. The check is based on the enabled features via flags . Filenames or patterns are expected to be/target full names. This variant of is_magic is meant to be run on filenames or patterns for file names only. If you need to check patterns with full paths, particularly Windows paths that include drive names or UNC sharepoints (which require special logic), it is recommended to use the glob.escape function. >>> fnmatch . is_magic ( 'test' ) False >>> fnmatch . is_magic ( '[test]ing?' ) True The table below illustrates which symbols are searched for based on the given feature. Each feature adds to the \"default\". In the case of NEGATE , if MINUSNEGATE is also enabled, MINUSNEGATE 's symbols will be searched instead of NEGATE 's symbols. Features Symbols Default ?*[]\\ EXTMATCH () BRACE {} NEGATE ! MINUSNEGATE - SPLIT | New 8.1 Added is_magic in 8.1.","title":"fnmatch.is_magic"},{"location":"fnmatch/#flags","text":"","title":"Flags"},{"location":"fnmatch/#case","text":"CASE forces case sensitivity. CASE has higher priority than IGNORECASE .","title":"fnmatch.CASE, fnmatch.C"},{"location":"fnmatch/#ignorecase","text":"IGNORECASE forces case insensitivity. CASE has higher priority than IGNORECASE .","title":"fnmatch.IGNORECASE, fnmatch.I"},{"location":"fnmatch/#rawchars","text":"RAWCHARS causes string character syntax to be parsed in raw strings: r '\\u0040' \u2192 r '@' . This will handle standard string escapes and Unicode including r '\\N{CHAR NAME}' .","title":"fnmatch.RAWCHARS, fnmatch.R"},{"location":"fnmatch/#negate","text":"NEGATE causes patterns that start with ! to be treated as exclusion patterns. A pattern of !*.py would match any file but Python files. Exclusion patterns cannot be used by themselves though, and must be paired with a normal, inclusion pattern, either by utilizing the SPLIT flag, or providing multiple patterns in a list. Assuming the SPLIT flag, this means using it in a pattern such as inclusion|!exclusion . If it is desired, you can force exclusion patterns, when no inclusion pattern is provided, to assume all files match unless the file matches the excluded pattern. This is done with the NEGATEALL flag. NEGATE enables DOTMATCH in all exclude patterns, this cannot be disabled. This will not affect the inclusion patterns. If NEGATE is set and exclusion patterns are passed via a matching function's exclude parameter, NEGATE will be ignored and the exclude patterns will be used instead. Either exclude or NEGATE should be used, not both.","title":"fnmatch.NEGATE, fnmatch.N"},{"location":"fnmatch/#negateall","text":"NEGATEALL can force exclusion patterns, when no inclusion pattern is provided, to assume all files match unless the file matches the excluded pattern. Essentially, it means if you use a pattern such as !*.md , it will assume two patterns were given: * and !*.md , where !*.md is applied to the results of * . Dot files will not be returned unless DOTMATCH .","title":"fnmatch.NEGATEALL, fnmatch.A"},{"location":"fnmatch/#minusnegate","text":"When MINUSNEGATE is used with NEGATE , exclusion patterns are recognized by a pattern starting with - instead of ! . This plays nice with the EXTMATCH option.","title":"fnmatch.MINUSNEGATE, fnmatch.M"},{"location":"fnmatch/#dotmatch","text":"By default, fnmatch and related functions will not match file or directory names that start with dot . unless matched with a literal dot. DOTMATCH allows the meta characters (such as * ) to match dots like any other character. Dots will not be matched in [] , * , or ? .","title":"fnmatch.DOTMATCH, fnmatch.D"},{"location":"fnmatch/#extmatch","text":"EXTMATCH enables extended pattern matching. This includes special pattern lists such as +(...) , *(...) , ?(...) , etc. See the syntax overview for more information. EXTMATCH and NEGATE When using EXTMATCH and NEGATE together, if a pattern starts with !( , the pattern will not be treated as a NEGATE pattern (even if !( doesn't yield a valid EXTMATCH pattern). To negate a pattern that starts with a literal ( , you must escape the bracket: !\\( .","title":"fnmatch.EXTMATCH, fnmatch.E"},{"location":"fnmatch/#brace","text":"BRACE enables Bash style brace expansion: a{b,{c,d}} \u2192 ab ac ad . Brace expansion is applied before anything else. When applied, a pattern will be expanded into multiple patterns. Each pattern will then be parsed separately. Redundant, identical patterns are discarded 1 by default. For simple patterns, it may make more sense to use EXTMATCH which will only generate a single pattern which will perform much better: @(ab|ac|ad) . Massive Expansion Risk It is important to note that each pattern is matched separately, so patterns such as {1..100} would generate one hundred patterns. Sometimes patterns like this are needed, so construct patterns thoughtfully and carefully. BRACE and SPLIT both expand patterns into multiple patterns. Using these two syntaxes simultaneously can exponential increase in duplicate patterns: >>> expand ( 'test@(this{|that,|other})|*.py' , BRACE | SPLIT | EXTMATCH ) ['test@(this|that)', 'test@(this|other)', '*.py', '*.py'] This effect is reduced as redundant, identical patterns are optimized away 1 . But it is useful to know if trying to construct efficient patterns.","title":"fnmatch.BRACE, fnmatch.B"},{"location":"fnmatch/#split","text":"SPLIT is used to take a string of multiple patterns that are delimited by | and split them into separate patterns. This is provided to help with some interfaces that might need a way to define multiple patterns in one input. It pairs really well with EXTMATCH and takes into account sequences ( [] ) and extended patterns ( *(...) ) and will not parse | within them. You can also escape the delimiters if needed: \\| . While SPLIT is not as powerful as BRACE , it's syntax is very easy to use, and when paired with EXTMATCH , it feels natural and comes a bit closer. It also much harder to create massive expansions of patterns with it, except when paired with BRACE . See BRACE and it's warnings related to pairing it with SPLIT . >>> from wcmatch import fnmatch >>> fnmatch . fnmatch ( 'test.txt' , '*.txt|*.py' , flags = fnmatch . SPLIT ) True >>> fnmatch . fnmatch ( 'test.py' , '*.txt|*.py' , flags = fnmatch . SPLIT ) True","title":"fnmatch.SPLIT, fnmatch.S"},{"location":"fnmatch/#forcewin","text":"FORCEWIN will force Windows name and case logic to be used on Linux/Unix systems. It will also cause slashes to be normalized. This is great if you need to match Windows specific names on a Linux/Unix system. If FORCEWIN is used along side FORCEUNIX , both will be ignored.","title":"fnmatch.FORCEWIN, fnmatch.W"},{"location":"fnmatch/#forceunix","text":"FORCEUNIX will force Linux/Unix name and case logic to be used on Windows systems. This is great if you need to match Linux/Unix specific names on a Windows system. When using FORCEUNIX , the names are assumed to be case sensitive, but you can use IGNORECASE to use case insensitivity. If FORCEUNIX is used along side FORCEWIN , both will be ignored. Identical patterns are only reduced by comparing case sensitively as POSIX character classes are case sensitive: [[:alnum:]] \u2260 [[:ALNUM:]] . \u21a9 \u21a9","title":"fnmatch.FORCEUNIX, fnmatch.U"},{"location":"glob/","text":"wcmatch.glob from wcmatch import glob Syntax The glob library provides methods for traversing the file system and returning files that matched a defined set of glob patterns. The library also provides a function called globmatch for matching file paths which is similar to fnmatch , but for paths. In short, globmatch matches what glob globs . Tip When using backslashes, it is helpful to use raw strings. In a raw string, a single backslash is used to escape a character r '\\?' . If you want to represent a literal backslash, you must use two: r 'some \\\\ path' . Pattern Meaning * Matches everything except slashes. On Windows it will avoid matching backslashes as well as slashes. ** Matches zero or more directories, but will never match the directories . and .. . Requires the GLOBSTAR flag. ? Matches any single character. [seq] Matches any character in seq. [!seq] Matches any character not in seq. Will also accept character exclusions in the form of [^seq] . [[:alnum:]] POSIX style character classes inside sequences. See POSIX Character Classes for more info. \\ Escapes characters. If applied to a meta character or non-meta characters, the character will be treated as a literal character. If applied to another escape, the backslash will be a literal backslash. ! When used at the start of a pattern, the pattern will be an exclusion pattern. Requires the NEGATE flag. If also using the MINUSNEGATE flag, - will be used instead of ! . ?(pattern_list) The pattern matches if zero or one occurrences of any of the patterns in the pattern_list match the input string. Requires the EXTGLOB flag. *(pattern_list) The pattern matches if zero or more occurrences of any of the patterns in the pattern_list match the input string. Requires the EXTGLOB flag. +(pattern_list) The pattern matches if one or more occurrences of any of the patterns in the pattern_list match the input string. Requires the EXTGLOB flag. @(pattern_list) The pattern matches if exactly one occurrence of any of the patterns in the pattern_list match the input string. Requires the EXTGLOB flag. !(pattern_list) The pattern matches if the input string cannot be matched with any of the patterns in the pattern_list . Requires the EXTGLOB flag. {} Bash style brace expansions. This is applied to patterns before anything else. Requires the BRACE flag. ~/pattern User path expansion via ~/pattern or ~user/pattern . Requires the GLOBTILDE flag. Slashes are generally treated special in glob related methods. Slashes are not matched in [] , * , ? , or extended patterns like *(...) . Slashes can be matched by ** if GLOBSTAR is set. Slashes on Windows are normalized. / will match both / and \\\\ . There is no need to explicitly use \\\\ in patterns on Windows, but if you do, they must be escaped to specify a literal \\\\ . If a backslash is escaped, it will match all valid windows separators, just like / does. On Windows, drives are treated special and must come at the beginning of the pattern and cannot be matched with * , [] , ? , or even extended match patterns like +(...) . Windows drives are recognized as either C:/ and //Server/mount/ . If a path uses an ambiguous root ( /some/path ), the system will assume the drive of the current working directory. Meta characters have no effect when inside a UNC path: //Server?/mount*/ . The one exception is pattern expansion characters like {} which are used by brace expansion and | used by pattern splitting . Pattern expansion characters are the only characters that can be escaped in a Windows drive/mount. If FORCEUNIX is applied on a Windows system, match and filter commands that do not touch the file system will not have slashes normalized. In addition, drive letters will also not be handled. Essentially, paths will be treated as if on a Linux/Unix system. Commands that do touch the file system ( glob and iglob ) will ignore FORCEUNIX and FORCEWIN . globmatch and globfilter , will also ignore FORCEUNIX and FORCEWIN if the REALPATH flag is enabled. FORCEWIN will do the opposite on a Linux/Unix system, and will force Windows logic on a Linux/Unix system. Like with FORCEUNIX , it only applies to commands that don't touch the file system. By default, file and directory names starting with . are only matched with literal . . The patterns * , ** , ? , and [] will not match a leading . . To alter this behavior, you can use the DOTGLOB flag. NEGATE will always enable DOTGLOB in exclude patterns. Even with DOTGLOB enabled, special tokens will not match a special directory ( . or .. ). But when a literal . is used at the start of the pattern ( .* , . , .. , etc.), . and .. can potentially be matched. In general, Wildcard Match's behavior is modeled off of Bash's, and prior to version 7.0, unlike Python's default glob , Wildcard Match's glob would match and return . and .. for magic patterns like .* . This is because our directory scanning logic inserts . and .. into results to be faithful to Bash. While this emulates Bash's behavior, it can be surprising to the user, especially if they are used to Python's default glob. In 7.0 we now avoid returning . and .. in our directory scanner. This does not affect how patterns are matched, just what is returned via our directory scan logic. You can once again enable the old Bash-like behavior with the flag SCANDOTDIR if this old behavior is desired. Python's default: >>> import glob >>> glob . glob ( 'docs/.*' ) [] Wildcard Match: >>> from wcmatch import glob >>> glob . glob ( 'docs/.*' ) [] Bash: $ echo docs/.* docs/. docs/.. Bash-like behavior restored in Wildcard Match SCANDOTDIR : >>> from wcmatch import glob >>> glob . glob ( 'docs/.*' , flags = glob . SCANDOTDIR ) ['docs/.', 'docs/..'] It is important to stress that this logic only relates to directory scanning and does not fundamentally alter glob patterns. We can still match a path of .. with .* when strictly doing a match: >>> from wcmatch import glob >>> glob . globmatch ( '..' , '.*' ) True Nor does it affect exclude results as they are used to filter the results after directory scanning: >>> from wcmatch import glob >>> glob . glob ( '..' ) ['..'] >>> glob . glob ([ '..' , '!.*' ], flags = glob . NEGATE ) [] If we wish to fundamentally alter the pattern matching behavior, we can use NODOTDIR . This would provide a more Zsh feel. >>> from wcmatch import glob >>> glob . glob ([ '..' , '!.*' ], flags = glob . NEGATE | glob . NODOTDIR ) ['..'] >>> glob . glob ([ '..' , '!..' ], flags = glob . NEGATE | glob . NODOTDIR ) [] >>> glob . globmatch ( '..' , '.*' , flags = glob . NODOTDIR ) False Changes 7.0 Prior to 7.0 . and .. would get returned by our directory scanner. This is no longer the default. New 7.0 Legacy behavior of directory scanning, in relation to . and .. , can be restored via SCANDOTDIR . NODOTDIR was added in 7.0. POSIX Character Classes A number of POSIX style character classes are available in the form [:alnum:] . They must be used inside sequences: [[:digit:]] . The C locale is used, and the values for each character class are found in the table below. Property Pattern alnum [a-zA-Z0-9] alpha [a-zA-Z] ascii [\\x00-\\x7F] blank [ \\t] cntrl [\\x00-\\x1F\\x7F] digit [0-9] graph [\\x21-\\x7E] lower [a-z] print [\\x20-\\x7E] punct [!\\\"\\#$%&'()*+,\\-./:;<=>?@\\[\\\\\\]^_`{}~] space [ \\t\\r\\n\\v\\f] upper [A-Z] word [a-zA-Z0-9_] xdigit [A-Fa-f0-9] Windows Separators On Windows, it is not required to use backslashes for path separators as / will match path separators for all systems. The following will work on Windows and Linux/Unix systems. glob . glob ( 'docs/.*' ) With that said, you can match Windows separators with backslashes as well. Keep in mind that Wildcard Match allows escaped characters in patterns, so to match a literal backslash separator, you must escape the backslash. It is advised to use raw strings when using backslashes to make the patterns more readable, but either of the below will work. glob . glob ( r 'docs \\\\ .*' ) glob . glob ( 'docs \\\\\\\\ .*' ) Multi-Pattern Limits Many of the API functions allow passing in multiple patterns or using either BRACE or SPLIT to expand a pattern in to more patterns. The number of allowed patterns is limited 1000 , but you can raise or lower this limit via the keyword option limit . If you set limit to 0 , there will be no limit. New 6.0 The imposed pattern limit and corresponding limit option was introduced in 6.0. API glob.glob def glob ( patterns , * , flags = 0 , root_dir = None , dir_fd = None , limit = 1000 , exclude = None ): glob takes a pattern (or list of patterns), flags, and an optional root directory (string or path-like object) and/or directory file descriptor. It also allows configuring the max pattern limit . Exclusion patterns can be specified via the exclude parameter which takes a pattern or a list of patterns.When executed it will crawl the file system returning matching files. Path-like Input Support Path-like object input support is only available in Python 3.6+ as the path-like protocol was added in Python 3.6. >>> from wcmatch import glob >>> glob . glob ( '**/*.md' ) ['docs/src/markdown/_snippets/abbr.md', 'docs/src/markdown/_snippets/links.md', 'docs/src/markdown/_snippets/refs.md', 'docs/src/markdown/changelog.md', 'docs/src/markdown/fnmatch.md', 'docs/src/markdown/glob.md', 'docs/src/markdown/index.md', 'docs/src/markdown/installation.md', 'docs/src/markdown/license.md', 'README.md'] Using a list, we can add exclusion patterns and also exclude directories and/or files: >>> from wcmatch import glob >>> glob . glob ([ '**/*.md' , '!README.md' , '!**/_snippets' ], flags = glob . NEGATE ) ['docs/src/markdown/changelog.md', 'docs/src/markdown/fnmatch.md', 'docs/src/markdown/glob.md', 'docs/src/markdown/index.md', 'docs/src/markdown/installation.md', 'docs/src/markdown/license.md'] When a glob pattern ends with a slash, it will only return directories: >>> from wcmatch import glob >>> glob . glob ( '**/' ) ['__pycache__/', 'docs/', 'docs/src/', 'docs/src/markdown/', 'docs/src/markdown/_snippets/', 'docs/theme/', 'requirements/', 'stuff/', 'tests/', 'tests/__pycache__/', 'wcmatch/', 'wcmatch/__pycache__/'] When providing a list, all patterns are run in the same context, but will not be run in the same pass. Each pattern is run in a separate pass, except for exclusion patterns (see the NEGATE flag) which are applied as filters to the inclusion patterns. Since each pattern is run in its own pass, it is possible for many directories to be researched multiple times. In Bash, duplicate files can be returned: $ echo *.md README.md LICENSE.md README.md README.md And we see that Wildcard Match's glob behaves the same, except it only returns unique results. >>> from wcmatch import glob >>> glob . glob ([ '*.md' , 'README.md' ]) ['LICENSE.md', 'README.md'] If we wanted to completely match Bash's results, we would turn off unique results with the NOUNIQUE flag. >>> from wcmatch import glob >>> glob . glob ([ '*.md' , 'README.md' ], flags = glob . NOUNIQUE ) ['LICENSE.md', 'README.md', 'README.md'] And if we apply an exclusion pattern, since the patterns share the same context, the exclusion applies to both: >>> from wcmatch import glob >>> glob . glob ([ '*.md' , , 'README.md' , '!README.md' ], flags = glob . NEGATE | glob . NOUNIQUE ) ['LICENSE.md'] Features like BRACE and SPLIT actually take a single string and breaks them up into multiple patterns. These features, when enabled and used, will also exhibit this behavior: >>> from wcmatch import glob >>> glob . glob ( '{*,README}.md' , flags = glob . BRACE | glob . NOUNIQUE ) ['LICENSE.md', 'README.md', 'README.md'] This also aligns with Bash's behavior: $ echo { *,README } .md LICENSE.md README.md README.md You can resolve user paths with ~ if the GLOBTILDE flag is enabled. You can also target specific users with ~user . >>> from wcmatch import glob >>> glob . glob ( '~' , flags = glob . GLOBTILDE ) ['/home/facelessuser'] >>> glob . glob ( '~root' , flags = glob . GLOBTILDE ) ['/root'] By default, glob uses the current working directory to evaluate relative patterns. Normally you'd have to use os . chdir ( '/new/path' ) to evaluate patterns relative to a different path. By setting root_dir parameter you can change the root path without using os.chdir . >>> from wcmatch import glob >>> glob . glob ( '*' ) ['appveyor.yml', 'docs', 'LICENSE.md', 'MANIFEST.in', 'mkdocs.yml', 'README.md', 'requirements', 'setup.cfg', 'setup.py', 'tests', 'tox.ini', 'wcmatch'] >>> glob . glob ( '*' , root_dir = 'docs/src' ) ['dictionary', 'markdown'] Additionally, you can use dir_fd and specify a root directory with a directory file descriptor. >>> import os >>> from wcmatch import glob >>> dir_fd = os . open ( 'docs/src' , os . O_RDONLY | os . O_DIRECTORY ) >>> glob . glob ( '*' , dir_fd = dir_fd ) ['markdown', 'dictionary'] Support for Directory Descriptors Directory descriptors may not be supported on all systems. You can check whether or not dir_fd is supported for a your platform referencing the attribute glob . SUPPORT_DIR_FD which will be True if it is supported. Additionally, the os . O_DIRECTORY may not be defined on some systems. You can likely just use os . O_RDONLY . New 5.1 root_dir was added in 5.1.0. New 6.0 limit was added in 6.0. New 8.2 dir_fd parameter was added in 8.2. New 8.4 exclude parameter was added. glob.iglob def iglob ( patterns , * , flags = 0 , root_dir = None , dir_fd = None , limit = 1000 , exclude = None ): iglob is just like glob except it returns an iterator. >>> from wcmatch import glob >>> list ( glob . iglob ( '**/*.md' )) ['docs/src/markdown/_snippets/abbr.md', 'docs/src/markdown/_snippets/links.md', 'docs/src/markdown/_snippets/refs.md', 'docs/src/markdown/changelog.md', 'docs/src/markdown/fnmatch.md', 'docs/src/markdown/glob.md', 'docs/src/markdown/index.md', 'docs/src/markdown/installation.md', 'docs/src/markdown/license.md', 'README.md'] New 5.1 root_dir was added in 5.1.0. New 6.0 limit was added in 6.0. New 8.2 dir_fd parameter was added in 8.2. New 8.4 exclude parameter was added. glob.globmatch def globmatch ( filename , patterns , * , flags = 0 , root_dir = None , dir_fd = None , limit = 1000 , exclude = None ): globmatch takes a file name (string or path-like object), a pattern (or list of patterns), flags, and an optional root directory and/or file descriptor. It also allows configuring the max pattern limit . Exclusion patterns can be specified via the exclude parameter which takes a pattern or a list of patterns. It will return a boolean indicating whether the file path was matched by the pattern(s). >>> from wcmatch import glob >>> glob . globmatch ( 'some/path/test.txt' , '**/*/@(*.txt|*.py)' , flags = glob . EXTGLOB ) True When applying multiple patterns, a file path matches if it matches any of the patterns: >>> from wcmatch import glob >>> glob . globmatch ( 'some/path/test.txt' , [ '**/*/*.txt' , '**/*/*.py' ]) True Exclusion patterns are allowed as well. When exclusion patterns are used in conjunction with other patterns, a path will be considered matched if one of the positive patterns match and none of the exclusion patterns match. If an exclusion pattern is given without any inclusion patterns, the pattern will match nothing. Exclusion patterns are meant to filter other patterns, not match anything by themselves. >>> from wcmatch import glob >>> glob . globmatch ( 'some/path/test.py' , '**|!**/*.txt' , flags = glob . NEGATE | glob . GLOBSTAR | glob . SPLIT ) True >>> glob . globmatch ( 'some/path/test.txt' , '**|!**/*.txt' , flags = glob . NEGATE | glob . GLOBSTAR | glob . SPLIT ) False >>> glob . globmatch ( 'some/path/test.txt' , [ '*/*/*.txt' , '!*/*/avoid.txt' ], flags = glob . NEGATE ) True >>> glob . globmatch ( 'some/path/avoid.txt' , [ '*/*/*.txt' , '!*/*/avoid.txt' ], flags = glob . NEGATE ) False As mentioned, exclusion patterns need to be applied to a inclusion pattern to work, but if it is desired, you can force exclusion patterns to assume all files should be filtered with the exclusion pattern(s) with the NEGATEALL flag. Essentially, it means if you use a pattern such as !*.md , it means if you use a pattern such as !*.md , it will assume two pattern were given: * and !*.md (where ** is specifically treated as if GLOBSTAR was enabled). >>> from wcmatch import glob >>> glob . globmatch ( 'some/path/test.py' , '!**/*.txt' , flags = glob . NEGATE | glob . GLOBSTAR | glob . NEGATEALL ) True >>> glob . globmatch ( 'some/path/test.txt' , '!**/*.txt' , flags = glob . NEGATE | glob . GLOBSTAR | glob . NEGATEALL ) False By default, globmatch and globfilter do not operate on the file system. This is to allow you to process paths from any source, even paths that are not on your current system. So if you are trying to explicitly match a directory with a pattern such as */ , your path must end with a slash ( my_directory/ ) to be recognized as a directory. It also won't be able to evaluate whether a directory is a symlink or not as it will have no way of checking. Here we see that globmatch fails to match the filepath as the pattern is explicitly looking for a directory and our filepath does not end with / . >>> from wcmatch import glob >>> glob . globmatch ( 'docs' , '*/' ) False If you would like for globmatch (or globfilter ) to operate on your current filesystem directly, simply pass in the REALPATH flag. When enabled, the path under consideration will be analyzed and will use that context to determine if the file exists, if it is a directory, does it's context make sense compared to what the pattern is looking vs the current working directory, or if it has symlinks that should not be matched by GLOBSTAR . Here we use REALPATH and can see that globmatch now knows that doc is a directory. >>> from wcmatch import glob >>> glob . globmatch ( 'docs' , '*/' , flags = glob . REALPATH ) True It also can tell if a file doesn't exist or is out of scope compared to what is being asked. For instance, the below example fails because the pattern is looking for any folder that is relative to the current path, which /usr is not. When we disable REALPATH , it will match just fine. Both cases can be useful depending on how you plan to use globmatch . >>> from wcmatch import glob >>> glob . globmatch ( '/usr' , '**/' , flags = glob . G | glob . REALPATH ) False >>> glob . globmatch ( '/usr' , '**/' , flags = glob . G ) True If you are using REALPATH and want to evaluate the paths relative to a different directory, you can set the root_dir parameter. >>> from wcmatch import glob >>> glob . globmatch ( 'markdown' , 'markdown' , flags = glob . REALPATH ) False >>> glob . globmatch ( 'markdown' , 'markdown' , flags = glob . REALPATH , root_dir = 'docs/src' ) True Additionally, you could also provide a root directory using a file descriptor. >>> import os >>> from wcmatch import glob >>> dir_fd = os . open ( 'docs/src' , os . O_RDONLY | os . O_DIRECTORY ) >>> glob . globmatch ( 'markdown' , 'markdown' , flags = glob . REALPATH ) False >>> glob . globmatch ( 'markdown' , 'markdown' , flags = glob . REALPATH , dir_fd = dir_fd ) True Support for Directory Descriptors Directory descriptors may not be supported on all systems. You can check whether or not dir_fd is supported for a your platform referencing the attribute glob . SUPPORT_DIR_FD which will be True if it is supported. Additionally, the os . O_DIRECTORY may not be defined on some systems. You can likely just use os . O_RDONLY . New 5.1 root_dir was added in 5.1.0. path-like object support for file path inputs was added in 5.1.0 New 6.0 limit was added in 6.0. New 8.2 dir_fd parameter was added in 8.2. New 8.4 exclude parameter was added. glob.globfilter def globfilter ( filenames , patterns , * , flags = 0 , root_dir = None , dir_fd = None , limit = 1000 , method = None ): globfilter takes a list of file paths (strings or path-like objects), a pattern (or list of patterns), flags, and an optional root directory and/or directory file descriptor. It also allows configuring the max pattern limit . Exclusion patterns can be specified via the exclude parameter which takes a pattern or a list of patterns.It returns a list of all files paths that matched the pattern(s). The same logic used for globmatch is used for globfilter , albeit more efficient for processing multiple files. Path-like Input Support Path-like object input support is only available in Python 3.6+ as the path-like protocol was added in Python 3.6. >>> from wcmatch import glob >>> glob . globfilter ([ 'some/path/a.txt' , 'b.txt' , 'another/path/c.py' ], '**/*.txt' ) ['some/path/a.txt', 'b.txt'] Like globmatch , globfilter does not operate directly on the file system, with all the caveats associated. But you can enable the REALPATH flag and globfilter will use the filesystem to gain context such as: whether the file exists, whether it is a directory or not, or whether it has symlinks that should not be matched by GLOBSTAR . See globmatch for examples. New 5.1 root_dir was added in 5.1.0. path-like object support for file path inputs was added in 5.1.0 New 6.0 limit was added in 6.0. New 8.2 dir_fd parameter was added in 8.2. New 8.4 exclude parameter was added. glob.translate def translate ( patterns , * , flags = 0 , limit = 1000 , exclude = None ): translate takes a file pattern (or list of patterns) and flags. It also allows configuring the max pattern limit . Exclusion patterns can be specified via the exclude parameter which takes a pattern or a list of patterns. It returns two lists: one for inclusion patterns and one for exclusion patterns. The lists contain the regular expressions used for matching the given patterns. It should be noted that a file is considered matched if it matches at least one inclusion pattern and matches none of the exclusion patterns. >>> from wcmatch import glob >>> glob . translate ( '**/*.{py,txt}' ) (['^(?s:(?=[^/])(?!(?:\\\\.{1,2})(?:$|[/]))(?:(?!\\\\.)[^/]*?)?[/]+(?=[^/])(?!(?:\\\\.{1,2})(?:$|[/]))(?:(?!\\\\.)[^/]*?)?\\\\.\\\\{py,txt\\\\}[/]*?)$'], []) >>> glob . translate ( '**|!**/*.{py,txt}' , flags = glob . NEGATE | glob . SPLIT ) (['^(?s:(?=[^/])(?!(?:\\\\.{1,2})(?:$|[/]))(?:(?!\\\\.)[^/]*?)?[/]*?)$'], ['^(?s:(?=[^/])(?!(?:\\\\.{1,2})(?:$|[/]))[^/]*?[/]+(?=[^/])(?!(?:\\\\.{1,2})(?:$|[/]))[^/]*?\\\\.\\\\{py,txt\\\\}[/]*?)$']) When using EXTGLOB patterns, patterns will be returned with capturing groups around the groups: While in regex patterns like r '(a)+' would capture only the last character, even though multiple where matched, we wrap the entire group to be captured: '+(a)' \u2192 r '((a)+)' . >>> from wcmatch import glob >>> import re >>> gpat = glob . translate ( \"@(file)+([[:digit:]])@(.*)\" , flags = glob . EXTGLOB ) >>> pat = re . compile ( gpat [ 0 ][ 0 ]) >>> pat . match ( 'file33.test.txt' ) . groups () ('file', '33', '.test.txt') New 6.0 limit was added in 6.0. New 7.1 Translate patterns now provide capturing groups for EXTGLOB groups. New 8.4 exclude parameter was added. glob.escape def escape ( pattern , unix = None ): The escape function will conservatively escape - , ! , * , ? , ( , ) , [ , ] , | , { , } . and \\ with backslashes, regardless of what feature is or is not enabled. It is meant to escape path parts (filenames, Windows drives, UNC sharepoints) or full paths. >>> from wcmatch import glob >>> glob . escape ( 'some/path?/**file** {} .txt' ) 'some/path\\\\?/\\\\*\\\\*file\\\\*\\\\*\\\\{}.txt' >>> glob . globmatch ( 'some/path?/**file** {} .txt' , glob . escape ( 'some/path?/**file** {} .txt' )) True escape can also handle Windows style paths with / or \\ path separators. It is usually recommended to use / as Windows backslashes are only supported via a special escape, but \\ will be expanded to an escaped backslash (represented in a raw string as r ' \\\\ ' or a normal string as ' \\\\\\\\ ' ). >>> from wmcatch import glob >>> glob . escape ( 'some \\\\ path? \\\\ **file** {} .txt' , unix = False ) 'some\\\\\\\\path\\\\?\\\\\\\\\\\\*\\\\*file\\\\*\\\\*\\\\{\\\\}.txt' >>> glob . globmatch ( 'some \\\\ path? \\\\ **file** {} .txt' , glob . escape ( 'some \\\\ path? \\\\ **file** {} .txt' ), flags = glob . FORCEWIN ) True >>> glob . escape ( 'some/path?/**file** {} .txt' , unix = False ) 'some/path\\\\?/\\\\*\\\\*file\\\\*\\\\*\\\\{\\\\}.txt' >>> glob . globmatch ( 'some \\\\ path? \\\\ **file** {} .txt' , glob . escape ( 'some/path?/**file** {} .txt' ), flags = glob . FORCEWIN ) True On a Windows system, meta characters are not processed in drives or UNC sharepoints except for pattern expansion meta characters. { and } (when using BRACE ) and | (when using SPLIT ) are the only meta characters that can affect drives and UNC sharepoints; therefore, they are the only characters that need to be escaped. escape , when it detects or is informed that it is processing a Windows path, escape will properly find and handle drives and UNC sharepoints. >>> from wmcatch import glob >>> glob . escape ( '//./Volume{b75e2c83-0000-0000-0000-602f00000000}\\Test\\Foo.txt' , unix = False ) '//./Volume\\\\{b75e2c83-0000-0000-0000-602f00000000\\\\}\\\\\\\\Test\\\\\\\\Foo.txt' escape will detect the system it is running on and pick Windows escape logic or Linux/Unix logic. Since globmatch allows you to match Unix style paths on a Windows system and vice versa, you can force Unix style escaping or Windows style escaping via the unix parameter. When unix is None , the escape style will be detected, when unix is True Linux/Unix style escaping will be used, and when unix is False Windows style escaping will be used. >>> glob . escape ( 'some/path?/**file** {} .txt' , unix = True ) New 5.0 The unix parameter is now None by default. Set to True to force Linux/Unix style escaping or set to False to force Windows style escaping. New 7.0 { , } , and | will be escaped in Windows drives. Additionally, users can escape these characters in Windows drives manually in their match patterns as well. glob.raw_escape Deprecated 8.1 In 8.1, raw_escape has been deprecated. The same can be accomplished simply by using codecs and then using the normal escape : >>> string = r \"translate \\\\ raw strings \\\\ \\u00c3\\xc3\\303\\N{LATIN CAPITAL LETTER A WITH TILDE}\" >>> translated = codecs . decode ( string , 'unicode_escape' ) >>> glob . escape ( translated ) 'translate\\\\\\\\raw strings\\\\\\\\\u00c3\u00c3\u00c3\u00c3' >>> glob . raw_escape ( string ) 'translate\\\\\\\\raw strings\\\\\\\\\u00c3\u00c3\u00c3\u00c3' def raw_escape ( pattern , unix = None , raw_chars = True ): raw_escape is kind of a niche function and 99% of the time, it is recommended to use escape . The big difference between raw_escape and escape is how \\ are handled. raw_escape is mainly for paths provided to Python via an interface that doesn't process Python strings like they normally are, for instance an input in a GUI. To illustrate, you may have an interface to input path names, but may want to take advantage of Python Unicode references. Normally, on a python command line, you can do this: >>> 'folder \\\\ El Ni \\u00f1 o' 'folder\\\\El Ni\u00f1o' But when in a GUI interface, if a user inputs the same, it's like getting a raw string. >>> r 'folder \\\\ El Ni\\u00f1o' 'folder\\\\\\\\El Ni\\\\u00f1o' raw_escape will take a raw string in the above format and resolve character escapes and escape the path as if it was a normal string. Notice to do this, we must treat literal Windows' path backslashes as an escaped backslash. >>> glob . escape ( 'folder \\\\ El Ni \\u00f1 o' , unix = False ) 'folder\\\\\\\\El Ni\u00f1o' >>> glob . raw_escape ( r 'folder \\\\ El Ni\\u00f1o' ) 'folder\\\\\\\\El Ni\u00f1o' Handling of raw character references can be turned off if desired: >>> glob . raw_escape ( r 'my \\\\ file-\\x31.txt' , unix = False ) 'my\\\\\\\\file\\\\-1.txt' >>> glob . raw_escape ( r 'my \\\\ file-\\x31.txt' , unix = False , raw_chars = False ) 'my\\\\\\\\file\\\\-\\\\\\\\x31.txt' Outside of the treatment of \\ , raw_escape will function just like escape : raw_escape will detect the system it is running on and pick Windows escape logic or Linux/Unix logic. Since globmatch allows you to match Unix style paths on a Windows system, and vice versa, you can force Unix style escaping or Windows style escaping via the unix parameter. When unix is None , the escape style will be detected, when unix is True Linux/Unix style escaping will be used, and when unix is False Windows style escaping will be used. >>> glob . raw_escape ( r 'some/path?/\\x2a\\x2afile\\x2a\\x2a {} .txt' , unix = True ) New 5.0 The unix parameter is now None by default. Set to True to force Linux/Unix style escaping or set to False to force Windows style escaping. New 7.0 { , } , and | will be escaped in Windows drives. Additionally, users can escape these characters in Windows drives manually in their match patterns as well. raw_chars option was added. glob.is_magic def is_magic ( pattern , * , flags = 0 ): \"\"\"Check if the pattern is likely to be magic.\"\"\" This checks a given path or pattern or to see if \"magic\" symbols are present or not. The check is based on the enabled features via flags . Paths and patterns are expected to be/target full paths, full filenames, full drive names, or full UNC sharepoints. If is_magic is run on a Windows path it will always flag it as \"magic\" unless you convert the directory separators to / as \\ is a \"magic\" symbol. >>> glob . is_magic ( 'test' ) False >>> glob . is_magic ( '[test]ing?' ) True When is_magic is called, the system it is called on is detected automatically and/or inferred from flags such as FORCEUNIX or FORCEWIN . If the pattern is checked against a Windows system, UNC sharepoints will be detected and treated differently. Wildcard Match cannot detect and glob all possible connected sharepoints, so they are treated differently and cannot contain magic except in three cases: The drive or sharepoint is using backslashes as backslashes are treated as magic. BRACE is enabled and either { or } are found in the drive name or UNC sharepoint. SPLIT is enabled and | is found in the drive name or UNC sharepoint. >>> glob . is_magic ( '//?/UNC/server/mount {} /' , flags = glob . FORCEWIN ) False >>> glob . is_magic ( '//?/UNC/server/mount {} /' , flags = glob . FORCEWIN | glob . BRACE ) True The table below illustrates which symbols are searched for based on the given feature. Each feature adds to the \"default\". In the case of NEGATE , if MINUSNEGATE is also enabled, MINUSNEGATE 's symbols will be searched instead of NEGATE 's symbols. Features Symbols Default ?*[]\\ EXTMATCH () BRACE {} NEGATE ! MINUSNEGATE - SPLIT | GLOBTILDE ~ New 8.1 Added is_magic in 8.1. Flags glob.CASE, glob.C CASE forces case sensitivity. CASE has higher priority than IGNORECASE . On Windows, drive letters ( C: ) and UNC sharepoints ( //host/share ) portions of a path will still be treated case insensitively, but the rest of the path will have case sensitive logic applied. glob.IGNORECASE, glob.I IGNORECASE forces case insensitivity. CASE has higher priority than IGNORECASE . glob.RAWCHARS, glob.R RAWCHARS causes string character syntax to be parsed in raw strings: r '\\u0040' \u2192 r '@' . This will handle standard string escapes and Unicode including r '\\N{CHAR NAME}' . glob.NEGATE, glob.N NEGATE causes patterns that start with ! to be treated as exclusion patterns. A pattern of !*.py exclude any Python files. Exclusion patterns cannot be used by themselves though, and must be paired with a normal, inclusion pattern, either by utilizing the SPLIT flag, or providing multiple patterns in a list. Assuming the SPLIT flag, this means using it in a pattern such as inclusion|!exclusion . If it is desired, you can force exclusion patterns, when no inclusion pattern is provided, to assume all files match unless the file matches the excluded pattern. This is done with the NEGATEALL flag. NEGATE enables DOTGLOB in all exclude patterns, this cannot be disabled. This will not affect the inclusion patterns. If NEGATE is set and exclusion patterns are passed via a matching or glob function's exclude parameter, NEGATE will be ignored and the exclude patterns will be used instead. Either exclude or NEGATE should be used, not both. glob.NEGATEALL, glob.A NEGATEALL can force exclusion patterns, when no inclusion pattern is provided, to assume all files match unless the file matches the excluded pattern. Essentially, it means if you use a pattern such as !*.md , it will assume two patterns were given: ** and !*.md , where !*.md is applied to the results of ** , and ** is specifically treated as if GLOBSTAR was enabled. Dot files will not be returned unless DOTGLOB is enabled. Symlinks will also be ignored in the return unless FOLLOW is enabled. glob.MINUSNEGATE, glob.M When MINUSNEGATE is used with NEGATE , exclusion patterns are recognized by a pattern starting with - instead of ! . This plays nice with the extended glob feature which already uses ! in patterns such as !(...) . glob.GLOBSTAR, glob.G GLOBSTAR enables the feature where ** matches zero or more directories. glob.FOLLOW, glob.L FOLLOW will cause GLOBSTAR patterns ( ** ) to match and traverse symlink directories. glob.REALPATH, glob.P In the past, only glob and iglob operated on the filesystem, but with REALPATH , other functions will now operate on the filesystem as well: globmatch and globfilter . Normally, functions such as globmatch would simply match a path with regular expression and return the result. The functions were not concerned with whether the path existed or not. It didn't care if it was even valid for the operating system. REALPATH forces globmatch and globfilter to treat the string path as a real file path for the given system it is running on. It will augment the patterns used to match files and enable additional logic so that the path must meet the following in order to match: Path must exist. Directories that are symlinks will not be matched by GLOBSTAR patterns ( ** ) unless the FOLLOW flag is enabled. When presented with a pattern where the match must be a directory, but the file path being compared doesn't indicate the file is a directory with a trailing slash, the command will look at the filesystem to determine if it is a directory. Paths must match in relation to the current working directory unless the pattern is constructed in a way to indicates an absolute path. Since REALPATH causes the file system to be referenced when matching a path, flags such as FORCEUNIX and FORCEWIN are not allowed with this flag and will be ignored. glob.DOTGLOB, glob.D By default, glob and globmatch will not match file or directory names that start with dot . unless matched with a literal dot. DOTGLOB allows the meta characters (such as * ) to glob dots like any other character. Dots will not be matched in [] , * , or ? . Alternatively DOTMATCH will also be accepted for consistency with the other provided libraries. Both flags are exactly the same and are provided as a convenience in case the user finds one more intuitive than the other since DOTGLOB is often the name used in Bash. glob.NODOTDIR, glob.Z NOTDOTDIR fundamentally changes how glob patterns deal with . and .. . This is great if you'd prefer a more Zsh feel when it comes to special directory matching. When NODOTDIR is enabled, \"magic\" patterns, such as .* , will not match the special directories of . and .. . In order to match these special directories, you will have to use literal glob patterns of . and .. . This can be used in all glob API functions that accept flags, and will affect inclusion patterns as well as exclusion patterns. >>> from wcmatch import glob >>> glob . globfilter ([ '.' , '..' ], '.*' ) ['.', '..'] >>> glob . globfilter ([ '.' , '..' ], '.*' , flags = glob . NODOTDIR ) [] >>> glob . globfilter ([ '.' , '..' ], '.' , flags = glob . NODOTDIR ) ['.'] >>> glob . globfilter ([ '.' , '..' ], '..' , flags = glob . NODOTDIR ) ['..'] Also affects exclusion patterns: >>> from wcmatch import glob >>> glob . glob ([ '..' , '!.*' ], flags = glob . NEGATE ) [] >>> glob . glob ([ '..' , '!.*' ], flags = glob . NEGATE | glob . NODOTDIR ) ['..'] >>> glob . glob ([ '..' , '!..' ], flags = glob . NEGATE | glob . NODOTDIR ) [] New 7.0 NODOTDIR was added in 7.0. glob.SCANDOTDIR, glob.SD SCANDOTDIR controls the directory scanning behavior of glob and iglob . The directory scanner of these functions do not return . and .. in their results. This means that unless you use an explicit . or .. in your glob pattern, . and .. will not be returned. When SCANDOTDIR is enabled, . and .. will be returned when a directory is scanned causing \"magic\" patterns, such as .* , to match . and .. . This only controls the directory scanning behavior and not how glob patterns behave. Exclude patterns, which filter the returned results via NEGATE , can still match . and .. with \"magic\" patterns such as .* regardless of whether SCANDOTDIR is enabled or not. It will also have no affect on globmatch . To fundamentally change how glob patterns behave, you can use NODOTDIR . >>> from wcmatch import glob >>> glob . glob ( '.*' ) ['.codecov.yml', '.tox', '.coverage', '.coveragerc', '.gitignore', '.github', '.pyspelling.yml', '.git'] >>> glob . glob ( '.*' , flags = glob . SCANDOTDIR ) ['.', '..', '.codecov.yml', '.tox', '.coverage', '.coveragerc', '.gitignore', '.github', '.pyspelling.yml', '.git'] New 7.0 SCANDOTDIR was added in 7.0. glob.EXTGLOB, glob.E EXTGLOB enables extended pattern matching which includes special pattern lists such as +(...) , *(...) , ?(...) , etc. Pattern lists allow for multiple patterns within them separated by | . See the globbing syntax overview for more information. Alternatively EXTMATCH will also be accepted for consistency with the other provided libraries. Both flags are exactly the same and are provided as a convenience in case the user finds one more intuitive than the other since EXTGLOB is often the name used in Bash. EXTGLOB and NEGATE When using EXTGLOB and NEGATE together, if a pattern starts with !( , the pattern will not be treated as a NEGATE pattern (even if !( doesn't yield a valid EXTGLOB pattern). To negate a pattern that starts with a literal ( , you must escape the bracket: !\\( . glob.BRACE, glob.B BRACE enables Bash style brace expansion: a{b,{c,d}} \u2192 ab ac ad . Brace expansion is applied before anything else. When applied, a pattern will be expanded into multiple patterns. Each pattern will then be parsed separately. Duplicate patterns will be discarded 1 by default, and glob and iglob will return only unique results. If you need glob or iglob to behave more like Bash and return all results, you can set NOUNIQUE . NOUNIQUE has no effect on matching functions such as globmatch and globfilter . For simple patterns, it may make more sense to use EXTGLOB which will only generate a single pattern which will perform much better: @(ab|ac|ad) . Massive Expansion Risk It is important to note that each pattern is crawled separately, so patterns such as {1..100} would generate one hundred patterns. In a match function ( globmatch ), that would cause a hundred compares, and in a file crawling function ( glob ), it would cause the file system to be crawled one hundred times. Sometimes patterns like this are needed, so construct patterns thoughtfully and carefully. BRACE and SPLIT both expand patterns into multiple patterns. Using these two syntaxes simultaneously can exponential increase duplicate patterns: >>> expand ( 'test@(this{|that,|other})|*.py' , BRACE | SPLIT | EXTMATCH ) ['test@(this|that)', 'test@(this|other)', '*.py', '*.py'] This effect is reduced as redundant, identical patterns are optimized away 1 , but when using crawling functions (like glob ) and NOUNIQUE that optimization is removed, and all of those patterns will be crawled. For this reason, especially when using functions like glob , it is recommended to use one syntax or the other. glob.SPLIT, glob.S SPLIT is used to take a string of multiple patterns that are delimited by | and split them into separate patterns. This is provided to help with some interfaces that might need a way to define multiple patterns in one input. It pairs really well with EXTGLOB and takes into account sequences ( [] ) and extended patterns ( *(...) ) and will not parse | within them. You can also escape the delimiters if needed: \\| . Duplicate patterns will be discarded 1 by default, and glob and iglob will return only unique results. If you need glob or iglob to behave more like Bash and return all results, you can set NOUNIQUE . NOUNIQUE has no effect on matching functions such as globmatch and globfilter . While SPLIT is not as powerful as BRACE , it's syntax is very easy to use, and when paired with EXTGLOB , it feels natural and comes a bit closer. It is also much harder to create massive expansions of patterns with it, except when paired with BRACE . See BRACE and its warnings related to pairing it with SPLIT . >>> from wcmatch import glob >>> glob . globmatch ( 'test.txt' , '*.txt|*.py' , flags = fnmatch . SPLIT ) True >>> glob . globmatch ( 'test.py' , '*.txt|*.py' , flags = fnmatch . SPLIT ) True glob.NOUNIQUE, glob.Q NOUNIQUE is used to disable Wildcard Match's unique results return. This mimics Bash's output behavior if that is desired. >>> from wcmatch import glob >>> glob . glob ( '{*,README}.md' , flags = glob . BRACE | glob . NOUNIQUE ) ['LICENSE.md', 'README.md', 'README.md'] >>> glob . glob ( '{*,README}.md' , flags = glob . BRACE ) ['LICENSE.md', 'README.md'] By default, only unique paths are returned in glob and iglob . Normally this is what a programmer would want from such a library, so input patterns are reduced to unique patterns 1 to reduce excessive matching with redundant patterns and excessive crawls through the file system. Also, as two different patterns that have been fed into glob may match the same file, the results are also filtered as to not return the duplicates. Unique results is are accomplished by filtering out duplicate patterns and by retaining an internal set of returned files to determine duplicates. The internal set of files is not retained if only a single, inclusive pattern is provided. Exclusive patterns via NEGATE will not trigger the logic. Singular inclusive patterns that use pattern expansions due to BRACE or SPLIT will act as if multiple patterns were provided, and will trigger the duplicate filtering logic. This is mentioned as functions such as iglob , which normally are expected to not retain results in memory, will be forced to retain a set to ensure unique results if multiple inclusive patterns are provided. NOUNIQUE disables all of the aforementioned \"unique\" optimizations, but only for glob and iglob . Functions like globmatch and globfilter would get no benefit from disabling \"unique\" optimizations as they only match what they are given. New in 6.0 \"Unique\" optimizations were added in 6.0, along with NOUNIQUE . glob.GLOBTILDE, glob.T GLOBTILDE allows for user path expansion via ~ . You can get the current user path by using ~ at the start of a path. ~ can be used as the entire pattern, or it must be followed by a directory slash: ~/more-pattern . To specify a specific user, you can explicitly specify a user name via ~user . If additional pattern is needed, the user name must be followed by a directory slash: ~user/more-pattern . >>> from wcmatch import glob >>> glob . glob ( '~' , flags = glob . GLOBTILDE ) ['/home/facelessuser'] >>> glob . glob ( '~root' , flags = glob . GLOBTILDE ) ['/root'] GLOBTILDE can also be used in things like globfilter or globmatch , but you must be using REALPATH or the user path will not be expanded. from wcmatch import glob >>> glob . globmatch ( '/home/facelessuser/' , '~' , flags = glob . GLOBTILDE | glob . REALPATH ) True New 6.0 Tilde expansion with GLOBTILDE was added in version 6.0. glob.MARK, glob.K MARK ensures that glob and iglob to return all directories with a trailing slash. This makes it very clear which paths are directories and allows you to save calling os.path.isdir as you can simply check for a path separator at the end of the path. This flag only applies to calls to glob or iglob . If you are passing the returned files from glob to globfilter or globmatch , it is important to ensure directory paths have trailing slashes as these functions have no way of telling the path is a directory otherwise (except when REALPATH is enabled). If you have REALPATH enabled, ensuring the files have trailing slashes can still save you a call to os.path.isdir as REALPATH resorts to calling it if there is no trailing slash. >>> from wcmatch import glob >>> glob . glob ( '*' , flags = glob . MARK ) ['appveyor.yml', 'base.patch', 'basematch.diff', 'docs/', 'LICENSE.md', 'MANIFEST.in', 'mkdocs.yml', 'README.md', 'requirements/', 'setup.cfg', 'setup.py', 'tests/', 'tools/', 'tox.ini', 'wcmatch/'] >>> glob . glob ( '*' ) ['appveyor.yml', 'base.patch', 'basematch.diff', 'docs', 'LICENSE.md', 'MANIFEST.in', 'mkdocs.yml', 'README.md', 'requirements', 'setup.cfg', 'setup.py', 'tests', 'tools', 'tox.ini', 'wcmatch'] glob.MATCHBASE, glob.X MATCHBASE , when a pattern has no slashes in it, will cause glob and iglob to seek for any file anywhere in the tree with a matching basename. When enabled for globfilter and globmatch , any path whose basename matches. MATCHBASE is sensitive to files and directories that start with . and will not match such files and directories if DOTGLOB is not enabled. >>> from wcmatch import glob >>> glob . glob ( '*.txt' , flags = glob . MATCHBASE ) ['docs/src/dictionary/en-custom.txt', 'docs/src/markdown/_snippets/abbr.txt', 'docs/src/markdown/_snippets/links.txt', 'docs/src/markdown/_snippets/posix.txt', 'docs/src/markdown/_snippets/refs.txt', 'requirements/docs.txt', 'requirements/lint.txt', 'requirements/setup.txt', 'requirements/test.txt', 'requirements/tools.txt'] glob.NODIR, glob.O NODIR will cause glob , iglob , globmatch , and globfilter to return only matched files. >>> from wcmatch import glob >>> glob . glob ( '*' , flags = glob . NODIR ) ['appveyor.yml', 'LICENSE.md', 'MANIFEST.in', 'mkdocs.yml', 'README.md', 'setup.cfg', 'setup.py', 'spell.log', 'tox.ini'] >>> glob . glob ( '*' ) ['appveyor.yml', 'docs', 'LICENSE.md', 'MANIFEST.in', 'mkdocs.yml', 'README.md', 'requirements', 'setup.cfg', 'setup.py', 'spell.log', 'tests', 'tools', 'tox.ini', 'wcmatch'] glob.FORCEWIN, glob.W FORCEWIN will force Windows path and case logic to be used on Linux/Unix systems. It will also cause slashes to be normalized and Windows drive syntax to be handled special. This is great if you need to match Windows specific paths on a Linux/Unix system. This will only work on commands that do not access the file system: translate , globmatch , globfilter , etc. These flags will not work with glob or iglob . It also will not work when using the REALPATH flag with things like globmatch and globfilter . If FORCEWIN is used along side FORCEUNIX , both will be ignored. glob.FORCEUNIX, glob.U FORCEUNIX will force Linux/Unix path and case logic to be used on Windows systems. This is great if you need to match Linux/Unix specific paths on a Windows system. This will only work on commands that do not access the file system: translate , globmatch , globfilter , etc. These flags will not work with glob or iglob . It also will not work when using the REALPATH flag with things like globmatch and globfilter . When using FORCEUNIX , the paths are assumed to be case sensitive, but you can use IGNORECASE to use case insensitivity. If FORCEUNIX is used along side FORCEWIN , both will be ignored. Identical patterns are only reduced by comparing case sensitively as POSIX character classes are case sensitive: [[:alnum:]] \u2260 [[:ALNUM:]] . \u21a9 \u21a9 \u21a9 \u21a9","title":"Usage"},{"location":"glob/#wcmatchglob","text":"from wcmatch import glob","title":"wcmatch.glob"},{"location":"glob/#syntax","text":"The glob library provides methods for traversing the file system and returning files that matched a defined set of glob patterns. The library also provides a function called globmatch for matching file paths which is similar to fnmatch , but for paths. In short, globmatch matches what glob globs . Tip When using backslashes, it is helpful to use raw strings. In a raw string, a single backslash is used to escape a character r '\\?' . If you want to represent a literal backslash, you must use two: r 'some \\\\ path' . Pattern Meaning * Matches everything except slashes. On Windows it will avoid matching backslashes as well as slashes. ** Matches zero or more directories, but will never match the directories . and .. . Requires the GLOBSTAR flag. ? Matches any single character. [seq] Matches any character in seq. [!seq] Matches any character not in seq. Will also accept character exclusions in the form of [^seq] . [[:alnum:]] POSIX style character classes inside sequences. See POSIX Character Classes for more info. \\ Escapes characters. If applied to a meta character or non-meta characters, the character will be treated as a literal character. If applied to another escape, the backslash will be a literal backslash. ! When used at the start of a pattern, the pattern will be an exclusion pattern. Requires the NEGATE flag. If also using the MINUSNEGATE flag, - will be used instead of ! . ?(pattern_list) The pattern matches if zero or one occurrences of any of the patterns in the pattern_list match the input string. Requires the EXTGLOB flag. *(pattern_list) The pattern matches if zero or more occurrences of any of the patterns in the pattern_list match the input string. Requires the EXTGLOB flag. +(pattern_list) The pattern matches if one or more occurrences of any of the patterns in the pattern_list match the input string. Requires the EXTGLOB flag. @(pattern_list) The pattern matches if exactly one occurrence of any of the patterns in the pattern_list match the input string. Requires the EXTGLOB flag. !(pattern_list) The pattern matches if the input string cannot be matched with any of the patterns in the pattern_list . Requires the EXTGLOB flag. {} Bash style brace expansions. This is applied to patterns before anything else. Requires the BRACE flag. ~/pattern User path expansion via ~/pattern or ~user/pattern . Requires the GLOBTILDE flag. Slashes are generally treated special in glob related methods. Slashes are not matched in [] , * , ? , or extended patterns like *(...) . Slashes can be matched by ** if GLOBSTAR is set. Slashes on Windows are normalized. / will match both / and \\\\ . There is no need to explicitly use \\\\ in patterns on Windows, but if you do, they must be escaped to specify a literal \\\\ . If a backslash is escaped, it will match all valid windows separators, just like / does. On Windows, drives are treated special and must come at the beginning of the pattern and cannot be matched with * , [] , ? , or even extended match patterns like +(...) . Windows drives are recognized as either C:/ and //Server/mount/ . If a path uses an ambiguous root ( /some/path ), the system will assume the drive of the current working directory. Meta characters have no effect when inside a UNC path: //Server?/mount*/ . The one exception is pattern expansion characters like {} which are used by brace expansion and | used by pattern splitting . Pattern expansion characters are the only characters that can be escaped in a Windows drive/mount. If FORCEUNIX is applied on a Windows system, match and filter commands that do not touch the file system will not have slashes normalized. In addition, drive letters will also not be handled. Essentially, paths will be treated as if on a Linux/Unix system. Commands that do touch the file system ( glob and iglob ) will ignore FORCEUNIX and FORCEWIN . globmatch and globfilter , will also ignore FORCEUNIX and FORCEWIN if the REALPATH flag is enabled. FORCEWIN will do the opposite on a Linux/Unix system, and will force Windows logic on a Linux/Unix system. Like with FORCEUNIX , it only applies to commands that don't touch the file system. By default, file and directory names starting with . are only matched with literal . . The patterns * , ** , ? , and [] will not match a leading . . To alter this behavior, you can use the DOTGLOB flag. NEGATE will always enable DOTGLOB in exclude patterns. Even with DOTGLOB enabled, special tokens will not match a special directory ( . or .. ). But when a literal . is used at the start of the pattern ( .* , . , .. , etc.), . and .. can potentially be matched. In general, Wildcard Match's behavior is modeled off of Bash's, and prior to version 7.0, unlike Python's default glob , Wildcard Match's glob would match and return . and .. for magic patterns like .* . This is because our directory scanning logic inserts . and .. into results to be faithful to Bash. While this emulates Bash's behavior, it can be surprising to the user, especially if they are used to Python's default glob. In 7.0 we now avoid returning . and .. in our directory scanner. This does not affect how patterns are matched, just what is returned via our directory scan logic. You can once again enable the old Bash-like behavior with the flag SCANDOTDIR if this old behavior is desired. Python's default: >>> import glob >>> glob . glob ( 'docs/.*' ) [] Wildcard Match: >>> from wcmatch import glob >>> glob . glob ( 'docs/.*' ) [] Bash: $ echo docs/.* docs/. docs/.. Bash-like behavior restored in Wildcard Match SCANDOTDIR : >>> from wcmatch import glob >>> glob . glob ( 'docs/.*' , flags = glob . SCANDOTDIR ) ['docs/.', 'docs/..'] It is important to stress that this logic only relates to directory scanning and does not fundamentally alter glob patterns. We can still match a path of .. with .* when strictly doing a match: >>> from wcmatch import glob >>> glob . globmatch ( '..' , '.*' ) True Nor does it affect exclude results as they are used to filter the results after directory scanning: >>> from wcmatch import glob >>> glob . glob ( '..' ) ['..'] >>> glob . glob ([ '..' , '!.*' ], flags = glob . NEGATE ) [] If we wish to fundamentally alter the pattern matching behavior, we can use NODOTDIR . This would provide a more Zsh feel. >>> from wcmatch import glob >>> glob . glob ([ '..' , '!.*' ], flags = glob . NEGATE | glob . NODOTDIR ) ['..'] >>> glob . glob ([ '..' , '!..' ], flags = glob . NEGATE | glob . NODOTDIR ) [] >>> glob . globmatch ( '..' , '.*' , flags = glob . NODOTDIR ) False Changes 7.0 Prior to 7.0 . and .. would get returned by our directory scanner. This is no longer the default. New 7.0 Legacy behavior of directory scanning, in relation to . and .. , can be restored via SCANDOTDIR . NODOTDIR was added in 7.0.","title":"Syntax"},{"location":"glob/#posix-character-classes","text":"A number of POSIX style character classes are available in the form [:alnum:] . They must be used inside sequences: [[:digit:]] . The C locale is used, and the values for each character class are found in the table below. Property Pattern alnum [a-zA-Z0-9] alpha [a-zA-Z] ascii [\\x00-\\x7F] blank [ \\t] cntrl [\\x00-\\x1F\\x7F] digit [0-9] graph [\\x21-\\x7E] lower [a-z] print [\\x20-\\x7E] punct [!\\\"\\#$%&'()*+,\\-./:;<=>?@\\[\\\\\\]^_`{}~] space [ \\t\\r\\n\\v\\f] upper [A-Z] word [a-zA-Z0-9_] xdigit [A-Fa-f0-9]","title":"POSIX Character Classes"},{"location":"glob/#windows-separators","text":"On Windows, it is not required to use backslashes for path separators as / will match path separators for all systems. The following will work on Windows and Linux/Unix systems. glob . glob ( 'docs/.*' ) With that said, you can match Windows separators with backslashes as well. Keep in mind that Wildcard Match allows escaped characters in patterns, so to match a literal backslash separator, you must escape the backslash. It is advised to use raw strings when using backslashes to make the patterns more readable, but either of the below will work. glob . glob ( r 'docs \\\\ .*' ) glob . glob ( 'docs \\\\\\\\ .*' )","title":"Windows Separators"},{"location":"glob/#multi-pattern-limits","text":"Many of the API functions allow passing in multiple patterns or using either BRACE or SPLIT to expand a pattern in to more patterns. The number of allowed patterns is limited 1000 , but you can raise or lower this limit via the keyword option limit . If you set limit to 0 , there will be no limit. New 6.0 The imposed pattern limit and corresponding limit option was introduced in 6.0.","title":"Multi-Pattern Limits"},{"location":"glob/#api","text":"","title":"API"},{"location":"glob/#glob","text":"def glob ( patterns , * , flags = 0 , root_dir = None , dir_fd = None , limit = 1000 , exclude = None ): glob takes a pattern (or list of patterns), flags, and an optional root directory (string or path-like object) and/or directory file descriptor. It also allows configuring the max pattern limit . Exclusion patterns can be specified via the exclude parameter which takes a pattern or a list of patterns.When executed it will crawl the file system returning matching files. Path-like Input Support Path-like object input support is only available in Python 3.6+ as the path-like protocol was added in Python 3.6. >>> from wcmatch import glob >>> glob . glob ( '**/*.md' ) ['docs/src/markdown/_snippets/abbr.md', 'docs/src/markdown/_snippets/links.md', 'docs/src/markdown/_snippets/refs.md', 'docs/src/markdown/changelog.md', 'docs/src/markdown/fnmatch.md', 'docs/src/markdown/glob.md', 'docs/src/markdown/index.md', 'docs/src/markdown/installation.md', 'docs/src/markdown/license.md', 'README.md'] Using a list, we can add exclusion patterns and also exclude directories and/or files: >>> from wcmatch import glob >>> glob . glob ([ '**/*.md' , '!README.md' , '!**/_snippets' ], flags = glob . NEGATE ) ['docs/src/markdown/changelog.md', 'docs/src/markdown/fnmatch.md', 'docs/src/markdown/glob.md', 'docs/src/markdown/index.md', 'docs/src/markdown/installation.md', 'docs/src/markdown/license.md'] When a glob pattern ends with a slash, it will only return directories: >>> from wcmatch import glob >>> glob . glob ( '**/' ) ['__pycache__/', 'docs/', 'docs/src/', 'docs/src/markdown/', 'docs/src/markdown/_snippets/', 'docs/theme/', 'requirements/', 'stuff/', 'tests/', 'tests/__pycache__/', 'wcmatch/', 'wcmatch/__pycache__/'] When providing a list, all patterns are run in the same context, but will not be run in the same pass. Each pattern is run in a separate pass, except for exclusion patterns (see the NEGATE flag) which are applied as filters to the inclusion patterns. Since each pattern is run in its own pass, it is possible for many directories to be researched multiple times. In Bash, duplicate files can be returned: $ echo *.md README.md LICENSE.md README.md README.md And we see that Wildcard Match's glob behaves the same, except it only returns unique results. >>> from wcmatch import glob >>> glob . glob ([ '*.md' , 'README.md' ]) ['LICENSE.md', 'README.md'] If we wanted to completely match Bash's results, we would turn off unique results with the NOUNIQUE flag. >>> from wcmatch import glob >>> glob . glob ([ '*.md' , 'README.md' ], flags = glob . NOUNIQUE ) ['LICENSE.md', 'README.md', 'README.md'] And if we apply an exclusion pattern, since the patterns share the same context, the exclusion applies to both: >>> from wcmatch import glob >>> glob . glob ([ '*.md' , , 'README.md' , '!README.md' ], flags = glob . NEGATE | glob . NOUNIQUE ) ['LICENSE.md'] Features like BRACE and SPLIT actually take a single string and breaks them up into multiple patterns. These features, when enabled and used, will also exhibit this behavior: >>> from wcmatch import glob >>> glob . glob ( '{*,README}.md' , flags = glob . BRACE | glob . NOUNIQUE ) ['LICENSE.md', 'README.md', 'README.md'] This also aligns with Bash's behavior: $ echo { *,README } .md LICENSE.md README.md README.md You can resolve user paths with ~ if the GLOBTILDE flag is enabled. You can also target specific users with ~user . >>> from wcmatch import glob >>> glob . glob ( '~' , flags = glob . GLOBTILDE ) ['/home/facelessuser'] >>> glob . glob ( '~root' , flags = glob . GLOBTILDE ) ['/root'] By default, glob uses the current working directory to evaluate relative patterns. Normally you'd have to use os . chdir ( '/new/path' ) to evaluate patterns relative to a different path. By setting root_dir parameter you can change the root path without using os.chdir . >>> from wcmatch import glob >>> glob . glob ( '*' ) ['appveyor.yml', 'docs', 'LICENSE.md', 'MANIFEST.in', 'mkdocs.yml', 'README.md', 'requirements', 'setup.cfg', 'setup.py', 'tests', 'tox.ini', 'wcmatch'] >>> glob . glob ( '*' , root_dir = 'docs/src' ) ['dictionary', 'markdown'] Additionally, you can use dir_fd and specify a root directory with a directory file descriptor. >>> import os >>> from wcmatch import glob >>> dir_fd = os . open ( 'docs/src' , os . O_RDONLY | os . O_DIRECTORY ) >>> glob . glob ( '*' , dir_fd = dir_fd ) ['markdown', 'dictionary'] Support for Directory Descriptors Directory descriptors may not be supported on all systems. You can check whether or not dir_fd is supported for a your platform referencing the attribute glob . SUPPORT_DIR_FD which will be True if it is supported. Additionally, the os . O_DIRECTORY may not be defined on some systems. You can likely just use os . O_RDONLY . New 5.1 root_dir was added in 5.1.0. New 6.0 limit was added in 6.0. New 8.2 dir_fd parameter was added in 8.2. New 8.4 exclude parameter was added.","title":"glob.glob"},{"location":"glob/#iglob","text":"def iglob ( patterns , * , flags = 0 , root_dir = None , dir_fd = None , limit = 1000 , exclude = None ): iglob is just like glob except it returns an iterator. >>> from wcmatch import glob >>> list ( glob . iglob ( '**/*.md' )) ['docs/src/markdown/_snippets/abbr.md', 'docs/src/markdown/_snippets/links.md', 'docs/src/markdown/_snippets/refs.md', 'docs/src/markdown/changelog.md', 'docs/src/markdown/fnmatch.md', 'docs/src/markdown/glob.md', 'docs/src/markdown/index.md', 'docs/src/markdown/installation.md', 'docs/src/markdown/license.md', 'README.md'] New 5.1 root_dir was added in 5.1.0. New 6.0 limit was added in 6.0. New 8.2 dir_fd parameter was added in 8.2. New 8.4 exclude parameter was added.","title":"glob.iglob"},{"location":"glob/#globmatch","text":"def globmatch ( filename , patterns , * , flags = 0 , root_dir = None , dir_fd = None , limit = 1000 , exclude = None ): globmatch takes a file name (string or path-like object), a pattern (or list of patterns), flags, and an optional root directory and/or file descriptor. It also allows configuring the max pattern limit . Exclusion patterns can be specified via the exclude parameter which takes a pattern or a list of patterns. It will return a boolean indicating whether the file path was matched by the pattern(s). >>> from wcmatch import glob >>> glob . globmatch ( 'some/path/test.txt' , '**/*/@(*.txt|*.py)' , flags = glob . EXTGLOB ) True When applying multiple patterns, a file path matches if it matches any of the patterns: >>> from wcmatch import glob >>> glob . globmatch ( 'some/path/test.txt' , [ '**/*/*.txt' , '**/*/*.py' ]) True Exclusion patterns are allowed as well. When exclusion patterns are used in conjunction with other patterns, a path will be considered matched if one of the positive patterns match and none of the exclusion patterns match. If an exclusion pattern is given without any inclusion patterns, the pattern will match nothing. Exclusion patterns are meant to filter other patterns, not match anything by themselves. >>> from wcmatch import glob >>> glob . globmatch ( 'some/path/test.py' , '**|!**/*.txt' , flags = glob . NEGATE | glob . GLOBSTAR | glob . SPLIT ) True >>> glob . globmatch ( 'some/path/test.txt' , '**|!**/*.txt' , flags = glob . NEGATE | glob . GLOBSTAR | glob . SPLIT ) False >>> glob . globmatch ( 'some/path/test.txt' , [ '*/*/*.txt' , '!*/*/avoid.txt' ], flags = glob . NEGATE ) True >>> glob . globmatch ( 'some/path/avoid.txt' , [ '*/*/*.txt' , '!*/*/avoid.txt' ], flags = glob . NEGATE ) False As mentioned, exclusion patterns need to be applied to a inclusion pattern to work, but if it is desired, you can force exclusion patterns to assume all files should be filtered with the exclusion pattern(s) with the NEGATEALL flag. Essentially, it means if you use a pattern such as !*.md , it means if you use a pattern such as !*.md , it will assume two pattern were given: * and !*.md (where ** is specifically treated as if GLOBSTAR was enabled). >>> from wcmatch import glob >>> glob . globmatch ( 'some/path/test.py' , '!**/*.txt' , flags = glob . NEGATE | glob . GLOBSTAR | glob . NEGATEALL ) True >>> glob . globmatch ( 'some/path/test.txt' , '!**/*.txt' , flags = glob . NEGATE | glob . GLOBSTAR | glob . NEGATEALL ) False By default, globmatch and globfilter do not operate on the file system. This is to allow you to process paths from any source, even paths that are not on your current system. So if you are trying to explicitly match a directory with a pattern such as */ , your path must end with a slash ( my_directory/ ) to be recognized as a directory. It also won't be able to evaluate whether a directory is a symlink or not as it will have no way of checking. Here we see that globmatch fails to match the filepath as the pattern is explicitly looking for a directory and our filepath does not end with / . >>> from wcmatch import glob >>> glob . globmatch ( 'docs' , '*/' ) False If you would like for globmatch (or globfilter ) to operate on your current filesystem directly, simply pass in the REALPATH flag. When enabled, the path under consideration will be analyzed and will use that context to determine if the file exists, if it is a directory, does it's context make sense compared to what the pattern is looking vs the current working directory, or if it has symlinks that should not be matched by GLOBSTAR . Here we use REALPATH and can see that globmatch now knows that doc is a directory. >>> from wcmatch import glob >>> glob . globmatch ( 'docs' , '*/' , flags = glob . REALPATH ) True It also can tell if a file doesn't exist or is out of scope compared to what is being asked. For instance, the below example fails because the pattern is looking for any folder that is relative to the current path, which /usr is not. When we disable REALPATH , it will match just fine. Both cases can be useful depending on how you plan to use globmatch . >>> from wcmatch import glob >>> glob . globmatch ( '/usr' , '**/' , flags = glob . G | glob . REALPATH ) False >>> glob . globmatch ( '/usr' , '**/' , flags = glob . G ) True If you are using REALPATH and want to evaluate the paths relative to a different directory, you can set the root_dir parameter. >>> from wcmatch import glob >>> glob . globmatch ( 'markdown' , 'markdown' , flags = glob . REALPATH ) False >>> glob . globmatch ( 'markdown' , 'markdown' , flags = glob . REALPATH , root_dir = 'docs/src' ) True Additionally, you could also provide a root directory using a file descriptor. >>> import os >>> from wcmatch import glob >>> dir_fd = os . open ( 'docs/src' , os . O_RDONLY | os . O_DIRECTORY ) >>> glob . globmatch ( 'markdown' , 'markdown' , flags = glob . REALPATH ) False >>> glob . globmatch ( 'markdown' , 'markdown' , flags = glob . REALPATH , dir_fd = dir_fd ) True Support for Directory Descriptors Directory descriptors may not be supported on all systems. You can check whether or not dir_fd is supported for a your platform referencing the attribute glob . SUPPORT_DIR_FD which will be True if it is supported. Additionally, the os . O_DIRECTORY may not be defined on some systems. You can likely just use os . O_RDONLY . New 5.1 root_dir was added in 5.1.0. path-like object support for file path inputs was added in 5.1.0 New 6.0 limit was added in 6.0. New 8.2 dir_fd parameter was added in 8.2. New 8.4 exclude parameter was added.","title":"glob.globmatch"},{"location":"glob/#globfilter","text":"def globfilter ( filenames , patterns , * , flags = 0 , root_dir = None , dir_fd = None , limit = 1000 , method = None ): globfilter takes a list of file paths (strings or path-like objects), a pattern (or list of patterns), flags, and an optional root directory and/or directory file descriptor. It also allows configuring the max pattern limit . Exclusion patterns can be specified via the exclude parameter which takes a pattern or a list of patterns.It returns a list of all files paths that matched the pattern(s). The same logic used for globmatch is used for globfilter , albeit more efficient for processing multiple files. Path-like Input Support Path-like object input support is only available in Python 3.6+ as the path-like protocol was added in Python 3.6. >>> from wcmatch import glob >>> glob . globfilter ([ 'some/path/a.txt' , 'b.txt' , 'another/path/c.py' ], '**/*.txt' ) ['some/path/a.txt', 'b.txt'] Like globmatch , globfilter does not operate directly on the file system, with all the caveats associated. But you can enable the REALPATH flag and globfilter will use the filesystem to gain context such as: whether the file exists, whether it is a directory or not, or whether it has symlinks that should not be matched by GLOBSTAR . See globmatch for examples. New 5.1 root_dir was added in 5.1.0. path-like object support for file path inputs was added in 5.1.0 New 6.0 limit was added in 6.0. New 8.2 dir_fd parameter was added in 8.2. New 8.4 exclude parameter was added.","title":"glob.globfilter"},{"location":"glob/#translate","text":"def translate ( patterns , * , flags = 0 , limit = 1000 , exclude = None ): translate takes a file pattern (or list of patterns) and flags. It also allows configuring the max pattern limit . Exclusion patterns can be specified via the exclude parameter which takes a pattern or a list of patterns. It returns two lists: one for inclusion patterns and one for exclusion patterns. The lists contain the regular expressions used for matching the given patterns. It should be noted that a file is considered matched if it matches at least one inclusion pattern and matches none of the exclusion patterns. >>> from wcmatch import glob >>> glob . translate ( '**/*.{py,txt}' ) (['^(?s:(?=[^/])(?!(?:\\\\.{1,2})(?:$|[/]))(?:(?!\\\\.)[^/]*?)?[/]+(?=[^/])(?!(?:\\\\.{1,2})(?:$|[/]))(?:(?!\\\\.)[^/]*?)?\\\\.\\\\{py,txt\\\\}[/]*?)$'], []) >>> glob . translate ( '**|!**/*.{py,txt}' , flags = glob . NEGATE | glob . SPLIT ) (['^(?s:(?=[^/])(?!(?:\\\\.{1,2})(?:$|[/]))(?:(?!\\\\.)[^/]*?)?[/]*?)$'], ['^(?s:(?=[^/])(?!(?:\\\\.{1,2})(?:$|[/]))[^/]*?[/]+(?=[^/])(?!(?:\\\\.{1,2})(?:$|[/]))[^/]*?\\\\.\\\\{py,txt\\\\}[/]*?)$']) When using EXTGLOB patterns, patterns will be returned with capturing groups around the groups: While in regex patterns like r '(a)+' would capture only the last character, even though multiple where matched, we wrap the entire group to be captured: '+(a)' \u2192 r '((a)+)' . >>> from wcmatch import glob >>> import re >>> gpat = glob . translate ( \"@(file)+([[:digit:]])@(.*)\" , flags = glob . EXTGLOB ) >>> pat = re . compile ( gpat [ 0 ][ 0 ]) >>> pat . match ( 'file33.test.txt' ) . groups () ('file', '33', '.test.txt') New 6.0 limit was added in 6.0. New 7.1 Translate patterns now provide capturing groups for EXTGLOB groups. New 8.4 exclude parameter was added.","title":"glob.translate"},{"location":"glob/#escape","text":"def escape ( pattern , unix = None ): The escape function will conservatively escape - , ! , * , ? , ( , ) , [ , ] , | , { , } . and \\ with backslashes, regardless of what feature is or is not enabled. It is meant to escape path parts (filenames, Windows drives, UNC sharepoints) or full paths. >>> from wcmatch import glob >>> glob . escape ( 'some/path?/**file** {} .txt' ) 'some/path\\\\?/\\\\*\\\\*file\\\\*\\\\*\\\\{}.txt' >>> glob . globmatch ( 'some/path?/**file** {} .txt' , glob . escape ( 'some/path?/**file** {} .txt' )) True escape can also handle Windows style paths with / or \\ path separators. It is usually recommended to use / as Windows backslashes are only supported via a special escape, but \\ will be expanded to an escaped backslash (represented in a raw string as r ' \\\\ ' or a normal string as ' \\\\\\\\ ' ). >>> from wmcatch import glob >>> glob . escape ( 'some \\\\ path? \\\\ **file** {} .txt' , unix = False ) 'some\\\\\\\\path\\\\?\\\\\\\\\\\\*\\\\*file\\\\*\\\\*\\\\{\\\\}.txt' >>> glob . globmatch ( 'some \\\\ path? \\\\ **file** {} .txt' , glob . escape ( 'some \\\\ path? \\\\ **file** {} .txt' ), flags = glob . FORCEWIN ) True >>> glob . escape ( 'some/path?/**file** {} .txt' , unix = False ) 'some/path\\\\?/\\\\*\\\\*file\\\\*\\\\*\\\\{\\\\}.txt' >>> glob . globmatch ( 'some \\\\ path? \\\\ **file** {} .txt' , glob . escape ( 'some/path?/**file** {} .txt' ), flags = glob . FORCEWIN ) True On a Windows system, meta characters are not processed in drives or UNC sharepoints except for pattern expansion meta characters. { and } (when using BRACE ) and | (when using SPLIT ) are the only meta characters that can affect drives and UNC sharepoints; therefore, they are the only characters that need to be escaped. escape , when it detects or is informed that it is processing a Windows path, escape will properly find and handle drives and UNC sharepoints. >>> from wmcatch import glob >>> glob . escape ( '//./Volume{b75e2c83-0000-0000-0000-602f00000000}\\Test\\Foo.txt' , unix = False ) '//./Volume\\\\{b75e2c83-0000-0000-0000-602f00000000\\\\}\\\\\\\\Test\\\\\\\\Foo.txt' escape will detect the system it is running on and pick Windows escape logic or Linux/Unix logic. Since globmatch allows you to match Unix style paths on a Windows system and vice versa, you can force Unix style escaping or Windows style escaping via the unix parameter. When unix is None , the escape style will be detected, when unix is True Linux/Unix style escaping will be used, and when unix is False Windows style escaping will be used. >>> glob . escape ( 'some/path?/**file** {} .txt' , unix = True ) New 5.0 The unix parameter is now None by default. Set to True to force Linux/Unix style escaping or set to False to force Windows style escaping. New 7.0 { , } , and | will be escaped in Windows drives. Additionally, users can escape these characters in Windows drives manually in their match patterns as well.","title":"glob.escape"},{"location":"glob/#raw_escape","text":"Deprecated 8.1 In 8.1, raw_escape has been deprecated. The same can be accomplished simply by using codecs and then using the normal escape : >>> string = r \"translate \\\\ raw strings \\\\ \\u00c3\\xc3\\303\\N{LATIN CAPITAL LETTER A WITH TILDE}\" >>> translated = codecs . decode ( string , 'unicode_escape' ) >>> glob . escape ( translated ) 'translate\\\\\\\\raw strings\\\\\\\\\u00c3\u00c3\u00c3\u00c3' >>> glob . raw_escape ( string ) 'translate\\\\\\\\raw strings\\\\\\\\\u00c3\u00c3\u00c3\u00c3' def raw_escape ( pattern , unix = None , raw_chars = True ): raw_escape is kind of a niche function and 99% of the time, it is recommended to use escape . The big difference between raw_escape and escape is how \\ are handled. raw_escape is mainly for paths provided to Python via an interface that doesn't process Python strings like they normally are, for instance an input in a GUI. To illustrate, you may have an interface to input path names, but may want to take advantage of Python Unicode references. Normally, on a python command line, you can do this: >>> 'folder \\\\ El Ni \\u00f1 o' 'folder\\\\El Ni\u00f1o' But when in a GUI interface, if a user inputs the same, it's like getting a raw string. >>> r 'folder \\\\ El Ni\\u00f1o' 'folder\\\\\\\\El Ni\\\\u00f1o' raw_escape will take a raw string in the above format and resolve character escapes and escape the path as if it was a normal string. Notice to do this, we must treat literal Windows' path backslashes as an escaped backslash. >>> glob . escape ( 'folder \\\\ El Ni \\u00f1 o' , unix = False ) 'folder\\\\\\\\El Ni\u00f1o' >>> glob . raw_escape ( r 'folder \\\\ El Ni\\u00f1o' ) 'folder\\\\\\\\El Ni\u00f1o' Handling of raw character references can be turned off if desired: >>> glob . raw_escape ( r 'my \\\\ file-\\x31.txt' , unix = False ) 'my\\\\\\\\file\\\\-1.txt' >>> glob . raw_escape ( r 'my \\\\ file-\\x31.txt' , unix = False , raw_chars = False ) 'my\\\\\\\\file\\\\-\\\\\\\\x31.txt' Outside of the treatment of \\ , raw_escape will function just like escape : raw_escape will detect the system it is running on and pick Windows escape logic or Linux/Unix logic. Since globmatch allows you to match Unix style paths on a Windows system, and vice versa, you can force Unix style escaping or Windows style escaping via the unix parameter. When unix is None , the escape style will be detected, when unix is True Linux/Unix style escaping will be used, and when unix is False Windows style escaping will be used. >>> glob . raw_escape ( r 'some/path?/\\x2a\\x2afile\\x2a\\x2a {} .txt' , unix = True ) New 5.0 The unix parameter is now None by default. Set to True to force Linux/Unix style escaping or set to False to force Windows style escaping. New 7.0 { , } , and | will be escaped in Windows drives. Additionally, users can escape these characters in Windows drives manually in their match patterns as well. raw_chars option was added.","title":"glob.raw_escape"},{"location":"glob/#is_magic","text":"def is_magic ( pattern , * , flags = 0 ): \"\"\"Check if the pattern is likely to be magic.\"\"\" This checks a given path or pattern or to see if \"magic\" symbols are present or not. The check is based on the enabled features via flags . Paths and patterns are expected to be/target full paths, full filenames, full drive names, or full UNC sharepoints. If is_magic is run on a Windows path it will always flag it as \"magic\" unless you convert the directory separators to / as \\ is a \"magic\" symbol. >>> glob . is_magic ( 'test' ) False >>> glob . is_magic ( '[test]ing?' ) True When is_magic is called, the system it is called on is detected automatically and/or inferred from flags such as FORCEUNIX or FORCEWIN . If the pattern is checked against a Windows system, UNC sharepoints will be detected and treated differently. Wildcard Match cannot detect and glob all possible connected sharepoints, so they are treated differently and cannot contain magic except in three cases: The drive or sharepoint is using backslashes as backslashes are treated as magic. BRACE is enabled and either { or } are found in the drive name or UNC sharepoint. SPLIT is enabled and | is found in the drive name or UNC sharepoint. >>> glob . is_magic ( '//?/UNC/server/mount {} /' , flags = glob . FORCEWIN ) False >>> glob . is_magic ( '//?/UNC/server/mount {} /' , flags = glob . FORCEWIN | glob . BRACE ) True The table below illustrates which symbols are searched for based on the given feature. Each feature adds to the \"default\". In the case of NEGATE , if MINUSNEGATE is also enabled, MINUSNEGATE 's symbols will be searched instead of NEGATE 's symbols. Features Symbols Default ?*[]\\ EXTMATCH () BRACE {} NEGATE ! MINUSNEGATE - SPLIT | GLOBTILDE ~ New 8.1 Added is_magic in 8.1.","title":"glob.is_magic"},{"location":"glob/#flags","text":"","title":"Flags"},{"location":"glob/#case","text":"CASE forces case sensitivity. CASE has higher priority than IGNORECASE . On Windows, drive letters ( C: ) and UNC sharepoints ( //host/share ) portions of a path will still be treated case insensitively, but the rest of the path will have case sensitive logic applied.","title":"glob.CASE, glob.C"},{"location":"glob/#ignorecase","text":"IGNORECASE forces case insensitivity. CASE has higher priority than IGNORECASE .","title":"glob.IGNORECASE, glob.I"},{"location":"glob/#rawchars","text":"RAWCHARS causes string character syntax to be parsed in raw strings: r '\\u0040' \u2192 r '@' . This will handle standard string escapes and Unicode including r '\\N{CHAR NAME}' .","title":"glob.RAWCHARS, glob.R"},{"location":"glob/#negate","text":"NEGATE causes patterns that start with ! to be treated as exclusion patterns. A pattern of !*.py exclude any Python files. Exclusion patterns cannot be used by themselves though, and must be paired with a normal, inclusion pattern, either by utilizing the SPLIT flag, or providing multiple patterns in a list. Assuming the SPLIT flag, this means using it in a pattern such as inclusion|!exclusion . If it is desired, you can force exclusion patterns, when no inclusion pattern is provided, to assume all files match unless the file matches the excluded pattern. This is done with the NEGATEALL flag. NEGATE enables DOTGLOB in all exclude patterns, this cannot be disabled. This will not affect the inclusion patterns. If NEGATE is set and exclusion patterns are passed via a matching or glob function's exclude parameter, NEGATE will be ignored and the exclude patterns will be used instead. Either exclude or NEGATE should be used, not both.","title":"glob.NEGATE, glob.N"},{"location":"glob/#negateall","text":"NEGATEALL can force exclusion patterns, when no inclusion pattern is provided, to assume all files match unless the file matches the excluded pattern. Essentially, it means if you use a pattern such as !*.md , it will assume two patterns were given: ** and !*.md , where !*.md is applied to the results of ** , and ** is specifically treated as if GLOBSTAR was enabled. Dot files will not be returned unless DOTGLOB is enabled. Symlinks will also be ignored in the return unless FOLLOW is enabled.","title":"glob.NEGATEALL, glob.A"},{"location":"glob/#minusnegate","text":"When MINUSNEGATE is used with NEGATE , exclusion patterns are recognized by a pattern starting with - instead of ! . This plays nice with the extended glob feature which already uses ! in patterns such as !(...) .","title":"glob.MINUSNEGATE, glob.M"},{"location":"glob/#globstar","text":"GLOBSTAR enables the feature where ** matches zero or more directories.","title":"glob.GLOBSTAR, glob.G"},{"location":"glob/#follow","text":"FOLLOW will cause GLOBSTAR patterns ( ** ) to match and traverse symlink directories.","title":"glob.FOLLOW, glob.L"},{"location":"glob/#realpath","text":"In the past, only glob and iglob operated on the filesystem, but with REALPATH , other functions will now operate on the filesystem as well: globmatch and globfilter . Normally, functions such as globmatch would simply match a path with regular expression and return the result. The functions were not concerned with whether the path existed or not. It didn't care if it was even valid for the operating system. REALPATH forces globmatch and globfilter to treat the string path as a real file path for the given system it is running on. It will augment the patterns used to match files and enable additional logic so that the path must meet the following in order to match: Path must exist. Directories that are symlinks will not be matched by GLOBSTAR patterns ( ** ) unless the FOLLOW flag is enabled. When presented with a pattern where the match must be a directory, but the file path being compared doesn't indicate the file is a directory with a trailing slash, the command will look at the filesystem to determine if it is a directory. Paths must match in relation to the current working directory unless the pattern is constructed in a way to indicates an absolute path. Since REALPATH causes the file system to be referenced when matching a path, flags such as FORCEUNIX and FORCEWIN are not allowed with this flag and will be ignored.","title":"glob.REALPATH, glob.P"},{"location":"glob/#dotglob","text":"By default, glob and globmatch will not match file or directory names that start with dot . unless matched with a literal dot. DOTGLOB allows the meta characters (such as * ) to glob dots like any other character. Dots will not be matched in [] , * , or ? . Alternatively DOTMATCH will also be accepted for consistency with the other provided libraries. Both flags are exactly the same and are provided as a convenience in case the user finds one more intuitive than the other since DOTGLOB is often the name used in Bash.","title":"glob.DOTGLOB, glob.D"},{"location":"glob/#globnodotdir","text":"NOTDOTDIR fundamentally changes how glob patterns deal with . and .. . This is great if you'd prefer a more Zsh feel when it comes to special directory matching. When NODOTDIR is enabled, \"magic\" patterns, such as .* , will not match the special directories of . and .. . In order to match these special directories, you will have to use literal glob patterns of . and .. . This can be used in all glob API functions that accept flags, and will affect inclusion patterns as well as exclusion patterns. >>> from wcmatch import glob >>> glob . globfilter ([ '.' , '..' ], '.*' ) ['.', '..'] >>> glob . globfilter ([ '.' , '..' ], '.*' , flags = glob . NODOTDIR ) [] >>> glob . globfilter ([ '.' , '..' ], '.' , flags = glob . NODOTDIR ) ['.'] >>> glob . globfilter ([ '.' , '..' ], '..' , flags = glob . NODOTDIR ) ['..'] Also affects exclusion patterns: >>> from wcmatch import glob >>> glob . glob ([ '..' , '!.*' ], flags = glob . NEGATE ) [] >>> glob . glob ([ '..' , '!.*' ], flags = glob . NEGATE | glob . NODOTDIR ) ['..'] >>> glob . glob ([ '..' , '!..' ], flags = glob . NEGATE | glob . NODOTDIR ) [] New 7.0 NODOTDIR was added in 7.0.","title":"glob.NODOTDIR, glob.Z"},{"location":"glob/#scandotdir","text":"SCANDOTDIR controls the directory scanning behavior of glob and iglob . The directory scanner of these functions do not return . and .. in their results. This means that unless you use an explicit . or .. in your glob pattern, . and .. will not be returned. When SCANDOTDIR is enabled, . and .. will be returned when a directory is scanned causing \"magic\" patterns, such as .* , to match . and .. . This only controls the directory scanning behavior and not how glob patterns behave. Exclude patterns, which filter the returned results via NEGATE , can still match . and .. with \"magic\" patterns such as .* regardless of whether SCANDOTDIR is enabled or not. It will also have no affect on globmatch . To fundamentally change how glob patterns behave, you can use NODOTDIR . >>> from wcmatch import glob >>> glob . glob ( '.*' ) ['.codecov.yml', '.tox', '.coverage', '.coveragerc', '.gitignore', '.github', '.pyspelling.yml', '.git'] >>> glob . glob ( '.*' , flags = glob . SCANDOTDIR ) ['.', '..', '.codecov.yml', '.tox', '.coverage', '.coveragerc', '.gitignore', '.github', '.pyspelling.yml', '.git'] New 7.0 SCANDOTDIR was added in 7.0.","title":"glob.SCANDOTDIR, glob.SD"},{"location":"glob/#extglob","text":"EXTGLOB enables extended pattern matching which includes special pattern lists such as +(...) , *(...) , ?(...) , etc. Pattern lists allow for multiple patterns within them separated by | . See the globbing syntax overview for more information. Alternatively EXTMATCH will also be accepted for consistency with the other provided libraries. Both flags are exactly the same and are provided as a convenience in case the user finds one more intuitive than the other since EXTGLOB is often the name used in Bash. EXTGLOB and NEGATE When using EXTGLOB and NEGATE together, if a pattern starts with !( , the pattern will not be treated as a NEGATE pattern (even if !( doesn't yield a valid EXTGLOB pattern). To negate a pattern that starts with a literal ( , you must escape the bracket: !\\( .","title":"glob.EXTGLOB, glob.E"},{"location":"glob/#brace","text":"BRACE enables Bash style brace expansion: a{b,{c,d}} \u2192 ab ac ad . Brace expansion is applied before anything else. When applied, a pattern will be expanded into multiple patterns. Each pattern will then be parsed separately. Duplicate patterns will be discarded 1 by default, and glob and iglob will return only unique results. If you need glob or iglob to behave more like Bash and return all results, you can set NOUNIQUE . NOUNIQUE has no effect on matching functions such as globmatch and globfilter . For simple patterns, it may make more sense to use EXTGLOB which will only generate a single pattern which will perform much better: @(ab|ac|ad) . Massive Expansion Risk It is important to note that each pattern is crawled separately, so patterns such as {1..100} would generate one hundred patterns. In a match function ( globmatch ), that would cause a hundred compares, and in a file crawling function ( glob ), it would cause the file system to be crawled one hundred times. Sometimes patterns like this are needed, so construct patterns thoughtfully and carefully. BRACE and SPLIT both expand patterns into multiple patterns. Using these two syntaxes simultaneously can exponential increase duplicate patterns: >>> expand ( 'test@(this{|that,|other})|*.py' , BRACE | SPLIT | EXTMATCH ) ['test@(this|that)', 'test@(this|other)', '*.py', '*.py'] This effect is reduced as redundant, identical patterns are optimized away 1 , but when using crawling functions (like glob ) and NOUNIQUE that optimization is removed, and all of those patterns will be crawled. For this reason, especially when using functions like glob , it is recommended to use one syntax or the other.","title":"glob.BRACE, glob.B"},{"location":"glob/#split","text":"SPLIT is used to take a string of multiple patterns that are delimited by | and split them into separate patterns. This is provided to help with some interfaces that might need a way to define multiple patterns in one input. It pairs really well with EXTGLOB and takes into account sequences ( [] ) and extended patterns ( *(...) ) and will not parse | within them. You can also escape the delimiters if needed: \\| . Duplicate patterns will be discarded 1 by default, and glob and iglob will return only unique results. If you need glob or iglob to behave more like Bash and return all results, you can set NOUNIQUE . NOUNIQUE has no effect on matching functions such as globmatch and globfilter . While SPLIT is not as powerful as BRACE , it's syntax is very easy to use, and when paired with EXTGLOB , it feels natural and comes a bit closer. It is also much harder to create massive expansions of patterns with it, except when paired with BRACE . See BRACE and its warnings related to pairing it with SPLIT . >>> from wcmatch import glob >>> glob . globmatch ( 'test.txt' , '*.txt|*.py' , flags = fnmatch . SPLIT ) True >>> glob . globmatch ( 'test.py' , '*.txt|*.py' , flags = fnmatch . SPLIT ) True","title":"glob.SPLIT, glob.S"},{"location":"glob/#nounique","text":"NOUNIQUE is used to disable Wildcard Match's unique results return. This mimics Bash's output behavior if that is desired. >>> from wcmatch import glob >>> glob . glob ( '{*,README}.md' , flags = glob . BRACE | glob . NOUNIQUE ) ['LICENSE.md', 'README.md', 'README.md'] >>> glob . glob ( '{*,README}.md' , flags = glob . BRACE ) ['LICENSE.md', 'README.md'] By default, only unique paths are returned in glob and iglob . Normally this is what a programmer would want from such a library, so input patterns are reduced to unique patterns 1 to reduce excessive matching with redundant patterns and excessive crawls through the file system. Also, as two different patterns that have been fed into glob may match the same file, the results are also filtered as to not return the duplicates. Unique results is are accomplished by filtering out duplicate patterns and by retaining an internal set of returned files to determine duplicates. The internal set of files is not retained if only a single, inclusive pattern is provided. Exclusive patterns via NEGATE will not trigger the logic. Singular inclusive patterns that use pattern expansions due to BRACE or SPLIT will act as if multiple patterns were provided, and will trigger the duplicate filtering logic. This is mentioned as functions such as iglob , which normally are expected to not retain results in memory, will be forced to retain a set to ensure unique results if multiple inclusive patterns are provided. NOUNIQUE disables all of the aforementioned \"unique\" optimizations, but only for glob and iglob . Functions like globmatch and globfilter would get no benefit from disabling \"unique\" optimizations as they only match what they are given. New in 6.0 \"Unique\" optimizations were added in 6.0, along with NOUNIQUE .","title":"glob.NOUNIQUE, glob.Q"},{"location":"glob/#globtilde","text":"GLOBTILDE allows for user path expansion via ~ . You can get the current user path by using ~ at the start of a path. ~ can be used as the entire pattern, or it must be followed by a directory slash: ~/more-pattern . To specify a specific user, you can explicitly specify a user name via ~user . If additional pattern is needed, the user name must be followed by a directory slash: ~user/more-pattern . >>> from wcmatch import glob >>> glob . glob ( '~' , flags = glob . GLOBTILDE ) ['/home/facelessuser'] >>> glob . glob ( '~root' , flags = glob . GLOBTILDE ) ['/root'] GLOBTILDE can also be used in things like globfilter or globmatch , but you must be using REALPATH or the user path will not be expanded. from wcmatch import glob >>> glob . globmatch ( '/home/facelessuser/' , '~' , flags = glob . GLOBTILDE | glob . REALPATH ) True New 6.0 Tilde expansion with GLOBTILDE was added in version 6.0.","title":"glob.GLOBTILDE, glob.T"},{"location":"glob/#mark","text":"MARK ensures that glob and iglob to return all directories with a trailing slash. This makes it very clear which paths are directories and allows you to save calling os.path.isdir as you can simply check for a path separator at the end of the path. This flag only applies to calls to glob or iglob . If you are passing the returned files from glob to globfilter or globmatch , it is important to ensure directory paths have trailing slashes as these functions have no way of telling the path is a directory otherwise (except when REALPATH is enabled). If you have REALPATH enabled, ensuring the files have trailing slashes can still save you a call to os.path.isdir as REALPATH resorts to calling it if there is no trailing slash. >>> from wcmatch import glob >>> glob . glob ( '*' , flags = glob . MARK ) ['appveyor.yml', 'base.patch', 'basematch.diff', 'docs/', 'LICENSE.md', 'MANIFEST.in', 'mkdocs.yml', 'README.md', 'requirements/', 'setup.cfg', 'setup.py', 'tests/', 'tools/', 'tox.ini', 'wcmatch/'] >>> glob . glob ( '*' ) ['appveyor.yml', 'base.patch', 'basematch.diff', 'docs', 'LICENSE.md', 'MANIFEST.in', 'mkdocs.yml', 'README.md', 'requirements', 'setup.cfg', 'setup.py', 'tests', 'tools', 'tox.ini', 'wcmatch']","title":"glob.MARK, glob.K"},{"location":"glob/#matchbase","text":"MATCHBASE , when a pattern has no slashes in it, will cause glob and iglob to seek for any file anywhere in the tree with a matching basename. When enabled for globfilter and globmatch , any path whose basename matches. MATCHBASE is sensitive to files and directories that start with . and will not match such files and directories if DOTGLOB is not enabled. >>> from wcmatch import glob >>> glob . glob ( '*.txt' , flags = glob . MATCHBASE ) ['docs/src/dictionary/en-custom.txt', 'docs/src/markdown/_snippets/abbr.txt', 'docs/src/markdown/_snippets/links.txt', 'docs/src/markdown/_snippets/posix.txt', 'docs/src/markdown/_snippets/refs.txt', 'requirements/docs.txt', 'requirements/lint.txt', 'requirements/setup.txt', 'requirements/test.txt', 'requirements/tools.txt']","title":"glob.MATCHBASE, glob.X"},{"location":"glob/#nodir","text":"NODIR will cause glob , iglob , globmatch , and globfilter to return only matched files. >>> from wcmatch import glob >>> glob . glob ( '*' , flags = glob . NODIR ) ['appveyor.yml', 'LICENSE.md', 'MANIFEST.in', 'mkdocs.yml', 'README.md', 'setup.cfg', 'setup.py', 'spell.log', 'tox.ini'] >>> glob . glob ( '*' ) ['appveyor.yml', 'docs', 'LICENSE.md', 'MANIFEST.in', 'mkdocs.yml', 'README.md', 'requirements', 'setup.cfg', 'setup.py', 'spell.log', 'tests', 'tools', 'tox.ini', 'wcmatch']","title":"glob.NODIR, glob.O"},{"location":"glob/#forcewin","text":"FORCEWIN will force Windows path and case logic to be used on Linux/Unix systems. It will also cause slashes to be normalized and Windows drive syntax to be handled special. This is great if you need to match Windows specific paths on a Linux/Unix system. This will only work on commands that do not access the file system: translate , globmatch , globfilter , etc. These flags will not work with glob or iglob . It also will not work when using the REALPATH flag with things like globmatch and globfilter . If FORCEWIN is used along side FORCEUNIX , both will be ignored.","title":"glob.FORCEWIN, glob.W"},{"location":"glob/#forceunix","text":"FORCEUNIX will force Linux/Unix path and case logic to be used on Windows systems. This is great if you need to match Linux/Unix specific paths on a Windows system. This will only work on commands that do not access the file system: translate , globmatch , globfilter , etc. These flags will not work with glob or iglob . It also will not work when using the REALPATH flag with things like globmatch and globfilter . When using FORCEUNIX , the paths are assumed to be case sensitive, but you can use IGNORECASE to use case insensitivity. If FORCEUNIX is used along side FORCEWIN , both will be ignored. Identical patterns are only reduced by comparing case sensitively as POSIX character classes are case sensitive: [[:alnum:]] \u2260 [[:ALNUM:]] . \u21a9 \u21a9 \u21a9 \u21a9","title":"glob.FORCEUNIX, glob.U"},{"location":"pathlib/","text":"wcmatch.pathlib from wcmatch import pathlib New 5.0 wcmatch.pathlib was added in wcmatch 5.0. Overview pathlib is a library that contains subclasses of Python's pathlib Path and PurePath classes, and their Posix and Windows subclasses, with the purpose of overriding the default glob behavior with Wildcard Match's very own glob . This allows a user of pathlib to use all of the glob enhancements that Wildcard Match provides. This includes features such as extended glob patterns, brace expansions, and more. This documentation does not mean to exhaustively describe the pathlib library, just the differences introduced by Wildcard Match's implementation. Please check out Python's pathlib documentation to learn more about pathlib in general. Also, to learn more about the underlying glob library being used, check out the documentation for Wildcard Match's glob . Multi-Pattern Limits Many of the API functions allow passing in multiple patterns or using either BRACE or SPLIT to expand a pattern in to more patterns. The number of allowed patterns is limited 1000 , but you can raise or lower this limit via the keyword option limit . If you set limit to 0 , there will be no limit. New 6.0 The imposed pattern limit and corresponding limit option was introduced in 6.0. Differences The API is the same as Python's default pathlib except for the few differences related to file globbing and matching: Each pathlib object's glob , rglob , and match methods are now driven by the wcmatch.glob library. As a result, some of the defaults and accepted parameters are different. Also, many new optional features can be enabled via flags . glob , rglob , and match can take a single string pattern or a list of patterns. They also accept flags via the flags keyword. This matches the interfaces found detailed in our glob documentation. glob , rglob , and match do not enable GLOBSTAR or DOTGLOB by default. These flags must be passed in to take advantage of this functionality. A globmatch function has been added to PurePath classes (and Path classes which are derived from PurePath ) which is like match except without the right to left behavior. See match and globmatch for more information. If file searching methods ( glob and rglob ) are given multiple patterns, they will ensure duplicate results are filtered out. This only occurs when more than one inclusive pattern is given, or a pattern is expanded into multiple, inclusive patterns via BRACE or SPLIT . When this occurs, an internal set is kept to track the results returned so that duplicates can be filtered. This will not occur if only a single, inclusive pattern is given or the NOUNIQUE flag is specified. Python's pathlib has logic to ignore . when used as a directory in both the file path and glob pattern. We do not alter how pathlib stores paths, but our implementation allows explicit use of . as a literal directory and will match accordingly. With that said, since pathlib normalizes paths by removing . directories, in most cases, you won't notice the difference, except when it comes to a path that is literally just . . Python's default glob: >>> import pathlib >>> list ( pathlib . Path ( '.' ) . glob ( 'docs/./src' )) [PosixPath('docs/src')] Ours: >>> form wcmatch import pathlib >>> list ( pathlib . Path ( '.' ) . glob ( 'docs/./src' )) [PosixPath('docs/src')] Python's default glob: >>> import pathlib >>> pathlib . Path ( '.' ) . match ( '.' ) Traceback (most recent call last): File \"<stdin>\" , line 1 , in <module> File \"/usr/local/Cellar/python@3.8/3.8.3/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pathlib.py\" , line 976 , in match raise ValueError ( \"empty pattern\" ) ValueError : empty pattern Ours: >>> from wcmatch import pathlib >>> pathlib . Path ( '.' ) . match ( '.' ) True Similarities glob , rglob , and match should mimic the basic behavior of Python's original pathlib library, just with the enhancements and configurability that Wildcard Match's glob provides. glob and rglob will yield an iterator of the results. rglob will exhibit the same recursive behavior. match will exhibit the same right to left behavior. Classes pathlib.PurePath PurePath is Wildcard Match's version of Python's PurePath class. Depending on the system, it will create either a PureWindowsPath or a PurePosixPath object. Both objects will utilize wcmatch.glob for all glob related actions. PurePath objects do not touch the filesystem. They include the methods match and globmatch (amongst others). You can force the path to access the filesystem if you give either function the REALPATH flag. We do not restrict this, but we do not enable it by default. REALPATH simply forces the match to check the filesystem to see if the file exists and is a directory or not. >>> from wcmatch import pathlib >>> pathlib . PurePath ( 'docs/src' ) PurePosixPath('docs/src') PurePath classes implement the match and globmatch methods: >>> from wcmatch import pathlib >>> p = pathlib . PurePath ( 'docs/src' ) >>> p . match ( 'src' ) True >>> p . globmatch ( '**/src' , flags = pathlib . GLOBSTAR ) True pathlib.PureWindowsPath PureWindowsPath is Wildcard Match's version of Python's PureWindowsPath . The PureWindowsPath class is useful if you'd like to have the ease that pathlib offers when working with a path, but don't want it to access the filesystem. This is also useful if you'd like to manipulate Windows path strings on a Posix system. This class will utilize Wildcard Match's glob for all glob related actions. The class is subclassed from PurePath . >>> from wcmatch import pathlib >>> os . name 'posix' >>> pathlib . PureWindowsPath ( 'c:/some/path' ) PureWindowsPath('c:/some/path') pathlib.PurePosixPath PurePosixPath is Wildcard Match's version of Python's PurePosixPath . The PurePosixPath class is useful if you'd like to have the ease that pathlib offers when working with a path, but don't want it to access the filesystem. This is also useful if you'd like to manipulate Posix path strings on a Windows system. This class will utilize Wildcard Match's glob for all glob related actions. The class is subclassed from PurePath . >>> from wcmatch import pathlib >>> os . name 'nt' >>> pathlib . PureWindowsPath ( '/usr/local/bin' ) PurePosixPath('/usr/local/bin') pathlib.Path Path is Wildcard Match's version of Python's Path class. Depending on the system, it will create either a WindowsPath or a PosixPath object. Both objects will utilize wcmatch.glob for all glob related actions. Path classes are subclassed from the PurePath objects, so you get all the features of the Path class in addition to the PurePath class features. Path objects have access to the filesystem. They include the PurePath methods match and globmatch (amongst others). Since these methods are PurePath methods, they do not touch the filesystem. But, you can force them to access the filesystem if you give either function the REALPATH flag. We do not restrict this, but we do not enable it by default. REALPATH simply forces the match to check the filesystem to see if the file exists and is a directory or not. >>> from wcmatch import pathlib >>> pathlib . PurePath ( 'docs/src' ) PosixPath('docs/src') Path classes implement the glob and globmatch methods: >>> from wcmatch import pathlib >>> p = pathlib . Path ( 'docs/src' ) >>> p . match ( 'src' ) True >>> p . globmatch ( '**/src' , flags = pathlib . GLOBSTAR ) True >>> list ( p . glob ( '**/*.txt' , flags = pathlib . GLOBSTAR )) [PosixPath('docs/src/dictionary/en-custom.txt'), PosixPath('docs/src/markdown/_snippets/links.txt'), PosixPath('docs/src/markdown/_snippets/refs.txt'), PosixPath('docs/src/markdown/_snippets/abbr.txt'), PosixPath('docs/src/markdown/_snippets/posix.txt')] >>> list ( p . rglob ( '*.txt' )) [PosixPath('docs/src/dictionary/en-custom.txt'), PosixPath('docs/src/markdown/_snippets/links.txt'), PosixPath('docs/src/markdown/_snippets/refs.txt'), PosixPath('docs/src/markdown/_snippets/abbr.txt'), PosixPath('docs/src/markdown/_snippets/posix.txt')] pathlib.WindowsPath WindowsPath is Wildcard Match's version of Python's WindowsPath . The WindowsPath class is useful if you'd like to have the ease that pathlib offers when working with a path and be able to manipulate or gain access to to information about that file. You cannot instantiate this class on a Posix system. This class will utilize Wildcard Match's glob for all glob related actions. The class is subclassed from Path . >>> from wcmatch import pathlib >>> os . name 'posix' >>> pathlib . Path ( 'c:/some/path' ) WindowsPath('c:/some/path') pathlib.PosixPath PosixPath is Wildcard Match's version of Python's PosixPath . The PosixPath class is useful if you'd like to have the ease that pathlib offers when working with a path and be able to manipulate or gain access to to information about that file. You cannot instantiate this class on a Windows system. This class will utilize Wildcard Match's glob for all glob related actions. The class is subclassed from Path . >>> from wcmatch import pathlib >>> os . name 'posix' >>> pathlib . Path ( '/usr/local/bin' ) PosixPath('/usr/local/bin') Methods PurePath.match def match ( self , patterns , * , flags = 0 , limit = 1000 , exclude = None ): match takes a pattern (or list of patterns), and flags. It also allows configuring the max pattern limit . Exclusion patterns can be specified via the exclude parameter which takes a pattern or a list of patterns. It will return a boolean indicating whether the object's file path was matched by the pattern(s). match mimics Python's pathlib version of match . Python's match uses a right to left evaluation. Wildcard Match emulates this behavior as well. What this means is that when provided with a path some/path/name , the patterns name , path/name and some/path/name will all match. Because the path is evaluated right to left, dot files may not prevent matches when DOTGLOB is disabled. >>> from wcmatch import pathlib >>> pathlib . PurePath ( '.dotfile/file' ) . match ( 'file' ) True >>> pathlib . PurePath ( '../.dotfile/file' ) . match ( 'file' ) True match does not access the filesystem, but you can force the path to access the filesystem if you give it the REALPATH flag. We do not restrict this, but we do not enable it by default. REALPATH simply forces the match to check the filesystem to see if the file exists and is a directory or not. Since Path is derived from PurePath , this method is also available in Path objects. >>> from wcmatch import pathlib >>> p = pathlib . PurePath ( 'docs/src' ) >>> p . match ( 'src' ) True New 6.0 limit was added in 6.0. New 8.4 exclude parameter was added. PurePath.globmatch def globmatch ( self , patterns , * , flags = 0 , limit = 1000 , exclude = None ): globmatch takes a pattern (or list of patterns), and flags. It also allows configuring the max pattern limit . Exclusion patterns can be specified via the exclude parameter which takes a pattern or a list of patterns. It will return a boolean indicating whether the objects file path was matched by the pattern(s). globmatch is similar to match except it does not use the same recursive logic that match does. In all other respects, it behaves the same. globmatch does not access the filesystem, but you can force the path to access the filesystem if you give it the REALPATH flag. We do not restrict this, but we do not enable it by default. REALPATH simply forces the match to check the filesystem to see if the file exists and is a directory or not. Since Path is derived from PurePath , this method is also available in Path objects. >>> from wcmatch import pathlib >>> p = pathlib . PurePath ( 'docs/src' ) >>> p . globmatch ( '**/src' , flags = pathlib . GLOBSTAR ) True New 6.0 limit was added in 6.0. New 8.4 exclude parameter was added. Path.glob def glob ( self , patterns , * , flags = 0 , limit = 1000 , exclude = None ): glob takes a pattern (or list of patterns) and flags. It also allows configuring the max pattern limit . It will crawl the file system, relative to the current Path object, returning a generator of Path objects. If a file/folder matches any regular, inclusion pattern, it is considered a match. If a file matches any exclusion pattern (specified via exclude or using negation patterns when enabling the NEGATE flag), then it will not be returned. This method calls our own iglob implementation, and as such, should behave in the same manner in respect to features, the one exception being that instead of returning path strings in the generator, it will return Path objects. The one difference between this glob and the iglob API is that this function does not accept the root_dir parameter. All searches are relative to the object's path, which is evaluated relative to the current working directory. >>> from wcmatch import pathlib >>> p = pathlib . Path ( 'docs/src' ) >>> list ( p . glob ( '**/*.txt' , flags = pathlib . GLOBSTAR )) [PosixPath('docs/src/dictionary/en-custom.txt'), PosixPath('docs/src/markdown/_snippets/links.txt'), PosixPath('docs/src/markdown/_snippets/refs.txt'), PosixPath('docs/src/markdown/_snippets/abbr.txt'), PosixPath('docs/src/markdown/_snippets/posix.txt')] New 6.0 limit was added in 6.0. New 8.4 exclude parameter was added. Path.rglob def rglob ( self , patterns , * , flags = 0 , path_limit = 1000 , exclude = None ): rglob takes a pattern (or list of patterns) and flags. It also allows configuring the max pattern limit . It will crawl the file system, relative to the current Path object, returning a generator of Path objects. If a file/folder matches any regular patterns, it is considered a match. If a file matches any exclusion pattern (specified via exclude or using negation patterns when enabling the NEGATE flag), then it will be not be returned. rglob mimics Python's pathlib version of rglob in that it uses a recursive logic. What this means is that when you are matching a path in the form some/path/name , the patterns name , path/name and some/path/name will all match. Essentially, the pattern behaves as if a GLOBSTAR pattern of **/ was added at the beginning of the pattern. rglob is similar to glob except for the use of recursive logic. In all other respects, it behaves the same. >>> from wcmatch import pathlib >>> p = pathlib . Path ( 'docs/src' ) >>> list ( p . rglob ( '*.txt' )) [PosixPath('docs/src/dictionary/en-custom.txt'), PosixPath('docs/src/markdown/_snippets/links.txt'), PosixPath('docs/src/markdown/_snippets/refs.txt'), PosixPath('docs/src/markdown/_snippets/abbr.txt'), PosixPath('docs/src/markdown/_snippets/posix.txt')] New 6.0 limit was added in 6.0. New 8.4 exclude parameter was added. Flags pathlib.CASE, pathlib.C CASE forces case sensitivity. CASE has higher priority than IGNORECASE . On Windows, drive letters ( C: ) and UNC sharepoints ( //host/share ) portions of a path will still be treated case insensitively, but the rest of the path will have case sensitive logic applied. pathlib.IGNORECASE, pathlib.I IGNORECASE forces case insensitivity. CASE has higher priority than IGNORECASE . glob.RAWCHARS, glob.R RAWCHARS causes string character syntax to be parsed in raw strings: r '\\u0040' \u2192 r '@' . This will handle standard string escapes and Unicode including r '\\N{CHAR NAME}' . pathlib.NEGATE, pathlib.N NEGATE causes patterns that start with ! to be treated as exclusion patterns. A pattern of !*.py would exclude any Python files. Exclusion patterns cannot be used by themselves though, and must be paired with a normal, inclusion pattern, either by utilizing the SPLIT flag, or providing multiple patterns in a list. Assuming the SPLIT flag, this means using it in a pattern such as inclusion|!exclusion . If it is desired, you can force exclusion patterns, when no inclusion pattern is provided, to assume all files match unless the file matches the excluded pattern. This is done with the NEGATEALL flag. NEGATE enables DOTGLOB in all exclude patterns, this cannot be disabled. This will not affect the inclusion patterns. If NEGATE is set and exclusion patterns are passed via a matching or glob function's exclude parameter, NEGATE will be ignored and the exclude patterns will be used instead. Either exclude or NEGATE should be used, not both. pathlib.NEGATEALL, pathlib.A NEGATEALL can force exclusion patterns, when no inclusion pattern is provided, to assume all files match unless the file matches the excluded pattern. Essentially, it means if you use a pattern such as !*.md , it will assume two patterns were given: ** and !*.md , where !*.md is applied to the results of ** , and ** is specifically treated as if GLOBSTAR was enabled. Dot files will not be returned unless DOTGLOB is enabled. Symlinks will also be ignored in the return unless FOLLOW is enabled. pathlib.MINUSNEGATE, pathlib.M When MINUSNEGATE is used with NEGATE , exclusion patterns are recognized by a pattern starting with - instead of ! . This plays nice with the extended glob feature which already uses ! in patterns such as !(...) . pathlib.GLOBSTAR, pathlib.G GLOBSTAR enables the feature where ** matches zero or more directories. pathlib.FOLLOW, pathlib.L FOLLOW will cause GLOBSTAR patterns ( ** ) to match and traverse symlink directories. pathlib.REALPATH, pathlib.P In the past, only glob and iglob operated on the filesystem, but with REALPATH , other functions will now operate on the filesystem as well: globmatch and match . Normally, functions such as globmatch would simply match a path with regular expression and return the result. The functions were not concerned with whether the path existed or not. It didn't care if it was even valid for the operating system. REALPATH forces globmatch and match to treat the path as a real file path for the given system it is running on. It will augment the patterns used to match files and enable additional logic so that the path must meet the following in order to match: Path must exist. Directories that are symlinks will not be matched by GLOBSTAR patterns ( ** ) unless the FOLLOW flag is enabled. When presented with a pattern where the match must be a directory, but the file path being compared doesn't indicate the file is a directory with a trailing slash, the command will look at the filesystem to determine if it is a directory. Paths must match in relation to the current working directory unless the pattern is constructed in a way to indicates an absolute path. pathlib.DOTGLOB, pathlib.D By default, globbing and matching functions will not match file or directory names that start with dot . unless matched with a literal dot. DOTGLOB allows the meta characters (such as * ) to glob dots like any other character. Dots will not be matched in [] , * , or ? . Alternatively DOTMATCH will also be accepted for consistency with the other provided libraries. Both flags are exactly the same and are provided as a convenience in case the user finds one more intuitive than the other since DOTGLOB is often the name used in Bash. pathlib.NODOTDIR, glob.Z NOTDOTDIR fundamentally changes how glob patterns deal with . and .. . This is great if you'd prefer a more Zsh feel when it comes to special directory matching. When NODOTDIR is enabled, \"magic\" patterns, such as .* , will not match the special directories of . and .. . In order to match these special directories, you will have to use literal glob patterns of . and .. . This can be used in all glob API functions that accept flags, and will affect inclusion patterns as well as exclusion patterns. >>> from wcmatch import pathlib >>> pathlib . Path ( '..' ) . match ( '.*' ) True >>> pathlib . Path ( '..' ) . match ( '.*' , flags = pathlib . NODOTDIR ) False >>> pathlib . Path ( '..' ) . match ( '..' , flags = pathlib . NODOTDIR ) True Also affects exclusion patterns: >>> from wcmatch import pathlib >>> list ( pathlib . Path ( '.' ) . glob ([ 'docs/..' , '!*/.*' ], flags = pathlib . NEGATE )) [] >>> list ( pathlib . Path ( '.' ) . glob ([ 'docs/..' , '!*/.*' ], flags = pathlib . NEGATE | pathlib . NODOTDIR )) [PosixPath('docs/..')] >>> list ( pathlib . Path ( '.' ) . glob ([ 'docs/..' , '!*/..' ], flags = pathlib . NEGATE | pathlib . NODOTDIR )) [] New 7.0 NODOTDIR was added in 7.0. pathlib.SCANDOTDIR, pathlib.SD Not recommended for pathlib pathlib supports all of the same flags that the wcmatch.glob library does. But due to how pathlib normalizes the paths that get returned, enabling SCANDOTDIR will only give confusing duplicates if using patterns such as .* . This is not a bug, but is something to be aware of. SCANDOTDIR controls the directory scanning behavior of glob and rglob . The directory scanner of these functions do not return . and .. in their results. This means unless you use an explicit . or .. in your glob pattern, . and .. will not be returned. When SCANDOTDIR is enabled, . and .. will be returned when a directory is scanned causing \"magic\" patterns, such as .* , to match . and .. . This only controls the directory scanning behavior and not how glob patterns behave. Exclude patterns, which filter, the returned results via NEGATE , can still match . and .. with \"magic\" patterns such as .* regardless of whether SCANDOTDIR is enabled or not. It will also have no affect on globmatch . To fundamentally change how glob patterns behave, you can use NODOTDIR . >>> from wcmatch import pathlib >>> list ( pathlib . Path ( 'temp' ) . glob ( '**/.*' , flags = glob . GLOBSTAR | glob . DOTGLOB )) [PosixPath('temp/.hidden'), PosixPath('temp/.DS_Store')] >>> list ( pathlib . Path ( 'temp' ) . glob ( '**/.*' , flags = pathlib . GLOBSTAR | pathlib . DOTGLOB | pathlib . SCANDOTDIR )) [PosixPath('temp'), PosixPath('temp/..'), PosixPath('temp/.hidden'), PosixPath('temp/.hidden/..'), PosixPath('temp/.DS_Store')] Notice when we turn off unique result filtering how we get multiple temp/.hidden results. This is due to how pathlib normalizes directories. When comparing the results to a non- pathlib glob, the results make a bit more sense. >>> list ( pathlib . Path ( 'temp' ) . glob ( '**/.*' , flags = pathlib . GLOBSTAR | pathlib . DOTGLOB | pathlib . SCANDOTDIR | pathlib . NOUNIQUE )) [PosixPath('temp'), PosixPath('temp/..'), PosixPath('temp/.hidden'), PosixPath('temp/.hidden'), PosixPath('temp/.hidden/..'), PosixPath('temp/.DS_Store')] >>> list ( glob . glob ( '**/.*' , flags = glob . GLOBSTAR | glob . DOTGLOB | glob . SCANDOTDIR , root_dir = \"temp\" )) ['.', '..', '.hidden', '.hidden/.', '.hidden/..', '.DS_Store'] New 7.0 SCANDOTDIR was added in 7.0. pathlib.EXTGLOB, pathlib.E EXTGLOB enables extended pattern matching which includes special pattern lists such as +(...) , *(...) , ?(...) , etc. Pattern lists allow for multiple patterns within them separated by | . See the globbing syntax overview for more information. Alternatively EXTMATCH will also be accepted for consistency with the other provided libraries. Both flags are exactly the same and are provided as a convenience in case the user finds one more intuitive than the other since EXTGLOB is often the name used in Bash. EXTGLOB and NEGATE When using EXTGLOB and NEGATE together, if a pattern starts with !( , the pattern will not be treated as a NEGATE pattern (even if !( doesn't yield a valid EXTGLOB pattern). To negate a pattern that starts with a literal ( , you must escape the bracket: !\\( . pathlib.BRACE, pathlib.B BRACE enables Bash style brace expansion: a{b,{c,d}} \u2192 ab ac ad . Brace expansion is applied before anything else. When applied, a pattern will be expanded into multiple patterns. Each pattern will then be parsed separately. Duplicate patterns will be discarded 1 by default, and glob and rglob will return only unique results. If you need glob or rglob to behave more like Bash and return all results, you can set NOUNIQUE . NOUNIQUE has no effect on matching functions such as globmatch and match . For simple patterns, it may make more sense to use EXTGLOB which will only generate a single pattern which will perform much better: @(ab|ac|ad) . Massive Expansion Risk It is important to note that each pattern is crawled separately, so patterns such as {1..100} would generate one hundred patterns. In a match function ( globmatch ), that would cause a hundred compares, and in a file crawling function ( glob ), it would cause the file system to be crawled one hundred times. Sometimes patterns like this are needed, so construct patterns thoughtfully and carefully. BRACE and SPLIT both expand patterns into multiple patterns. Using these two syntaxes simultaneously can exponential increase duplicate patterns: >>> expand ( 'test@(this{|that,|other})|*.py' , BRACE | SPLIT | EXTMATCH ) ['test@(this|that)', 'test@(this|other)', '*.py', '*.py'] This effect is reduced as redundant, identical patterns are optimized away 1 , but when using crawling functions (like in glob ) and NOUNIQUE that optimization is removed, and all of those patterns will be crawled. For this reason, especially when using functions like glob , it is recommended to use one syntax or the other. pathlib.SPLIT, pathlib.S SPLIT is used to take a string of multiple patterns that are delimited by | and split them into separate patterns. This is provided to help with some interfaces that might need a way to define multiple patterns in one input. It pairs really well with EXTGLOB and takes into account sequences ( [] ) and extended patterns ( *(...) ) and will not parse | within them. You can also escape the delimiters if needed: \\| . Duplicate patterns will be discarded 1 by default, and glob and rglob will return only unique results. If you need glob or rglob to behave more like Bash and return all results, you can set NOUNIQUE . NOUNIQUE has no effect on matching functions such as globmatch and match . While SPLIT is not as powerful as BRACE , it's syntax is very easy to use, and when paired with EXTGLOB , it feels natural and comes a bit closer. It is also much harder to create massive expansions of patterns with it, except when paired with BRACE . See BRACE and its warnings related to pairing it with SPLIT . >>> from wcmatch import pathlib >>> list ( pathlib . Path ( '.' ) . glob ( 'README.md|LICENSE.md' , flags = pathlib . SPLIT )) [WindowsPath('README.md'), WindowsPath('LICENSE.md')] pathlib.NOUNIQUE, pathlib.Q NOUNIQUE is used to disable Wildcard Match's unique results return. This mimics Bash's output behavior if that is desired. >>> from wcmatch import glob >>> glob . glob ( '{*,README}.md' , flags = glob . BRACE | glob . NOUNIQUE ) ['LICENSE.md', 'README.md', 'README.md'] >>> glob . glob ( '{*,README}.md' , flags = glob . BRACE ) ['LICENSE.md', 'README.md'] By default, only unique paths are returned in glob and rglob . Normally this is what a programmer would want from such a library, so input patterns are reduced to unique patterns 1 to reduce excessive matching with redundant patterns and excessive crawls through the file system. Also, as two different patterns that have been fed into glob may match the same file, the results are also filtered as to not return the duplicates. Unique results are accomplished by filtering out duplicate patterns and by retaining an internal set of returned files to determine duplicates. The internal set of files is not retained if only a single, inclusive pattern is provided. Exclusive patterns via NEGATE will not trigger the logic, but singular inclusive patterns that use pattern expansions due to BRACE or SPLIT will act as if multiple patterns were provided, and will trigger the duplicate filtering logic. Lastly, if SCANDOTDIR is enabled, even singular inclusive patterns will trigger duplicate filtering logic to protect against cases where pathlib will normalize two unique results to be the same path, such as .hidden and .hidden/. which get normalized to .hidden . NOUNIQUE disables all of the aforementioned \"unique\" optimizations, but only for glob and rglob . Functions like globmatch and match would get no benefit from disabling \"unique\" optimizations as they only match what they are given. New in 6.0 \"Unique\" optimizations were added in 6.0, along with NOUNIQUE . pathlib.MATCHBASE, pathlib.X MATCHBASE , when a pattern has no slashes in it, will cause all glob related functions to seek for any file anywhere in the tree with a matching basename, or in the case of match and globmatch , path whose basename matches. MATCHBASE is sensitive to files and directories that start with . and will not match such files and directories if DOTGLOB is not enabled. >>> from wcmatch import pathlib >>> list ( pathlib . Path ( '.' ) . glob ( '*.txt' , flags = pathlib . MATCHBASE )) [WindowsPath('docs/src/dictionary/en-custom.txt'), WindowsPath('docs/src/markdown/_snippets/abbr.txt'), WindowsPath('docs/src/markdown/_snippets/links.txt'), WindowsPath('docs/src/markdown/_snippets/posix.txt'), WindowsPath('docs/src/markdown/_snippets/refs.txt'), WindowsPath('requirements/docs.txt'), WindowsPath('requirements/lint.txt'), WindowsPath('requirements/setup.txt'), WindowsPath('requirements/test.txt'), WindowsPath('requirements/tools.txt'), WindowsPath('site/_snippets/abbr.txt'), WindowsPath('site/_snippets/links.txt'), WindowsPath('site/_snippets/posix.txt'), WindowsPath('site/_snippets/refs.txt')] pathlib.NODIR, pathlib.O NODIR will cause all glob related functions to return only matched files. In the case of PurePath classes, this may not be possible as those classes do not access the file system, nor will they retain trailing slashes. >>> from wcmatch import pathlib >>> list ( pathlib . Path ( '.' ) . glob ( '*' , flags = pathlib . NODIR )) [WindowsPath('appveyor.yml'), WindowsPath('LICENSE.md'), WindowsPath('MANIFEST.in'), WindowsPath('mkdocs.yml'), WindowsPath('README.md'), WindowsPath('setup.cfg'), WindowsPath('setup.py'), WindowsPath('tox.ini')] >>> list ( pathlib . Path ( '.' ) . glob ( '*' )) [WindowsPath('appveyor.yml'), WindowsPath('docs'), WindowsPath('LICENSE.md'), WindowsPath('MANIFEST.in'), WindowsPath('mkdocs.yml'), WindowsPath('README.md'), WindowsPath('requirements'), WindowsPath('setup.cfg'), WindowsPath('setup.py'), WindowsPath('site'), WindowsPath('tests'), WindowsPath('tox.ini'), WindowsPath('wcmatch')] Identical patterns are only reduced by comparing case sensitively as POSIX character classes are case sensitive: [[:alnum:]] \u2260 [[:ALNUM:]] . \u21a9 \u21a9 \u21a9 \u21a9","title":"Usage"},{"location":"pathlib/#wcmatchpathlib","text":"from wcmatch import pathlib New 5.0 wcmatch.pathlib was added in wcmatch 5.0.","title":"wcmatch.pathlib"},{"location":"pathlib/#overview","text":"pathlib is a library that contains subclasses of Python's pathlib Path and PurePath classes, and their Posix and Windows subclasses, with the purpose of overriding the default glob behavior with Wildcard Match's very own glob . This allows a user of pathlib to use all of the glob enhancements that Wildcard Match provides. This includes features such as extended glob patterns, brace expansions, and more. This documentation does not mean to exhaustively describe the pathlib library, just the differences introduced by Wildcard Match's implementation. Please check out Python's pathlib documentation to learn more about pathlib in general. Also, to learn more about the underlying glob library being used, check out the documentation for Wildcard Match's glob .","title":"Overview"},{"location":"pathlib/#multi-pattern-limits","text":"Many of the API functions allow passing in multiple patterns or using either BRACE or SPLIT to expand a pattern in to more patterns. The number of allowed patterns is limited 1000 , but you can raise or lower this limit via the keyword option limit . If you set limit to 0 , there will be no limit. New 6.0 The imposed pattern limit and corresponding limit option was introduced in 6.0.","title":"Multi-Pattern Limits"},{"location":"pathlib/#differences","text":"The API is the same as Python's default pathlib except for the few differences related to file globbing and matching: Each pathlib object's glob , rglob , and match methods are now driven by the wcmatch.glob library. As a result, some of the defaults and accepted parameters are different. Also, many new optional features can be enabled via flags . glob , rglob , and match can take a single string pattern or a list of patterns. They also accept flags via the flags keyword. This matches the interfaces found detailed in our glob documentation. glob , rglob , and match do not enable GLOBSTAR or DOTGLOB by default. These flags must be passed in to take advantage of this functionality. A globmatch function has been added to PurePath classes (and Path classes which are derived from PurePath ) which is like match except without the right to left behavior. See match and globmatch for more information. If file searching methods ( glob and rglob ) are given multiple patterns, they will ensure duplicate results are filtered out. This only occurs when more than one inclusive pattern is given, or a pattern is expanded into multiple, inclusive patterns via BRACE or SPLIT . When this occurs, an internal set is kept to track the results returned so that duplicates can be filtered. This will not occur if only a single, inclusive pattern is given or the NOUNIQUE flag is specified. Python's pathlib has logic to ignore . when used as a directory in both the file path and glob pattern. We do not alter how pathlib stores paths, but our implementation allows explicit use of . as a literal directory and will match accordingly. With that said, since pathlib normalizes paths by removing . directories, in most cases, you won't notice the difference, except when it comes to a path that is literally just . . Python's default glob: >>> import pathlib >>> list ( pathlib . Path ( '.' ) . glob ( 'docs/./src' )) [PosixPath('docs/src')] Ours: >>> form wcmatch import pathlib >>> list ( pathlib . Path ( '.' ) . glob ( 'docs/./src' )) [PosixPath('docs/src')] Python's default glob: >>> import pathlib >>> pathlib . Path ( '.' ) . match ( '.' ) Traceback (most recent call last): File \"<stdin>\" , line 1 , in <module> File \"/usr/local/Cellar/python@3.8/3.8.3/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pathlib.py\" , line 976 , in match raise ValueError ( \"empty pattern\" ) ValueError : empty pattern Ours: >>> from wcmatch import pathlib >>> pathlib . Path ( '.' ) . match ( '.' ) True","title":"Differences"},{"location":"pathlib/#similarities","text":"glob , rglob , and match should mimic the basic behavior of Python's original pathlib library, just with the enhancements and configurability that Wildcard Match's glob provides. glob and rglob will yield an iterator of the results. rglob will exhibit the same recursive behavior. match will exhibit the same right to left behavior.","title":"Similarities"},{"location":"pathlib/#classes","text":"","title":"Classes"},{"location":"pathlib/#purepath","text":"PurePath is Wildcard Match's version of Python's PurePath class. Depending on the system, it will create either a PureWindowsPath or a PurePosixPath object. Both objects will utilize wcmatch.glob for all glob related actions. PurePath objects do not touch the filesystem. They include the methods match and globmatch (amongst others). You can force the path to access the filesystem if you give either function the REALPATH flag. We do not restrict this, but we do not enable it by default. REALPATH simply forces the match to check the filesystem to see if the file exists and is a directory or not. >>> from wcmatch import pathlib >>> pathlib . PurePath ( 'docs/src' ) PurePosixPath('docs/src') PurePath classes implement the match and globmatch methods: >>> from wcmatch import pathlib >>> p = pathlib . PurePath ( 'docs/src' ) >>> p . match ( 'src' ) True >>> p . globmatch ( '**/src' , flags = pathlib . GLOBSTAR ) True","title":"pathlib.PurePath"},{"location":"pathlib/#purewindowspath","text":"PureWindowsPath is Wildcard Match's version of Python's PureWindowsPath . The PureWindowsPath class is useful if you'd like to have the ease that pathlib offers when working with a path, but don't want it to access the filesystem. This is also useful if you'd like to manipulate Windows path strings on a Posix system. This class will utilize Wildcard Match's glob for all glob related actions. The class is subclassed from PurePath . >>> from wcmatch import pathlib >>> os . name 'posix' >>> pathlib . PureWindowsPath ( 'c:/some/path' ) PureWindowsPath('c:/some/path')","title":"pathlib.PureWindowsPath"},{"location":"pathlib/#pureposixpath","text":"PurePosixPath is Wildcard Match's version of Python's PurePosixPath . The PurePosixPath class is useful if you'd like to have the ease that pathlib offers when working with a path, but don't want it to access the filesystem. This is also useful if you'd like to manipulate Posix path strings on a Windows system. This class will utilize Wildcard Match's glob for all glob related actions. The class is subclassed from PurePath . >>> from wcmatch import pathlib >>> os . name 'nt' >>> pathlib . PureWindowsPath ( '/usr/local/bin' ) PurePosixPath('/usr/local/bin')","title":"pathlib.PurePosixPath"},{"location":"pathlib/#path","text":"Path is Wildcard Match's version of Python's Path class. Depending on the system, it will create either a WindowsPath or a PosixPath object. Both objects will utilize wcmatch.glob for all glob related actions. Path classes are subclassed from the PurePath objects, so you get all the features of the Path class in addition to the PurePath class features. Path objects have access to the filesystem. They include the PurePath methods match and globmatch (amongst others). Since these methods are PurePath methods, they do not touch the filesystem. But, you can force them to access the filesystem if you give either function the REALPATH flag. We do not restrict this, but we do not enable it by default. REALPATH simply forces the match to check the filesystem to see if the file exists and is a directory or not. >>> from wcmatch import pathlib >>> pathlib . PurePath ( 'docs/src' ) PosixPath('docs/src') Path classes implement the glob and globmatch methods: >>> from wcmatch import pathlib >>> p = pathlib . Path ( 'docs/src' ) >>> p . match ( 'src' ) True >>> p . globmatch ( '**/src' , flags = pathlib . GLOBSTAR ) True >>> list ( p . glob ( '**/*.txt' , flags = pathlib . GLOBSTAR )) [PosixPath('docs/src/dictionary/en-custom.txt'), PosixPath('docs/src/markdown/_snippets/links.txt'), PosixPath('docs/src/markdown/_snippets/refs.txt'), PosixPath('docs/src/markdown/_snippets/abbr.txt'), PosixPath('docs/src/markdown/_snippets/posix.txt')] >>> list ( p . rglob ( '*.txt' )) [PosixPath('docs/src/dictionary/en-custom.txt'), PosixPath('docs/src/markdown/_snippets/links.txt'), PosixPath('docs/src/markdown/_snippets/refs.txt'), PosixPath('docs/src/markdown/_snippets/abbr.txt'), PosixPath('docs/src/markdown/_snippets/posix.txt')]","title":"pathlib.Path"},{"location":"pathlib/#windowspath","text":"WindowsPath is Wildcard Match's version of Python's WindowsPath . The WindowsPath class is useful if you'd like to have the ease that pathlib offers when working with a path and be able to manipulate or gain access to to information about that file. You cannot instantiate this class on a Posix system. This class will utilize Wildcard Match's glob for all glob related actions. The class is subclassed from Path . >>> from wcmatch import pathlib >>> os . name 'posix' >>> pathlib . Path ( 'c:/some/path' ) WindowsPath('c:/some/path')","title":"pathlib.WindowsPath"},{"location":"pathlib/#posixpath","text":"PosixPath is Wildcard Match's version of Python's PosixPath . The PosixPath class is useful if you'd like to have the ease that pathlib offers when working with a path and be able to manipulate or gain access to to information about that file. You cannot instantiate this class on a Windows system. This class will utilize Wildcard Match's glob for all glob related actions. The class is subclassed from Path . >>> from wcmatch import pathlib >>> os . name 'posix' >>> pathlib . Path ( '/usr/local/bin' ) PosixPath('/usr/local/bin')","title":"pathlib.PosixPath"},{"location":"pathlib/#methods","text":"","title":"Methods"},{"location":"pathlib/#match","text":"def match ( self , patterns , * , flags = 0 , limit = 1000 , exclude = None ): match takes a pattern (or list of patterns), and flags. It also allows configuring the max pattern limit . Exclusion patterns can be specified via the exclude parameter which takes a pattern or a list of patterns. It will return a boolean indicating whether the object's file path was matched by the pattern(s). match mimics Python's pathlib version of match . Python's match uses a right to left evaluation. Wildcard Match emulates this behavior as well. What this means is that when provided with a path some/path/name , the patterns name , path/name and some/path/name will all match. Because the path is evaluated right to left, dot files may not prevent matches when DOTGLOB is disabled. >>> from wcmatch import pathlib >>> pathlib . PurePath ( '.dotfile/file' ) . match ( 'file' ) True >>> pathlib . PurePath ( '../.dotfile/file' ) . match ( 'file' ) True match does not access the filesystem, but you can force the path to access the filesystem if you give it the REALPATH flag. We do not restrict this, but we do not enable it by default. REALPATH simply forces the match to check the filesystem to see if the file exists and is a directory or not. Since Path is derived from PurePath , this method is also available in Path objects. >>> from wcmatch import pathlib >>> p = pathlib . PurePath ( 'docs/src' ) >>> p . match ( 'src' ) True New 6.0 limit was added in 6.0. New 8.4 exclude parameter was added.","title":"PurePath.match"},{"location":"pathlib/#globmatch","text":"def globmatch ( self , patterns , * , flags = 0 , limit = 1000 , exclude = None ): globmatch takes a pattern (or list of patterns), and flags. It also allows configuring the max pattern limit . Exclusion patterns can be specified via the exclude parameter which takes a pattern or a list of patterns. It will return a boolean indicating whether the objects file path was matched by the pattern(s). globmatch is similar to match except it does not use the same recursive logic that match does. In all other respects, it behaves the same. globmatch does not access the filesystem, but you can force the path to access the filesystem if you give it the REALPATH flag. We do not restrict this, but we do not enable it by default. REALPATH simply forces the match to check the filesystem to see if the file exists and is a directory or not. Since Path is derived from PurePath , this method is also available in Path objects. >>> from wcmatch import pathlib >>> p = pathlib . PurePath ( 'docs/src' ) >>> p . globmatch ( '**/src' , flags = pathlib . GLOBSTAR ) True New 6.0 limit was added in 6.0. New 8.4 exclude parameter was added.","title":"PurePath.globmatch"},{"location":"pathlib/#glob","text":"def glob ( self , patterns , * , flags = 0 , limit = 1000 , exclude = None ): glob takes a pattern (or list of patterns) and flags. It also allows configuring the max pattern limit . It will crawl the file system, relative to the current Path object, returning a generator of Path objects. If a file/folder matches any regular, inclusion pattern, it is considered a match. If a file matches any exclusion pattern (specified via exclude or using negation patterns when enabling the NEGATE flag), then it will not be returned. This method calls our own iglob implementation, and as such, should behave in the same manner in respect to features, the one exception being that instead of returning path strings in the generator, it will return Path objects. The one difference between this glob and the iglob API is that this function does not accept the root_dir parameter. All searches are relative to the object's path, which is evaluated relative to the current working directory. >>> from wcmatch import pathlib >>> p = pathlib . Path ( 'docs/src' ) >>> list ( p . glob ( '**/*.txt' , flags = pathlib . GLOBSTAR )) [PosixPath('docs/src/dictionary/en-custom.txt'), PosixPath('docs/src/markdown/_snippets/links.txt'), PosixPath('docs/src/markdown/_snippets/refs.txt'), PosixPath('docs/src/markdown/_snippets/abbr.txt'), PosixPath('docs/src/markdown/_snippets/posix.txt')] New 6.0 limit was added in 6.0. New 8.4 exclude parameter was added.","title":"Path.glob"},{"location":"pathlib/#rglob","text":"def rglob ( self , patterns , * , flags = 0 , path_limit = 1000 , exclude = None ): rglob takes a pattern (or list of patterns) and flags. It also allows configuring the max pattern limit . It will crawl the file system, relative to the current Path object, returning a generator of Path objects. If a file/folder matches any regular patterns, it is considered a match. If a file matches any exclusion pattern (specified via exclude or using negation patterns when enabling the NEGATE flag), then it will be not be returned. rglob mimics Python's pathlib version of rglob in that it uses a recursive logic. What this means is that when you are matching a path in the form some/path/name , the patterns name , path/name and some/path/name will all match. Essentially, the pattern behaves as if a GLOBSTAR pattern of **/ was added at the beginning of the pattern. rglob is similar to glob except for the use of recursive logic. In all other respects, it behaves the same. >>> from wcmatch import pathlib >>> p = pathlib . Path ( 'docs/src' ) >>> list ( p . rglob ( '*.txt' )) [PosixPath('docs/src/dictionary/en-custom.txt'), PosixPath('docs/src/markdown/_snippets/links.txt'), PosixPath('docs/src/markdown/_snippets/refs.txt'), PosixPath('docs/src/markdown/_snippets/abbr.txt'), PosixPath('docs/src/markdown/_snippets/posix.txt')] New 6.0 limit was added in 6.0. New 8.4 exclude parameter was added.","title":"Path.rglob"},{"location":"pathlib/#flags","text":"","title":"Flags"},{"location":"pathlib/#case","text":"CASE forces case sensitivity. CASE has higher priority than IGNORECASE . On Windows, drive letters ( C: ) and UNC sharepoints ( //host/share ) portions of a path will still be treated case insensitively, but the rest of the path will have case sensitive logic applied.","title":"pathlib.CASE, pathlib.C"},{"location":"pathlib/#ignorecase","text":"IGNORECASE forces case insensitivity. CASE has higher priority than IGNORECASE .","title":"pathlib.IGNORECASE, pathlib.I"},{"location":"pathlib/#rawchars","text":"RAWCHARS causes string character syntax to be parsed in raw strings: r '\\u0040' \u2192 r '@' . This will handle standard string escapes and Unicode including r '\\N{CHAR NAME}' .","title":"glob.RAWCHARS, glob.R"},{"location":"pathlib/#negate","text":"NEGATE causes patterns that start with ! to be treated as exclusion patterns. A pattern of !*.py would exclude any Python files. Exclusion patterns cannot be used by themselves though, and must be paired with a normal, inclusion pattern, either by utilizing the SPLIT flag, or providing multiple patterns in a list. Assuming the SPLIT flag, this means using it in a pattern such as inclusion|!exclusion . If it is desired, you can force exclusion patterns, when no inclusion pattern is provided, to assume all files match unless the file matches the excluded pattern. This is done with the NEGATEALL flag. NEGATE enables DOTGLOB in all exclude patterns, this cannot be disabled. This will not affect the inclusion patterns. If NEGATE is set and exclusion patterns are passed via a matching or glob function's exclude parameter, NEGATE will be ignored and the exclude patterns will be used instead. Either exclude or NEGATE should be used, not both.","title":"pathlib.NEGATE, pathlib.N"},{"location":"pathlib/#negateall","text":"NEGATEALL can force exclusion patterns, when no inclusion pattern is provided, to assume all files match unless the file matches the excluded pattern. Essentially, it means if you use a pattern such as !*.md , it will assume two patterns were given: ** and !*.md , where !*.md is applied to the results of ** , and ** is specifically treated as if GLOBSTAR was enabled. Dot files will not be returned unless DOTGLOB is enabled. Symlinks will also be ignored in the return unless FOLLOW is enabled.","title":"pathlib.NEGATEALL, pathlib.A"},{"location":"pathlib/#minusnegate","text":"When MINUSNEGATE is used with NEGATE , exclusion patterns are recognized by a pattern starting with - instead of ! . This plays nice with the extended glob feature which already uses ! in patterns such as !(...) .","title":"pathlib.MINUSNEGATE, pathlib.M"},{"location":"pathlib/#globstar","text":"GLOBSTAR enables the feature where ** matches zero or more directories.","title":"pathlib.GLOBSTAR, pathlib.G"},{"location":"pathlib/#follow","text":"FOLLOW will cause GLOBSTAR patterns ( ** ) to match and traverse symlink directories.","title":"pathlib.FOLLOW, pathlib.L"},{"location":"pathlib/#realpath","text":"In the past, only glob and iglob operated on the filesystem, but with REALPATH , other functions will now operate on the filesystem as well: globmatch and match . Normally, functions such as globmatch would simply match a path with regular expression and return the result. The functions were not concerned with whether the path existed or not. It didn't care if it was even valid for the operating system. REALPATH forces globmatch and match to treat the path as a real file path for the given system it is running on. It will augment the patterns used to match files and enable additional logic so that the path must meet the following in order to match: Path must exist. Directories that are symlinks will not be matched by GLOBSTAR patterns ( ** ) unless the FOLLOW flag is enabled. When presented with a pattern where the match must be a directory, but the file path being compared doesn't indicate the file is a directory with a trailing slash, the command will look at the filesystem to determine if it is a directory. Paths must match in relation to the current working directory unless the pattern is constructed in a way to indicates an absolute path.","title":"pathlib.REALPATH, pathlib.P"},{"location":"pathlib/#dotglob","text":"By default, globbing and matching functions will not match file or directory names that start with dot . unless matched with a literal dot. DOTGLOB allows the meta characters (such as * ) to glob dots like any other character. Dots will not be matched in [] , * , or ? . Alternatively DOTMATCH will also be accepted for consistency with the other provided libraries. Both flags are exactly the same and are provided as a convenience in case the user finds one more intuitive than the other since DOTGLOB is often the name used in Bash.","title":"pathlib.DOTGLOB, pathlib.D"},{"location":"pathlib/#nodotdir","text":"NOTDOTDIR fundamentally changes how glob patterns deal with . and .. . This is great if you'd prefer a more Zsh feel when it comes to special directory matching. When NODOTDIR is enabled, \"magic\" patterns, such as .* , will not match the special directories of . and .. . In order to match these special directories, you will have to use literal glob patterns of . and .. . This can be used in all glob API functions that accept flags, and will affect inclusion patterns as well as exclusion patterns. >>> from wcmatch import pathlib >>> pathlib . Path ( '..' ) . match ( '.*' ) True >>> pathlib . Path ( '..' ) . match ( '.*' , flags = pathlib . NODOTDIR ) False >>> pathlib . Path ( '..' ) . match ( '..' , flags = pathlib . NODOTDIR ) True Also affects exclusion patterns: >>> from wcmatch import pathlib >>> list ( pathlib . Path ( '.' ) . glob ([ 'docs/..' , '!*/.*' ], flags = pathlib . NEGATE )) [] >>> list ( pathlib . Path ( '.' ) . glob ([ 'docs/..' , '!*/.*' ], flags = pathlib . NEGATE | pathlib . NODOTDIR )) [PosixPath('docs/..')] >>> list ( pathlib . Path ( '.' ) . glob ([ 'docs/..' , '!*/..' ], flags = pathlib . NEGATE | pathlib . NODOTDIR )) [] New 7.0 NODOTDIR was added in 7.0.","title":"pathlib.NODOTDIR, glob.Z"},{"location":"pathlib/#scandotdir","text":"Not recommended for pathlib pathlib supports all of the same flags that the wcmatch.glob library does. But due to how pathlib normalizes the paths that get returned, enabling SCANDOTDIR will only give confusing duplicates if using patterns such as .* . This is not a bug, but is something to be aware of. SCANDOTDIR controls the directory scanning behavior of glob and rglob . The directory scanner of these functions do not return . and .. in their results. This means unless you use an explicit . or .. in your glob pattern, . and .. will not be returned. When SCANDOTDIR is enabled, . and .. will be returned when a directory is scanned causing \"magic\" patterns, such as .* , to match . and .. . This only controls the directory scanning behavior and not how glob patterns behave. Exclude patterns, which filter, the returned results via NEGATE , can still match . and .. with \"magic\" patterns such as .* regardless of whether SCANDOTDIR is enabled or not. It will also have no affect on globmatch . To fundamentally change how glob patterns behave, you can use NODOTDIR . >>> from wcmatch import pathlib >>> list ( pathlib . Path ( 'temp' ) . glob ( '**/.*' , flags = glob . GLOBSTAR | glob . DOTGLOB )) [PosixPath('temp/.hidden'), PosixPath('temp/.DS_Store')] >>> list ( pathlib . Path ( 'temp' ) . glob ( '**/.*' , flags = pathlib . GLOBSTAR | pathlib . DOTGLOB | pathlib . SCANDOTDIR )) [PosixPath('temp'), PosixPath('temp/..'), PosixPath('temp/.hidden'), PosixPath('temp/.hidden/..'), PosixPath('temp/.DS_Store')] Notice when we turn off unique result filtering how we get multiple temp/.hidden results. This is due to how pathlib normalizes directories. When comparing the results to a non- pathlib glob, the results make a bit more sense. >>> list ( pathlib . Path ( 'temp' ) . glob ( '**/.*' , flags = pathlib . GLOBSTAR | pathlib . DOTGLOB | pathlib . SCANDOTDIR | pathlib . NOUNIQUE )) [PosixPath('temp'), PosixPath('temp/..'), PosixPath('temp/.hidden'), PosixPath('temp/.hidden'), PosixPath('temp/.hidden/..'), PosixPath('temp/.DS_Store')] >>> list ( glob . glob ( '**/.*' , flags = glob . GLOBSTAR | glob . DOTGLOB | glob . SCANDOTDIR , root_dir = \"temp\" )) ['.', '..', '.hidden', '.hidden/.', '.hidden/..', '.DS_Store'] New 7.0 SCANDOTDIR was added in 7.0.","title":"pathlib.SCANDOTDIR, pathlib.SD"},{"location":"pathlib/#extglob","text":"EXTGLOB enables extended pattern matching which includes special pattern lists such as +(...) , *(...) , ?(...) , etc. Pattern lists allow for multiple patterns within them separated by | . See the globbing syntax overview for more information. Alternatively EXTMATCH will also be accepted for consistency with the other provided libraries. Both flags are exactly the same and are provided as a convenience in case the user finds one more intuitive than the other since EXTGLOB is often the name used in Bash. EXTGLOB and NEGATE When using EXTGLOB and NEGATE together, if a pattern starts with !( , the pattern will not be treated as a NEGATE pattern (even if !( doesn't yield a valid EXTGLOB pattern). To negate a pattern that starts with a literal ( , you must escape the bracket: !\\( .","title":"pathlib.EXTGLOB, pathlib.E"},{"location":"pathlib/#brace","text":"BRACE enables Bash style brace expansion: a{b,{c,d}} \u2192 ab ac ad . Brace expansion is applied before anything else. When applied, a pattern will be expanded into multiple patterns. Each pattern will then be parsed separately. Duplicate patterns will be discarded 1 by default, and glob and rglob will return only unique results. If you need glob or rglob to behave more like Bash and return all results, you can set NOUNIQUE . NOUNIQUE has no effect on matching functions such as globmatch and match . For simple patterns, it may make more sense to use EXTGLOB which will only generate a single pattern which will perform much better: @(ab|ac|ad) . Massive Expansion Risk It is important to note that each pattern is crawled separately, so patterns such as {1..100} would generate one hundred patterns. In a match function ( globmatch ), that would cause a hundred compares, and in a file crawling function ( glob ), it would cause the file system to be crawled one hundred times. Sometimes patterns like this are needed, so construct patterns thoughtfully and carefully. BRACE and SPLIT both expand patterns into multiple patterns. Using these two syntaxes simultaneously can exponential increase duplicate patterns: >>> expand ( 'test@(this{|that,|other})|*.py' , BRACE | SPLIT | EXTMATCH ) ['test@(this|that)', 'test@(this|other)', '*.py', '*.py'] This effect is reduced as redundant, identical patterns are optimized away 1 , but when using crawling functions (like in glob ) and NOUNIQUE that optimization is removed, and all of those patterns will be crawled. For this reason, especially when using functions like glob , it is recommended to use one syntax or the other.","title":"pathlib.BRACE, pathlib.B"},{"location":"pathlib/#split","text":"SPLIT is used to take a string of multiple patterns that are delimited by | and split them into separate patterns. This is provided to help with some interfaces that might need a way to define multiple patterns in one input. It pairs really well with EXTGLOB and takes into account sequences ( [] ) and extended patterns ( *(...) ) and will not parse | within them. You can also escape the delimiters if needed: \\| . Duplicate patterns will be discarded 1 by default, and glob and rglob will return only unique results. If you need glob or rglob to behave more like Bash and return all results, you can set NOUNIQUE . NOUNIQUE has no effect on matching functions such as globmatch and match . While SPLIT is not as powerful as BRACE , it's syntax is very easy to use, and when paired with EXTGLOB , it feels natural and comes a bit closer. It is also much harder to create massive expansions of patterns with it, except when paired with BRACE . See BRACE and its warnings related to pairing it with SPLIT . >>> from wcmatch import pathlib >>> list ( pathlib . Path ( '.' ) . glob ( 'README.md|LICENSE.md' , flags = pathlib . SPLIT )) [WindowsPath('README.md'), WindowsPath('LICENSE.md')]","title":"pathlib.SPLIT, pathlib.S"},{"location":"pathlib/#nounique","text":"NOUNIQUE is used to disable Wildcard Match's unique results return. This mimics Bash's output behavior if that is desired. >>> from wcmatch import glob >>> glob . glob ( '{*,README}.md' , flags = glob . BRACE | glob . NOUNIQUE ) ['LICENSE.md', 'README.md', 'README.md'] >>> glob . glob ( '{*,README}.md' , flags = glob . BRACE ) ['LICENSE.md', 'README.md'] By default, only unique paths are returned in glob and rglob . Normally this is what a programmer would want from such a library, so input patterns are reduced to unique patterns 1 to reduce excessive matching with redundant patterns and excessive crawls through the file system. Also, as two different patterns that have been fed into glob may match the same file, the results are also filtered as to not return the duplicates. Unique results are accomplished by filtering out duplicate patterns and by retaining an internal set of returned files to determine duplicates. The internal set of files is not retained if only a single, inclusive pattern is provided. Exclusive patterns via NEGATE will not trigger the logic, but singular inclusive patterns that use pattern expansions due to BRACE or SPLIT will act as if multiple patterns were provided, and will trigger the duplicate filtering logic. Lastly, if SCANDOTDIR is enabled, even singular inclusive patterns will trigger duplicate filtering logic to protect against cases where pathlib will normalize two unique results to be the same path, such as .hidden and .hidden/. which get normalized to .hidden . NOUNIQUE disables all of the aforementioned \"unique\" optimizations, but only for glob and rglob . Functions like globmatch and match would get no benefit from disabling \"unique\" optimizations as they only match what they are given. New in 6.0 \"Unique\" optimizations were added in 6.0, along with NOUNIQUE .","title":"pathlib.NOUNIQUE, pathlib.Q"},{"location":"pathlib/#matchbase","text":"MATCHBASE , when a pattern has no slashes in it, will cause all glob related functions to seek for any file anywhere in the tree with a matching basename, or in the case of match and globmatch , path whose basename matches. MATCHBASE is sensitive to files and directories that start with . and will not match such files and directories if DOTGLOB is not enabled. >>> from wcmatch import pathlib >>> list ( pathlib . Path ( '.' ) . glob ( '*.txt' , flags = pathlib . MATCHBASE )) [WindowsPath('docs/src/dictionary/en-custom.txt'), WindowsPath('docs/src/markdown/_snippets/abbr.txt'), WindowsPath('docs/src/markdown/_snippets/links.txt'), WindowsPath('docs/src/markdown/_snippets/posix.txt'), WindowsPath('docs/src/markdown/_snippets/refs.txt'), WindowsPath('requirements/docs.txt'), WindowsPath('requirements/lint.txt'), WindowsPath('requirements/setup.txt'), WindowsPath('requirements/test.txt'), WindowsPath('requirements/tools.txt'), WindowsPath('site/_snippets/abbr.txt'), WindowsPath('site/_snippets/links.txt'), WindowsPath('site/_snippets/posix.txt'), WindowsPath('site/_snippets/refs.txt')]","title":"pathlib.MATCHBASE, pathlib.X"},{"location":"pathlib/#nodir","text":"NODIR will cause all glob related functions to return only matched files. In the case of PurePath classes, this may not be possible as those classes do not access the file system, nor will they retain trailing slashes. >>> from wcmatch import pathlib >>> list ( pathlib . Path ( '.' ) . glob ( '*' , flags = pathlib . NODIR )) [WindowsPath('appveyor.yml'), WindowsPath('LICENSE.md'), WindowsPath('MANIFEST.in'), WindowsPath('mkdocs.yml'), WindowsPath('README.md'), WindowsPath('setup.cfg'), WindowsPath('setup.py'), WindowsPath('tox.ini')] >>> list ( pathlib . Path ( '.' ) . glob ( '*' )) [WindowsPath('appveyor.yml'), WindowsPath('docs'), WindowsPath('LICENSE.md'), WindowsPath('MANIFEST.in'), WindowsPath('mkdocs.yml'), WindowsPath('README.md'), WindowsPath('requirements'), WindowsPath('setup.cfg'), WindowsPath('setup.py'), WindowsPath('site'), WindowsPath('tests'), WindowsPath('tox.ini'), WindowsPath('wcmatch')] Identical patterns are only reduced by comparing case sensitively as POSIX character classes are case sensitive: [[:alnum:]] \u2260 [[:ALNUM:]] . \u21a9 \u21a9 \u21a9 \u21a9","title":"pathlib.NODIR, pathlib.O"},{"location":"wcmatch/","text":"wcmatch.wcmatch from wcmatch import wcmatch Overview wcmatch.WcMatch was originally written to provide a simple user interface for searching specific files in Rummage . A class was needed to facilitate a user interface where a user could select a root directory, define one or more file patterns they wanted to search for, and provide folders to exclude if needed. It needed to be aware of hidden files on different systems, not just ignoring files that start with . . It also needed to be extendable so we could further filter returned files by size, creation date, or whatever else was decided. While glob is a fantastic file and folder search tool, it just didn't make sense for such a user interface. wcmatch.WcMatch class WcMatch : \"\"\"Finds files by wildcard.\"\"\" def __init__ ( self , root_dir = \".\" , file_pattern = None , ** kwargs ): \"\"\"Initialize the directory walker object.\"\"\" WcMatch is an extendable file search class. It allows you to specify a root directory path, file patterns, and optional folder exclude patterns. You can specify whether you want to see hidden files and whether the search should be recursive. You can also derive from the class and tap into specific hooks to change what is returned or done when a file is matched, skipped, or when there is an error. There are also hooks where you can inject additional, custom filtering. Parameter Default Description root_dir The root directory to search. file_pattern '' One or more patterns separated by | . You can define exceptions by starting a pattern with ! (or - if MINUSNEGATE is set). The default is an empty string, but if an empty string is used, all files will be matched. exclude_pattern '' Zero or more folder exclude patterns separated by | . You can define exceptions by starting a pattern with ! (or - if MINUSNEGATE is set). flags 0 Flags to alter behavior of folder and file matching. See Flags for more info. limit 1000 Allows configuring the max pattern limit . Note Dots are not treated special in wcmatch . When the HIDDEN flag is not included, all hidden files (system and dot files) are excluded from the crawling processes, so there is no risk of * matching a dot file as it will not show up in the crawl. If the HIDDEN flag is included, * , ? , and [.] will then match dot files. New 6.0 limit was added in 6.0. Multi-Pattern Limits The WcMatch class allow expanding a pattern into multiple patterns by using | and by using BRACE . The number of allowed patterns is limited 1000 , but you can raise or lower this limit via the keyword option limit . If you set limit to 0 , there will be no limit. New 6.0 The imposed pattern limit and corresponding limit option was introduced in 6.0. Examples Searching for files: >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt' ) . match () ['./LICENSE.md', './README.md'] Recursively searching for files: >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt' , flags = wcmatch . RECURSIVE ) . match () ['./LICENSE.md', './README.md', './docs/src/markdown/changelog.md', './docs/src/markdown/fnmatch.md', './docs/src/markdown/glob.md', './docs/src/markdown/index.md', './docs/src/markdown/installation.md', './docs/src/markdown/license.md', './docs/src/markdown/wcmatch.md', './docs/src/markdown/_snippets/abbr.md', './docs/src/markdown/_snippets/links.md', './docs/src/markdown/_snippets/refs.md', './requirements/docs.txt', './requirements/lint.txt', './requirements/setup.txt', './requirements/test.txt'] Excluding directories: >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt' , exclude_pattern = 'docs' , flags = wcmatch . RECURSIVE ) . match () ['./LICENSE.md', './README.md', './requirements/docs.txt', './requirements/lint.txt', './requirements/setup.txt', './requirements/test.txt'] Using file negation patterns: >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt|!README*' , exclude_pattern = 'docs' , flags = wcmatch . RECURSIVE ) . match () ['./LICENSE.md', './requirements/docs.txt', './requirements/lint.txt', './requirements/setup.txt', './requirements/test.txt'] You can also use negation patterns in directory exclude. Here we avoid all folders with * , but add an exception for requirements . It should be noted that you cannot add an exception for the child of an excluded folder. >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt' , exclude_pattern = '*|!requirements' , flags = wcmatch . RECURSIVE ) . match () ['./LICENSE.md', './README.md', './requirements/docs.txt', './requirements/lint.txt', './requirements/setup.txt', './requirements/test.txt'] Negative patterns can be given by themselves. >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt' , exclude_pattern = '!requirements' , flags = wcmatch . RECURSIVE ) . match () ['./LICENSE.md', './README.md', './requirements/docs.txt', './requirements/lint.txt', './requirements/setup.txt', './requirements/test.txt'] Enabling hidden files: >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.yml' ) . match () ['./appveyor.yml', './mkdocs.yml'] >>> wcmatch . WcMatch ( '.' , '*.yml' , flags = wcmatch . HIDDEN ) . match () ['./.codecov.yml', './.travis.yml', './appveyor.yml', './mkdocs.yml'] Methods WcMatch.match Perform match returning files that match the patterns. >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt' ) . match () ['./LICENSE.md', './README.md'] WcMatch.imatch Perform match returning an iterator of files that match the patterns. >>> from wcmatch import wcmatch >>> list ( wcmatch . WcMatch ( '.' , '*.md|*.txt' ) . imatch ()) ['./LICENSE.md', './README.md'] WcMatch.kill If searching with imatch , this provides a way to gracefully kill the internal searching. Internally, you can call is_aborted to check if a request to abort has been made. So if work on a file is being done in an on_match , you can check if there has been a request to kill the process, and tie up loose ends gracefully. >>> from wcmatch import wcmatch >>> wcm = wcmatch . WcMatch ( '.' , '*.md|*.txt' ) >>> for f in wcm . imatch (): ... print ( f ) ... wcm . kill () ... ./LICENSE.md Once a \"kill\" has been issued, the class will remain in an aborted state. To clear the \"kill\" state, you must call reset . This allows a process to define a Wcmatch class and reuse it. If a process receives an early kill and sets it before the match is started, when the match is started, it will immediately abort. This helps with race conditions depending on how you are using WcMatch . WcMatch.reset Resets the abort state after running kill . >>> from wcmatch import wcmatch >>> wcm = wcmatch . WcMatch ( '.' , '*.md|*.txt' ) >>> for f in wcm . imatch (): ... print ( f ) ... wcm . kill () ... ./LICENSE.md >>> wcm . reset () >>> list ( wcm . imatch ()) ['./LICENSE.md', './README.md'] WcMatch.is_aborted Checks if an abort has been issued. >>> from wcmatch import wcmatch >>> wcm = wcmatch . WcMatch ( '.' , '*.md|*.txt' ) >>> for f in wcm . imatch (): ... wcm . kill () ... >>> wcm . is_aborted () True WcMatch.get_skipped Returns the number of skipped files. Files in skipped folders are not included in the count. >>> from wcmatch import wcmatch >>> wcm = wcmatch . WcMatch ( '.' , '*.md|*.txt' ) >>> list ( wcm . imatch ()) ['./LICENSE.md', './README.md'] >>> wcm . get_skipped () 10 Hooks WcMatch.on_init def on_init ( self , ** kwargs ): \"\"\"Handle custom init.\"\"\" Any keyword arguments not processed by the main initializer are sent to on_init . This allows you to specify additional arguments when deriving from WcMatch . Changed 8.0 Starting in 8.0, on_init only accepts keyword arguments as now WcMatch requires all parameters (except root_dir and file_pattern ) to be keyword parameters and must explicitly be specified in the form key=value . WcMatch.on_validate_directory def on_validate_directory ( self , base , name ): \"\"\"Validate folder override.\"\"\" return True When validating a directory, if the directory passes validation, it will be sent to on_validate_directory which can be overridden to provide additional validation if required. WcMatch.on_validate_file def on_validate_file ( self , base , name ): \"\"\"Validate file override.\"\"\" return True When validating a file, if the file passes validation, it will be sent to on_validate_file which can be overridden to provide additional validation if required. WcMatch.on_skip def on_skip ( self , base , name ): \"\"\"On skip.\"\"\" return None When a file that must be skipped is encountered (a file that doesn't pass validation), it is sent to on_skip . Here you could abort the search, store away information, or even create a special skip record to return. It is advised to create a special type for skip returns so that you can identify them when they are returned via match or imatch . WcMatch.on_error def on_error ( self , base , name ): \"\"\"On error.\"\"\" return None When accessing or processing a file throws an error, it is sent to on_error . Here you could abort the search, store away information, or even create a special error record to return. It is advised to create a special type for error returns so that you can identify them when they are returned via match or imatch . WcMatch.on_match def on_match ( self , base , name ): \"\"\"On match.\"\"\" return os . path . join ( base , name ) On match returns the path of the matched file. You can override on_match and change what is returned. You could return just the base, you could parse the file and return the content, or return a special match record with additional file meta data. on_match must return something, and all results will be returned via match or imatch . WcMatch.on_reset def on_reset ( self ): \"\"\"On reset.\"\"\" pass on_reset is a hook to provide a way to reset any custom logic in classes that have derived from WcMatch . on_reset is called on every new match call. Flags wcmatch.RECURSIVE, wcmatch.RV RECURSIVE forces a recursive search that will crawl all subdirectories. wcmatch.HIDDEN, wcmatch.HD HIDDEN enables the crawling of hidden directories and will return hidden files if the wildcard pattern matches. This enables not just dot files, but system hidden files as well. wcmatch.SYMLINK, wcmatch.SL SYMLINK enables the crawling of symlink directories. By default, symlink directories are ignored during the file crawl. wcmatch.CASE, wcmatch.C CASE forces case sensitivity. CASE has higher priority than IGNORECASE . wcmatch.IGNORECASE, wcmatch.I IGNORECASE forces case insensitive searches. CASE has higher priority than IGNORECASE . wcmatch.RAWCHARS, wcmatch.R RAWCHARS causes string character syntax to be parsed in raw strings: r '\\u0040' \u2192 r '@' . This will handle standard string escapes and Unicode (including r '\\N{CHAR NAME}' ). wcmatch.EXTMATCH, wcmatch.E EXTMATCH enables extended pattern matching which includes special pattern lists such as +(...) , *(...) , ?(...) , etc. EXTMATCH and NEGATE When using EXTMATCH and NEGATE together, if a pattern starts with !( , the pattern will not be treated as a NEGATE pattern (even if !( doesn't yield a valid EXTMATCH pattern). To negate a pattern that starts with a literal ( , you must escape the bracket: !\\( . wcmatch.BRACE, wcmatch.B BRACE enables Bash style brace expansion: a{b,{c,d}} \u2192 ab ac ad . Brace expansion is applied before anything else. When applied, a pattern will be expanded into multiple patterns. Each pattern will then be parsed separately. Redundant, identical patterns are discarded 1 by default. For simple patterns, it may make more sense to use EXTMATCH which will only generate a single pattern which will perform much better: @(ab|ac|ad) . Massive Expansion Risk It is important to note that each pattern is matched separately, so patterns such as {1..100} would generate one hundred patterns. Since WcMatch class is able to crawl the file system one pass accounting for all the patterns, the performance isn't as bad as it may be with glob , but it can still impact performance as each file must get compared against many patterns until one is matched. Sometimes patterns like this are needed, so construct patterns thoughtfully and carefully. Splitting patterns with | is built into WcMatch . BRACE and and splitting with | both expand patterns into multiple patterns. Using these two syntaxes simultaneously can exponential increase in duplicate patterns: >>> expand ( 'test@(this{|that,|other})|*.py' , BRACE | SPLIT | EXTMATCH ) ['test@(this|that)', 'test@(this|other)', '*.py', '*.py'] This effect is reduced as redundant, identical patterns are optimized away 1 . But it is useful to know if trying to construct efficient patterns. wcmatch.MINUSNEGATE, wcmatch.M MINUSNEGATE requires negation patterns to use - instead of ! . wcmatch.DIRPATHNAME, wcmatch.DP DIRPATHNAME will enable path name searching for excluded folder patterns, but it will not apply to file patterns. This is mainly provided for cases where you may have multiple folders with the same name, but you want to target a specific folder to exclude. The path name compared will be the entire path relative to the root directory. So if the provided root directory folder was . , and the folder under evaluation is ./some/folder , some/folder will be matched against the pattern. >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt' , 'docs/src/markdown' , flags = wcmatch . DIRPATHNAME | wcmatch . RECURSIVE ) . match () ['./LICENSE.md', './README.md', './requirements/docs.txt', './requirements/lint.txt', './requirements/setup.txt', './requirements/test.txt'] wcmatch.FILEPATHNAME, wcmatch.FP FILEPATHNAME will enable path name searching for the file patterns, but it will not apply to directory exclude patterns. The path name compared will be the entire path relative to the root directory path. So if the provided root directory was . , and the file under evaluation is ./some/file.txt , some/file.txt will be matched against the pattern. >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '**/*.md|!**/_snippets/*' , flags = wcmatch . FILEPATHNAME | wcmatch . GLOBSTAR | wcmatch . RECURSIVE ) . match () ['./LICENSE.md', './README.md', './docs/src/markdown/changelog.md', './docs/src/markdown/fnmatch.md', './docs/src/markdown/glob.md', './docs/src/markdown/index.md', './docs/src/markdown/license.md', './docs/src/markdown/wcmatch.md'] wcmatch.PATHNAME, wcmatch.P PATHNAME enables both DIRPATHNAME and FILEPATHNAME . It is provided for convenience. wcmatch.MATCHBASE, wcmatch.X When FILEPATHNAME or DIRPATHNAME is enabled, MATCHBASE will ensure that that the respective file or directory pattern, when there are no slashes in the pattern, seeks for any file anywhere in the tree with a matching basename. This is essentially the behavior when FILEPATHNAME and DIRPATHNAME is disabled, but with MATCHBASE , you can toggle the behavior by including slashes in your pattern. When we include no slashes: >>> wcmatch . WcMatch ( '.' , '*.md' , flags = wcmatch . FILEPATHNAME | wcmatch . GLOBSTAR | wcmatch . MATCHBASE | wcmatch . RECURSIVE ) . match () ['./LICENSE.md', './README.md', './docs/src/markdown/changelog.md', './docs/src/markdown/fnmatch.md', './docs/src/markdown/glob.md', './docs/src/markdown/index.md', './docs/src/markdown/license.md', './docs/src/markdown/wcmatch.md'] If we include slashes in the pattern, the path, not the basename, must match the pattern: >>> wcmatch . WcMatch ( '.' , 'docs/**/*.md' , flags = wcmatch . FILEPATHNAME | wcmatch . GLOBSTAR | wcmatch . MATCHBASE | wcmatch . RECURSIVE ) . match () ['./docs/src/markdown/changelog.md', './docs/src/markdown/fnmatch.md', './docs/src/markdown/glob.md', './docs/src/markdown/index.md', './docs/src/markdown/license.md', './docs/src/markdown/wcmatch.md'] If we have a leading slash, the pattern will not perform a match on the basename, but will instead be a normal path pattern that is anchored to the current base path, in this case . . >>> wcmatch . WcMatch ( '.' , '/*.md' , flags = wcmatch . FILEPATHNAME | wcmatch . GLOBSTAR | wcmatch . MATCHBASE | wcmatch . RECURSIVE ) . match () ['./LICENSE.md', './README.md'] wcmatch.GLOBSTAR, wcmatch.G When the PATHNAME flag is provided, you can also enable GLOBSTAR to enable the recursive directory pattern matches with ** . >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt' , '**/markdown' , flags = wcmatch . DIRPATHNAME | wcmatch . GLOBSTAR | wcmatch . RECURSIVE ) . match () ['./LICENSE.md', './README.md', './requirements/docs.txt', './requirements/lint.txt', './requirements/setup.txt', './requirements/test.txt'] Identical patterns are only reduced by comparing case sensitively as POSIX character classes are case sensitive: [[:alnum:]] \u2260 [[:ALNUM:]] . \u21a9 \u21a9","title":"Usage"},{"location":"wcmatch/#wcmatchwcmatch","text":"from wcmatch import wcmatch","title":"wcmatch.wcmatch"},{"location":"wcmatch/#overview","text":"wcmatch.WcMatch was originally written to provide a simple user interface for searching specific files in Rummage . A class was needed to facilitate a user interface where a user could select a root directory, define one or more file patterns they wanted to search for, and provide folders to exclude if needed. It needed to be aware of hidden files on different systems, not just ignoring files that start with . . It also needed to be extendable so we could further filter returned files by size, creation date, or whatever else was decided. While glob is a fantastic file and folder search tool, it just didn't make sense for such a user interface.","title":"Overview"},{"location":"wcmatch/#wcmatch","text":"class WcMatch : \"\"\"Finds files by wildcard.\"\"\" def __init__ ( self , root_dir = \".\" , file_pattern = None , ** kwargs ): \"\"\"Initialize the directory walker object.\"\"\" WcMatch is an extendable file search class. It allows you to specify a root directory path, file patterns, and optional folder exclude patterns. You can specify whether you want to see hidden files and whether the search should be recursive. You can also derive from the class and tap into specific hooks to change what is returned or done when a file is matched, skipped, or when there is an error. There are also hooks where you can inject additional, custom filtering. Parameter Default Description root_dir The root directory to search. file_pattern '' One or more patterns separated by | . You can define exceptions by starting a pattern with ! (or - if MINUSNEGATE is set). The default is an empty string, but if an empty string is used, all files will be matched. exclude_pattern '' Zero or more folder exclude patterns separated by | . You can define exceptions by starting a pattern with ! (or - if MINUSNEGATE is set). flags 0 Flags to alter behavior of folder and file matching. See Flags for more info. limit 1000 Allows configuring the max pattern limit . Note Dots are not treated special in wcmatch . When the HIDDEN flag is not included, all hidden files (system and dot files) are excluded from the crawling processes, so there is no risk of * matching a dot file as it will not show up in the crawl. If the HIDDEN flag is included, * , ? , and [.] will then match dot files. New 6.0 limit was added in 6.0.","title":"wcmatch.WcMatch"},{"location":"wcmatch/#multi-pattern-limits","text":"The WcMatch class allow expanding a pattern into multiple patterns by using | and by using BRACE . The number of allowed patterns is limited 1000 , but you can raise or lower this limit via the keyword option limit . If you set limit to 0 , there will be no limit. New 6.0 The imposed pattern limit and corresponding limit option was introduced in 6.0.","title":"Multi-Pattern Limits"},{"location":"wcmatch/#examples","text":"Searching for files: >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt' ) . match () ['./LICENSE.md', './README.md'] Recursively searching for files: >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt' , flags = wcmatch . RECURSIVE ) . match () ['./LICENSE.md', './README.md', './docs/src/markdown/changelog.md', './docs/src/markdown/fnmatch.md', './docs/src/markdown/glob.md', './docs/src/markdown/index.md', './docs/src/markdown/installation.md', './docs/src/markdown/license.md', './docs/src/markdown/wcmatch.md', './docs/src/markdown/_snippets/abbr.md', './docs/src/markdown/_snippets/links.md', './docs/src/markdown/_snippets/refs.md', './requirements/docs.txt', './requirements/lint.txt', './requirements/setup.txt', './requirements/test.txt'] Excluding directories: >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt' , exclude_pattern = 'docs' , flags = wcmatch . RECURSIVE ) . match () ['./LICENSE.md', './README.md', './requirements/docs.txt', './requirements/lint.txt', './requirements/setup.txt', './requirements/test.txt'] Using file negation patterns: >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt|!README*' , exclude_pattern = 'docs' , flags = wcmatch . RECURSIVE ) . match () ['./LICENSE.md', './requirements/docs.txt', './requirements/lint.txt', './requirements/setup.txt', './requirements/test.txt'] You can also use negation patterns in directory exclude. Here we avoid all folders with * , but add an exception for requirements . It should be noted that you cannot add an exception for the child of an excluded folder. >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt' , exclude_pattern = '*|!requirements' , flags = wcmatch . RECURSIVE ) . match () ['./LICENSE.md', './README.md', './requirements/docs.txt', './requirements/lint.txt', './requirements/setup.txt', './requirements/test.txt'] Negative patterns can be given by themselves. >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt' , exclude_pattern = '!requirements' , flags = wcmatch . RECURSIVE ) . match () ['./LICENSE.md', './README.md', './requirements/docs.txt', './requirements/lint.txt', './requirements/setup.txt', './requirements/test.txt'] Enabling hidden files: >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.yml' ) . match () ['./appveyor.yml', './mkdocs.yml'] >>> wcmatch . WcMatch ( '.' , '*.yml' , flags = wcmatch . HIDDEN ) . match () ['./.codecov.yml', './.travis.yml', './appveyor.yml', './mkdocs.yml']","title":"Examples"},{"location":"wcmatch/#methods","text":"","title":"Methods"},{"location":"wcmatch/#match","text":"Perform match returning files that match the patterns. >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt' ) . match () ['./LICENSE.md', './README.md']","title":"WcMatch.match"},{"location":"wcmatch/#imatch","text":"Perform match returning an iterator of files that match the patterns. >>> from wcmatch import wcmatch >>> list ( wcmatch . WcMatch ( '.' , '*.md|*.txt' ) . imatch ()) ['./LICENSE.md', './README.md']","title":"WcMatch.imatch"},{"location":"wcmatch/#kill","text":"If searching with imatch , this provides a way to gracefully kill the internal searching. Internally, you can call is_aborted to check if a request to abort has been made. So if work on a file is being done in an on_match , you can check if there has been a request to kill the process, and tie up loose ends gracefully. >>> from wcmatch import wcmatch >>> wcm = wcmatch . WcMatch ( '.' , '*.md|*.txt' ) >>> for f in wcm . imatch (): ... print ( f ) ... wcm . kill () ... ./LICENSE.md Once a \"kill\" has been issued, the class will remain in an aborted state. To clear the \"kill\" state, you must call reset . This allows a process to define a Wcmatch class and reuse it. If a process receives an early kill and sets it before the match is started, when the match is started, it will immediately abort. This helps with race conditions depending on how you are using WcMatch .","title":"WcMatch.kill"},{"location":"wcmatch/#reset","text":"Resets the abort state after running kill . >>> from wcmatch import wcmatch >>> wcm = wcmatch . WcMatch ( '.' , '*.md|*.txt' ) >>> for f in wcm . imatch (): ... print ( f ) ... wcm . kill () ... ./LICENSE.md >>> wcm . reset () >>> list ( wcm . imatch ()) ['./LICENSE.md', './README.md']","title":"WcMatch.reset"},{"location":"wcmatch/#is_aborted","text":"Checks if an abort has been issued. >>> from wcmatch import wcmatch >>> wcm = wcmatch . WcMatch ( '.' , '*.md|*.txt' ) >>> for f in wcm . imatch (): ... wcm . kill () ... >>> wcm . is_aborted () True","title":"WcMatch.is_aborted"},{"location":"wcmatch/#get_skipped","text":"Returns the number of skipped files. Files in skipped folders are not included in the count. >>> from wcmatch import wcmatch >>> wcm = wcmatch . WcMatch ( '.' , '*.md|*.txt' ) >>> list ( wcm . imatch ()) ['./LICENSE.md', './README.md'] >>> wcm . get_skipped () 10","title":"WcMatch.get_skipped"},{"location":"wcmatch/#hooks","text":"","title":"Hooks"},{"location":"wcmatch/#on_init","text":"def on_init ( self , ** kwargs ): \"\"\"Handle custom init.\"\"\" Any keyword arguments not processed by the main initializer are sent to on_init . This allows you to specify additional arguments when deriving from WcMatch . Changed 8.0 Starting in 8.0, on_init only accepts keyword arguments as now WcMatch requires all parameters (except root_dir and file_pattern ) to be keyword parameters and must explicitly be specified in the form key=value .","title":"WcMatch.on_init"},{"location":"wcmatch/#on_validate_directory","text":"def on_validate_directory ( self , base , name ): \"\"\"Validate folder override.\"\"\" return True When validating a directory, if the directory passes validation, it will be sent to on_validate_directory which can be overridden to provide additional validation if required.","title":"WcMatch.on_validate_directory"},{"location":"wcmatch/#on_validate_file","text":"def on_validate_file ( self , base , name ): \"\"\"Validate file override.\"\"\" return True When validating a file, if the file passes validation, it will be sent to on_validate_file which can be overridden to provide additional validation if required.","title":"WcMatch.on_validate_file"},{"location":"wcmatch/#on_skip","text":"def on_skip ( self , base , name ): \"\"\"On skip.\"\"\" return None When a file that must be skipped is encountered (a file that doesn't pass validation), it is sent to on_skip . Here you could abort the search, store away information, or even create a special skip record to return. It is advised to create a special type for skip returns so that you can identify them when they are returned via match or imatch .","title":"WcMatch.on_skip"},{"location":"wcmatch/#on_error","text":"def on_error ( self , base , name ): \"\"\"On error.\"\"\" return None When accessing or processing a file throws an error, it is sent to on_error . Here you could abort the search, store away information, or even create a special error record to return. It is advised to create a special type for error returns so that you can identify them when they are returned via match or imatch .","title":"WcMatch.on_error"},{"location":"wcmatch/#on_match","text":"def on_match ( self , base , name ): \"\"\"On match.\"\"\" return os . path . join ( base , name ) On match returns the path of the matched file. You can override on_match and change what is returned. You could return just the base, you could parse the file and return the content, or return a special match record with additional file meta data. on_match must return something, and all results will be returned via match or imatch .","title":"WcMatch.on_match"},{"location":"wcmatch/#on_reset","text":"def on_reset ( self ): \"\"\"On reset.\"\"\" pass on_reset is a hook to provide a way to reset any custom logic in classes that have derived from WcMatch . on_reset is called on every new match call.","title":"WcMatch.on_reset"},{"location":"wcmatch/#flags","text":"","title":"Flags"},{"location":"wcmatch/#recursive","text":"RECURSIVE forces a recursive search that will crawl all subdirectories.","title":"wcmatch.RECURSIVE, wcmatch.RV"},{"location":"wcmatch/#hidden","text":"HIDDEN enables the crawling of hidden directories and will return hidden files if the wildcard pattern matches. This enables not just dot files, but system hidden files as well.","title":"wcmatch.HIDDEN, wcmatch.HD"},{"location":"wcmatch/#symlink","text":"SYMLINK enables the crawling of symlink directories. By default, symlink directories are ignored during the file crawl.","title":"wcmatch.SYMLINK, wcmatch.SL"},{"location":"wcmatch/#case","text":"CASE forces case sensitivity. CASE has higher priority than IGNORECASE .","title":"wcmatch.CASE, wcmatch.C"},{"location":"wcmatch/#ignorecase","text":"IGNORECASE forces case insensitive searches. CASE has higher priority than IGNORECASE .","title":"wcmatch.IGNORECASE, wcmatch.I"},{"location":"wcmatch/#rawchars","text":"RAWCHARS causes string character syntax to be parsed in raw strings: r '\\u0040' \u2192 r '@' . This will handle standard string escapes and Unicode (including r '\\N{CHAR NAME}' ).","title":"wcmatch.RAWCHARS, wcmatch.R"},{"location":"wcmatch/#extmatch","text":"EXTMATCH enables extended pattern matching which includes special pattern lists such as +(...) , *(...) , ?(...) , etc. EXTMATCH and NEGATE When using EXTMATCH and NEGATE together, if a pattern starts with !( , the pattern will not be treated as a NEGATE pattern (even if !( doesn't yield a valid EXTMATCH pattern). To negate a pattern that starts with a literal ( , you must escape the bracket: !\\( .","title":"wcmatch.EXTMATCH, wcmatch.E"},{"location":"wcmatch/#brace","text":"BRACE enables Bash style brace expansion: a{b,{c,d}} \u2192 ab ac ad . Brace expansion is applied before anything else. When applied, a pattern will be expanded into multiple patterns. Each pattern will then be parsed separately. Redundant, identical patterns are discarded 1 by default. For simple patterns, it may make more sense to use EXTMATCH which will only generate a single pattern which will perform much better: @(ab|ac|ad) . Massive Expansion Risk It is important to note that each pattern is matched separately, so patterns such as {1..100} would generate one hundred patterns. Since WcMatch class is able to crawl the file system one pass accounting for all the patterns, the performance isn't as bad as it may be with glob , but it can still impact performance as each file must get compared against many patterns until one is matched. Sometimes patterns like this are needed, so construct patterns thoughtfully and carefully. Splitting patterns with | is built into WcMatch . BRACE and and splitting with | both expand patterns into multiple patterns. Using these two syntaxes simultaneously can exponential increase in duplicate patterns: >>> expand ( 'test@(this{|that,|other})|*.py' , BRACE | SPLIT | EXTMATCH ) ['test@(this|that)', 'test@(this|other)', '*.py', '*.py'] This effect is reduced as redundant, identical patterns are optimized away 1 . But it is useful to know if trying to construct efficient patterns.","title":"wcmatch.BRACE, wcmatch.B"},{"location":"wcmatch/#minusnegate","text":"MINUSNEGATE requires negation patterns to use - instead of ! .","title":"wcmatch.MINUSNEGATE, wcmatch.M"},{"location":"wcmatch/#dirpathname","text":"DIRPATHNAME will enable path name searching for excluded folder patterns, but it will not apply to file patterns. This is mainly provided for cases where you may have multiple folders with the same name, but you want to target a specific folder to exclude. The path name compared will be the entire path relative to the root directory. So if the provided root directory folder was . , and the folder under evaluation is ./some/folder , some/folder will be matched against the pattern. >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt' , 'docs/src/markdown' , flags = wcmatch . DIRPATHNAME | wcmatch . RECURSIVE ) . match () ['./LICENSE.md', './README.md', './requirements/docs.txt', './requirements/lint.txt', './requirements/setup.txt', './requirements/test.txt']","title":"wcmatch.DIRPATHNAME, wcmatch.DP"},{"location":"wcmatch/#filepathname","text":"FILEPATHNAME will enable path name searching for the file patterns, but it will not apply to directory exclude patterns. The path name compared will be the entire path relative to the root directory path. So if the provided root directory was . , and the file under evaluation is ./some/file.txt , some/file.txt will be matched against the pattern. >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '**/*.md|!**/_snippets/*' , flags = wcmatch . FILEPATHNAME | wcmatch . GLOBSTAR | wcmatch . RECURSIVE ) . match () ['./LICENSE.md', './README.md', './docs/src/markdown/changelog.md', './docs/src/markdown/fnmatch.md', './docs/src/markdown/glob.md', './docs/src/markdown/index.md', './docs/src/markdown/license.md', './docs/src/markdown/wcmatch.md']","title":"wcmatch.FILEPATHNAME, wcmatch.FP"},{"location":"wcmatch/#pathname","text":"PATHNAME enables both DIRPATHNAME and FILEPATHNAME . It is provided for convenience.","title":"wcmatch.PATHNAME, wcmatch.P"},{"location":"wcmatch/#matchbase","text":"When FILEPATHNAME or DIRPATHNAME is enabled, MATCHBASE will ensure that that the respective file or directory pattern, when there are no slashes in the pattern, seeks for any file anywhere in the tree with a matching basename. This is essentially the behavior when FILEPATHNAME and DIRPATHNAME is disabled, but with MATCHBASE , you can toggle the behavior by including slashes in your pattern. When we include no slashes: >>> wcmatch . WcMatch ( '.' , '*.md' , flags = wcmatch . FILEPATHNAME | wcmatch . GLOBSTAR | wcmatch . MATCHBASE | wcmatch . RECURSIVE ) . match () ['./LICENSE.md', './README.md', './docs/src/markdown/changelog.md', './docs/src/markdown/fnmatch.md', './docs/src/markdown/glob.md', './docs/src/markdown/index.md', './docs/src/markdown/license.md', './docs/src/markdown/wcmatch.md'] If we include slashes in the pattern, the path, not the basename, must match the pattern: >>> wcmatch . WcMatch ( '.' , 'docs/**/*.md' , flags = wcmatch . FILEPATHNAME | wcmatch . GLOBSTAR | wcmatch . MATCHBASE | wcmatch . RECURSIVE ) . match () ['./docs/src/markdown/changelog.md', './docs/src/markdown/fnmatch.md', './docs/src/markdown/glob.md', './docs/src/markdown/index.md', './docs/src/markdown/license.md', './docs/src/markdown/wcmatch.md'] If we have a leading slash, the pattern will not perform a match on the basename, but will instead be a normal path pattern that is anchored to the current base path, in this case . . >>> wcmatch . WcMatch ( '.' , '/*.md' , flags = wcmatch . FILEPATHNAME | wcmatch . GLOBSTAR | wcmatch . MATCHBASE | wcmatch . RECURSIVE ) . match () ['./LICENSE.md', './README.md']","title":"wcmatch.MATCHBASE, wcmatch.X"},{"location":"wcmatch/#globstar","text":"When the PATHNAME flag is provided, you can also enable GLOBSTAR to enable the recursive directory pattern matches with ** . >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt' , '**/markdown' , flags = wcmatch . DIRPATHNAME | wcmatch . GLOBSTAR | wcmatch . RECURSIVE ) . match () ['./LICENSE.md', './README.md', './requirements/docs.txt', './requirements/lint.txt', './requirements/setup.txt', './requirements/test.txt'] Identical patterns are only reduced by comparing case sensitively as POSIX character classes are case sensitive: [[:alnum:]] \u2260 [[:ALNUM:]] . \u21a9 \u21a9","title":"wcmatch.GLOBSTAR, wcmatch.G"},{"location":"about/changelog/","text":"Changelog 8.4 NEW : Drop support for Python 3.6. NEW : Switch to Hatch backend instead of Setuptools. NEW : Add new exclude option to fnmatch , pathlib , and glob methods that allows exclusion patterns to be specified directly without needing to enable NEGATE and prepend patterns with ! . exclude accepts a separate pattern or pattern list. exclude should not be used in conjunction with NEGATE . One or the other should be used. 8.3 NEW : Officially support Python 3.10. NEW : Provide type hints for API. FIX : Gracefully handle calls with an empty pattern list. 8.2 NEW : Add support for dir_fd in glob patterns. FIX : Small fix for Python 3.10 Beta 1 and pathlib . 8.1.2 FIX : fnmatch.translate no longer requires user to normalize their Windows paths for comparison. Previously, portions of the translate regex handled both / and \\\\ , while other portions did not. This inconsistent handling forced users to normalize paths for reliable matching. Now all of the generated regex should handle both / and \\\\ . FIX : On Linux/Unix systems, a backslash should not be assumed literal if it is followed by a forward slash. Backslash is magic on all systems, and an escaped forward slash is still counted as a forward slash, not a backslash and forward slash. FIX : A trailing backslash that is not escaped via another backslash should not be assumed as a backslash. Since it is escaping nothing, it will be ignored. Literal backslashes on any system must be escaped. 8.1.1 FIX : When tracking unique glob paths, the unique cache had inverted logic for case sensitive vs case insensitive comparison. ( #164 ) 8.1 NEW : Add is_magic function to the glob and fnmatch library. NEW : fnmatch now has escape available via its API. The fnmatch variant uses filename logic instead of path logic. NEW : Deprecate raw_escape in glob as it is very niche and the same can be accomplished simply by using codecs . decode ( string , 'unicode_escape' ) and then using escape . FIX : Use os.fspath to convert path-like objects to string/bytes, whatever the return from __fspath__ is what Wildcard Match will accept. Don't try to convert paths via __str__ or __bytes__ as not all path-like objects may implement both. FIX : Better checking of types to ensure consistent failure if the path, pattern, or root directory of are not all of type str or bytes . FIX : Some internal fixes and refactoring. FIX : Refactor code to take advantage of bracex 's ability to abort parsing on extremely large pattern expansions. Patterns like {1..10000000} will now abort dramatically quicker. Require bracex 2.1.1 which aborts much quicker. FIX : Fix some corner cases where limit would not abort correctly. 8.0.1 FIX : Small bug in [:alpha:] range. 8.0 NEW : WcMatch 's on_init hook now only accepts kwargs and not args . NEW : Cosmetic change of referring to the first __init__ parameter as root_dir instead of base . This is to make it more clear when we are talking about the overall root directory that all paths are relative to vs the base path of a file which is relative to the root directory and the actual file name. NEW : Internal attribute of WcMatch changed from base to _root_dir . This attribute is not really meant to be referenced by users and as been marked as private. NEW : Drop requirement for backrefs and update documentation to note that POSIX properties never actually enabled the use of Unicode properties. While the documentation stated this and it was probably intended, it was never actually enabled. Currently, Wildcard match has chosen to keep with the ASCII definition for now as it has been since the feature was introduced. This may change in the future if there is demand for it. NEW : Add [:word:] POSIX character class. 7.2 NEW : Drop Python 3.5 support. NEW : Formally support Python 3.9 support. FIX : Small fix for regular expression output to ensure NODIR pattern looks at both / and \\\\ on Windows. 7.1 NEW : Translate functions will now use capturing groups for EXTGLOB / EXTMATCH groups in the returned regular expression patterns. 7.0.1 FIX : Ensure that when using REALPATH that all symlinks are evaluated. FIX : Fix issue where an extended pattern pattern can't follow right behind an inverse extended pattern. FIX : Fix issues related to nested inverse glob patterns. 7.0 Check out Release Notes to learn more about upgrading to 7.0. NEW : Recognize extended UNC paths. NEW : Allow escaping any character in Windows drives for better compatibility with SPLIT and BRACE which requires a user to escape { , } and | to avoid expanding a pattern. NEW : raw_escape now accepts the raw_chars parameter so that translation of Python character back references can be disabled. NEW : Search functions that use scandir will not return . and .. for wildcard patterns that require iterating over a directory to match the files against a pattern. This matches Python's glob and is most likely what most users expect. Pattern matching logic is unaffected. NEW : Add SCANDOTDIR flag to enable previous behavior of injecting . and .. in scandir results. SCANDOTDIR has no affect on match functions such as globmatch which don't use directory scanning. NEW : Flag NODOTDIR has been added to disable patterns such as .* from matching . and .. . When enabled, matching logic is changed to require a literal pattern of . and .. to match the special directories . and .. . This is more Zsh like. FIX : Negative extended glob patterns ( !(...) ) incorrectly allowed for hidden files to be returned when one of the subpatterns started with . , even when DOTMATCH / DOTGLOB was not enabled. FIX : When NOUNIQUE is enabled and pathlib is being used, you could still get non-unique results across patterns expanded with BRACE or SPLIT (or even by simply providing a list of patterns). Ensure that unique results are only returned when NOUNIQUE is not enabled. FIX : Fix corner cases with escape and raw_escape with back slashes. FIX : Ensure that globmatch does not match test// with pattern test/* . FIX : pathlib.match should not evaluate symlinks that are on the left hand side of what was matched. 6.1 NEW : EXTMATCH / EXTGLOB can now be used with NEGATE without needing MINUSNEGATE . If a pattern starts with !( , and NEGATE and EXTMATCH / EXTGLOB are both enabled, the pattern will not be treated as a NEGATE pattern (even if !( doesn't yield a valid EXTGLOB pattern). To negate a pattern that starts with a literal ( , you must escape the bracket: !\\( . FIX : Support Python 3.9. FIX : Adjust pattern limit logic of glob to be consistent with other functions. 6.0.3 FIX : Fix issue where when FOLLOW and GLOBSTAR were used, a pattern like **/* would not properly match a directory which was a symlink. While Bash does not return a symlinked folder with ** , * (and other patterns), should properly find the symlinked directory. FIX : pathlib clearly states that the match method, if the pattern is relative, matches from the right. Wildcard Match used the same implementation that rglob used, which prepends **/ to a relative pattern. This is essentially like MATCHBASE , but allows for multiple directory levels. This means that dot files (and special folders such as . and .. ) on the left side could prevent the path from matching depending on flags that were set. match will now be evaluated in such a way as to give the same right to left matching feel that Python's pathlib uses. 6.0.2 FIX : Fix logic related to dot files and GLOBSTAR . Recursive directory search should return all dot files, which should then be filtered by the patterns. They should not be excluded before being filtered by the pattern. 6.0.1 FIX : If we only have one pattern (exclusion patterns not included) we can disable unique path filtering on returns as you cannot have a duplicate path with only one inclusion pattern. 6.0 NEW : Tilde user expansion support via the new GLOBTILDE flag. NEW : glob by default now returns only unique results, regardless of whether multiple patterns that match the same file were provided, or even when BRACE or SPLIT expansion produces new patterns that match the same file. NEW : A new flag called NOUNIQUE has been added that makes glob act like Bash, which will return the same file multiple times if multiple patterns match it, whether provided directly or due to the result of BRACE or SPLIT expansion. NEW : Limit number of patterns that can be processed (expanded and otherwise) to 1000. Allow user to change this value via an optional limit parameter in related API functions. FIX : Matching functions that receive multiple patterns, or that receive a single pattern that expands to multiple, will filter out duplicate patterns in order avoid redundant matching. While the WcMatch class crawls the file system, it utilizes the aforementioned matching functions in it's operation, and indirectly takes advantage of this. glob (and related functions: rglob , iglob , etc.) will also filter redundant patterns except when NOUNIQUE is enabled, this is so they can better act like Bash when NOUNIQUE is enabled. FIX : BRACE is now processed before SPLIT in order to fix a number of edge cases. FIX : RAWCHARS was inconsistently applied at different times depending on what was calling it. It is now applied first followed by BRACE , SPLIT , and finally GLOBTILDE . 5.1.0 NEW : Add new parameter to glob related functions (except in pathlib ) called root_dir that allows a user to specify a different working directory with either a string or path-like object. Path-like inputs are only supported on Python 3.6+. NEW : Support path-like objects for globmatch and globfilter path inputs. Path-like inputs are only supported on Python 3.6+. FIX : Filter functions should not alter the slashes of files it filters. Filtered strings and paths should be returned unaltered. 5.0.3 FIX : Rework glob relative path handling so internally it is indistinguishable from when it is given no relative path and uses the current working directory. This fixes an issue where pathlib couldn't handle negate patterns properly ( !negate ). 5.0.2 FIX : Fix case where a GLOBSTAR pattern, followed by a slash, was not disabling MATCHBASE . FIX : Fix pathlib relative path resolution in glob implementations. 5.0.1 FIX : In glob , avoid using up too many file descriptors by acquiring all file/folder names under a directory in one batch before recursing into other folders. 5.0 NEW : Add wcmatch.pathlib which contains pathlib variants that uses wcmatch.glob instead of the default Python glob. NEW : escape and raw_escape can manually be forced to use Windows or Linux/Unix logic via the keyword only argument by setting to False or True respectively. The default is None which will auto detect the system. NEW : The deprecated flag FORCECASE has now been removed. NEW : The deprecated functions globsplit and fnsplit have been removed. NEW : The deprecated variables version and version_info have been removed. 4.3.1 FIX : Regression for root level literal matches in glob . FIX : Bug where glob would mistakenly abort if a pattern started with a literal file or directory and could not match a file or directory. This caused subsequent patterns in the chain to not get evaluated. 4.3.0 NEW : Add CASE flag which allows for case sensitive paths on Linux, macOS, and Windows. Windows drive letters and UNC //host-name/share-name/ portion are still treated insensitively, but all directories will be treated with case sensitivity. NEW : With the recent addition of CASE and FORCEUNIX , FORCECASE is no longer needed. Deprecate FORCECASE which will be removed at some future point. 4.2.0 NEW : Drop Python 3.4 support. NEW : Add flags FORCEWIN and FORCEUNIX to force Windows or Linux/Unix path logic on commands that do not access the file system: translate , fnmatch , filter , globmatch , globfilter , etc. These flags will not work with glob , iglob or with the WcMatch class. It also will not work when using the REALPATH flag with things like fnmatch , filter , globmatch , globfilter . FIX : glob corner case where the first folder, if defined as a literal name (not a magic pattern), would not be treated properly if IGNORECASE was enabled in Linux. 4.1.0 NEW : Add WcMatch.is_aborted . FIX : Remove deprecation of kill and reset in WcMatch . There are legitimate reasons to not deprecate killing via kill instead of simply breaking. FIX : If for any reason, a file exists, but fails \"is directory\" check, consider it as a file. 4.0.1 FIX : Fix regression with exclusion patterns that use braces in glob . FIX : Translate functions should have NODIR patterns exclude if matched not exclude if not matched. 4.0 NEW : Deprecated WcMatch class methods kill and reset . WcMatch should be broken with a simple break statement instead. NEW : Add a new flag MARK to force glob to return directories with a trailing slash. NEW : Add MATCHBASE that causes glob glob related functions and WcMatch , when the pattern has no slashes in it, to seek for any file anywhere in the tree with a matching basename. NEW : Add NODIR that causes glob matchers and crawlers to only match and return files. NEW : Exclusion patterns (enabled with NEGATE ) now always enable DOTALL in the exclusion patterns. They also will match symlinks in ** patterns. Only non NEGATE patterns that are paired with a NEGATE pattern are subject to symlinks and dot rules. Exclusion patterns themselves allow dots and symlinks to make filtering easier. NEW : Exclusion patterns no longer provide a default inclusion pattern if one is not specified. Exclusion patterns are meant to filter the results of inclusion patterns. You can either use the SPLIT flag and provide an inclusion pattern with your default ('default_pattern|!exclusion'), or feed in a list of multiple patterns instead of a single string ( ['inclusion', '!exclusion'] ). If you really need the old behavior, you can use the NEGATEALL flag which will provide a default inclusion pattern that matches all files. NEW : Translate now outputs exclusion patterns so that if they match, the file is excluded. This is opposite logic to how it used to be, but is more efficient. FIX : An empty pattern in glob should not match slashes. 3.0.2 FIX : Fix an offset issue when processing an absolute path pattern in glob on Linux or macOS. FIX : Fix an issue where the glob command would use GLOBSTAR logic on ** even when GLOBSTAR was disabled. 3.0.1 FIX : In the WcMatch class, defer hidden file check until after the file or directory is compared against patterns to potentially avoid calling hidden if the pattern doesn't match. The reduced lstat calls improve performance. 3.0 NEW : globsplit and fnsplit have been deprecated. Users are encouraged to use the new SPLIT flag to allow functions to use multiple wildcard paths delimited by | . NEW : globmatch and globfilter will now parse provided paths as real paths if the new REALPATH flag is set. This has the advantage of allowing the commands to be aware of symlinks and properly apply related logic (whether to follow the links or not). It also helps to clarify ambiguous cases where it isn't clear if a file path references a directory because the trailing slash was omitted. It also allows the command to be aware of Windows drives evaluate the path in proper context compared to the current working directory. NEW : WcMatch class no longer accepts the recursive or show_hidden parameter, instead the RECURSIVE or HIDDEN flag must be used. NEW : WcMatch class now can search symlink directories with the new SYMLINK flag. NEW : glob and iglob functions now behave like Bash 5.0 in regards to symlinks in GLOBSTAR ( ** ). GLOBSTAR will ignore symlink directories. This affects other functions such as globmatch and globfilter when the REALPATH flag is enabled. NEW : New flag called FOLLOW was added to force related glob commands to recognize and follow symlink directories. FIX : Fix glob regression where inverse patterns such as !**/test/** would allow a directory base/test to match when it should have excluded it. FIX : glob should handle root paths ( / ) properly, and on Windows, it should assume the drive of the current working directory. 2.2.1 FIX : EXTMATCH / EXTGLOB should allow literal dots and should not treat dots like sequences do. FIX : Fix !(...) extended match patterns in glob and globmatch so that they properly match . and .. if their pattern starts with . . FIX : Fix !(...) extended match patterns so that they handle path separators correctly. FIX : Patterns such as ? or [.] should not trigger matching directories . and .. in glob and globmatch . 2.2.0 NEW : Officially support Python 3.8. 2.1.0 NEW : Deprecate version and version_info in favor of the more standard __version__ and __version_info__ . FIX : Fix issue where exclusion patterns would trigger before end of path. FIX : Fix GLOBSTAR regular expression pattern issues. 2.0.3 FIX : In glob , properly handle files in the current working directory when give a literal pattern that matches it. 2.0.2 FIX : wcmatch override events ( on_error and on_skip ) should verify the return is not None and not not falsy . 2.0.1 FIX : Can't install due to requirements being assigned to setup opposed to install. 2.0 Breaking Changes Version 2.0 introduces breaking changes in regards to flags. This is meant to bring about consistency amongst the provided libraries. Flag names have been changed in some cases, and logic has been inverted in some cases. NEW : Glob's NOBRACE , NOGLOBSTAR , and NOEXTGLOB flags are now BRACE , GLOBSTAR , and EXTGLOB and now enable the features instead of disabling the features. This logic matches the provided fnmatch and wcmatch . NEW : Glob's DOTGLOB and EXTGLOB also have the respective aliases DOTMATCH and EXTMATCH to provide consistent flags across provided libraries, but the GLOB variants that match Bash's feature names can still be used. NEW : fnmatch 's PERIOD flag has been replaced with DOTMATCH with inverted logic from what was originally provided. NEW : Documentation exposes the shorthand form of flags: FORCECASE \u2192 F , etc. FIX : Wcmatch always documented that it had the flag named EXTMATCH , but internally it was actually EXTGLOB , this was a bug though. EXTMATCH is now the documented and the actual flag to use. 1.0.2 FIX : Officially support Python 3.7. 1.0.1 FIX : Ensure that all patterns in glob that have a directory preceding ** but also end with ** returns the preceding directory. FIX : Fix byte conversion in path normalization. FIX : Ensure POSIX character classes, when at the start of a sequence, properly have hyphens escaped following it. [[:ascii:]-z] should convert to [\\x00-\\x7f\\\\-b] not [\\x00-\\x7f-b] . FIX : Fix an issue where we would fail because we couldn't covert raw characters even though raw character parsing was disabled. FIX : Better default for file patterns. Before if no pattern was provided for files, '*' was assumed, now it is '' , and if '' is used, all files will be matched. This works better for when full path is enabled as you get the same file matching logic. 1.0 Initial release","title":"Changelog"},{"location":"about/changelog/#changelog","text":"","title":"Changelog"},{"location":"about/changelog/#84","text":"NEW : Drop support for Python 3.6. NEW : Switch to Hatch backend instead of Setuptools. NEW : Add new exclude option to fnmatch , pathlib , and glob methods that allows exclusion patterns to be specified directly without needing to enable NEGATE and prepend patterns with ! . exclude accepts a separate pattern or pattern list. exclude should not be used in conjunction with NEGATE . One or the other should be used.","title":"8.4"},{"location":"about/changelog/#83","text":"NEW : Officially support Python 3.10. NEW : Provide type hints for API. FIX : Gracefully handle calls with an empty pattern list.","title":"8.3"},{"location":"about/changelog/#82","text":"NEW : Add support for dir_fd in glob patterns. FIX : Small fix for Python 3.10 Beta 1 and pathlib .","title":"8.2"},{"location":"about/changelog/#812","text":"FIX : fnmatch.translate no longer requires user to normalize their Windows paths for comparison. Previously, portions of the translate regex handled both / and \\\\ , while other portions did not. This inconsistent handling forced users to normalize paths for reliable matching. Now all of the generated regex should handle both / and \\\\ . FIX : On Linux/Unix systems, a backslash should not be assumed literal if it is followed by a forward slash. Backslash is magic on all systems, and an escaped forward slash is still counted as a forward slash, not a backslash and forward slash. FIX : A trailing backslash that is not escaped via another backslash should not be assumed as a backslash. Since it is escaping nothing, it will be ignored. Literal backslashes on any system must be escaped.","title":"8.1.2"},{"location":"about/changelog/#811","text":"FIX : When tracking unique glob paths, the unique cache had inverted logic for case sensitive vs case insensitive comparison. ( #164 )","title":"8.1.1"},{"location":"about/changelog/#81","text":"NEW : Add is_magic function to the glob and fnmatch library. NEW : fnmatch now has escape available via its API. The fnmatch variant uses filename logic instead of path logic. NEW : Deprecate raw_escape in glob as it is very niche and the same can be accomplished simply by using codecs . decode ( string , 'unicode_escape' ) and then using escape . FIX : Use os.fspath to convert path-like objects to string/bytes, whatever the return from __fspath__ is what Wildcard Match will accept. Don't try to convert paths via __str__ or __bytes__ as not all path-like objects may implement both. FIX : Better checking of types to ensure consistent failure if the path, pattern, or root directory of are not all of type str or bytes . FIX : Some internal fixes and refactoring. FIX : Refactor code to take advantage of bracex 's ability to abort parsing on extremely large pattern expansions. Patterns like {1..10000000} will now abort dramatically quicker. Require bracex 2.1.1 which aborts much quicker. FIX : Fix some corner cases where limit would not abort correctly.","title":"8.1"},{"location":"about/changelog/#801","text":"FIX : Small bug in [:alpha:] range.","title":"8.0.1"},{"location":"about/changelog/#80","text":"NEW : WcMatch 's on_init hook now only accepts kwargs and not args . NEW : Cosmetic change of referring to the first __init__ parameter as root_dir instead of base . This is to make it more clear when we are talking about the overall root directory that all paths are relative to vs the base path of a file which is relative to the root directory and the actual file name. NEW : Internal attribute of WcMatch changed from base to _root_dir . This attribute is not really meant to be referenced by users and as been marked as private. NEW : Drop requirement for backrefs and update documentation to note that POSIX properties never actually enabled the use of Unicode properties. While the documentation stated this and it was probably intended, it was never actually enabled. Currently, Wildcard match has chosen to keep with the ASCII definition for now as it has been since the feature was introduced. This may change in the future if there is demand for it. NEW : Add [:word:] POSIX character class.","title":"8.0"},{"location":"about/changelog/#72","text":"NEW : Drop Python 3.5 support. NEW : Formally support Python 3.9 support. FIX : Small fix for regular expression output to ensure NODIR pattern looks at both / and \\\\ on Windows.","title":"7.2"},{"location":"about/changelog/#71","text":"NEW : Translate functions will now use capturing groups for EXTGLOB / EXTMATCH groups in the returned regular expression patterns.","title":"7.1"},{"location":"about/changelog/#701","text":"FIX : Ensure that when using REALPATH that all symlinks are evaluated. FIX : Fix issue where an extended pattern pattern can't follow right behind an inverse extended pattern. FIX : Fix issues related to nested inverse glob patterns.","title":"7.0.1"},{"location":"about/changelog/#70","text":"Check out Release Notes to learn more about upgrading to 7.0. NEW : Recognize extended UNC paths. NEW : Allow escaping any character in Windows drives for better compatibility with SPLIT and BRACE which requires a user to escape { , } and | to avoid expanding a pattern. NEW : raw_escape now accepts the raw_chars parameter so that translation of Python character back references can be disabled. NEW : Search functions that use scandir will not return . and .. for wildcard patterns that require iterating over a directory to match the files against a pattern. This matches Python's glob and is most likely what most users expect. Pattern matching logic is unaffected. NEW : Add SCANDOTDIR flag to enable previous behavior of injecting . and .. in scandir results. SCANDOTDIR has no affect on match functions such as globmatch which don't use directory scanning. NEW : Flag NODOTDIR has been added to disable patterns such as .* from matching . and .. . When enabled, matching logic is changed to require a literal pattern of . and .. to match the special directories . and .. . This is more Zsh like. FIX : Negative extended glob patterns ( !(...) ) incorrectly allowed for hidden files to be returned when one of the subpatterns started with . , even when DOTMATCH / DOTGLOB was not enabled. FIX : When NOUNIQUE is enabled and pathlib is being used, you could still get non-unique results across patterns expanded with BRACE or SPLIT (or even by simply providing a list of patterns). Ensure that unique results are only returned when NOUNIQUE is not enabled. FIX : Fix corner cases with escape and raw_escape with back slashes. FIX : Ensure that globmatch does not match test// with pattern test/* . FIX : pathlib.match should not evaluate symlinks that are on the left hand side of what was matched.","title":"7.0"},{"location":"about/changelog/#61","text":"NEW : EXTMATCH / EXTGLOB can now be used with NEGATE without needing MINUSNEGATE . If a pattern starts with !( , and NEGATE and EXTMATCH / EXTGLOB are both enabled, the pattern will not be treated as a NEGATE pattern (even if !( doesn't yield a valid EXTGLOB pattern). To negate a pattern that starts with a literal ( , you must escape the bracket: !\\( . FIX : Support Python 3.9. FIX : Adjust pattern limit logic of glob to be consistent with other functions.","title":"6.1"},{"location":"about/changelog/#603","text":"FIX : Fix issue where when FOLLOW and GLOBSTAR were used, a pattern like **/* would not properly match a directory which was a symlink. While Bash does not return a symlinked folder with ** , * (and other patterns), should properly find the symlinked directory. FIX : pathlib clearly states that the match method, if the pattern is relative, matches from the right. Wildcard Match used the same implementation that rglob used, which prepends **/ to a relative pattern. This is essentially like MATCHBASE , but allows for multiple directory levels. This means that dot files (and special folders such as . and .. ) on the left side could prevent the path from matching depending on flags that were set. match will now be evaluated in such a way as to give the same right to left matching feel that Python's pathlib uses.","title":"6.0.3"},{"location":"about/changelog/#602","text":"FIX : Fix logic related to dot files and GLOBSTAR . Recursive directory search should return all dot files, which should then be filtered by the patterns. They should not be excluded before being filtered by the pattern.","title":"6.0.2"},{"location":"about/changelog/#601","text":"FIX : If we only have one pattern (exclusion patterns not included) we can disable unique path filtering on returns as you cannot have a duplicate path with only one inclusion pattern.","title":"6.0.1"},{"location":"about/changelog/#60","text":"NEW : Tilde user expansion support via the new GLOBTILDE flag. NEW : glob by default now returns only unique results, regardless of whether multiple patterns that match the same file were provided, or even when BRACE or SPLIT expansion produces new patterns that match the same file. NEW : A new flag called NOUNIQUE has been added that makes glob act like Bash, which will return the same file multiple times if multiple patterns match it, whether provided directly or due to the result of BRACE or SPLIT expansion. NEW : Limit number of patterns that can be processed (expanded and otherwise) to 1000. Allow user to change this value via an optional limit parameter in related API functions. FIX : Matching functions that receive multiple patterns, or that receive a single pattern that expands to multiple, will filter out duplicate patterns in order avoid redundant matching. While the WcMatch class crawls the file system, it utilizes the aforementioned matching functions in it's operation, and indirectly takes advantage of this. glob (and related functions: rglob , iglob , etc.) will also filter redundant patterns except when NOUNIQUE is enabled, this is so they can better act like Bash when NOUNIQUE is enabled. FIX : BRACE is now processed before SPLIT in order to fix a number of edge cases. FIX : RAWCHARS was inconsistently applied at different times depending on what was calling it. It is now applied first followed by BRACE , SPLIT , and finally GLOBTILDE .","title":"6.0"},{"location":"about/changelog/#510","text":"NEW : Add new parameter to glob related functions (except in pathlib ) called root_dir that allows a user to specify a different working directory with either a string or path-like object. Path-like inputs are only supported on Python 3.6+. NEW : Support path-like objects for globmatch and globfilter path inputs. Path-like inputs are only supported on Python 3.6+. FIX : Filter functions should not alter the slashes of files it filters. Filtered strings and paths should be returned unaltered.","title":"5.1.0"},{"location":"about/changelog/#503","text":"FIX : Rework glob relative path handling so internally it is indistinguishable from when it is given no relative path and uses the current working directory. This fixes an issue where pathlib couldn't handle negate patterns properly ( !negate ).","title":"5.0.3"},{"location":"about/changelog/#502","text":"FIX : Fix case where a GLOBSTAR pattern, followed by a slash, was not disabling MATCHBASE . FIX : Fix pathlib relative path resolution in glob implementations.","title":"5.0.2"},{"location":"about/changelog/#501","text":"FIX : In glob , avoid using up too many file descriptors by acquiring all file/folder names under a directory in one batch before recursing into other folders.","title":"5.0.1"},{"location":"about/changelog/#50","text":"NEW : Add wcmatch.pathlib which contains pathlib variants that uses wcmatch.glob instead of the default Python glob. NEW : escape and raw_escape can manually be forced to use Windows or Linux/Unix logic via the keyword only argument by setting to False or True respectively. The default is None which will auto detect the system. NEW : The deprecated flag FORCECASE has now been removed. NEW : The deprecated functions globsplit and fnsplit have been removed. NEW : The deprecated variables version and version_info have been removed.","title":"5.0"},{"location":"about/changelog/#431","text":"FIX : Regression for root level literal matches in glob . FIX : Bug where glob would mistakenly abort if a pattern started with a literal file or directory and could not match a file or directory. This caused subsequent patterns in the chain to not get evaluated.","title":"4.3.1"},{"location":"about/changelog/#430","text":"NEW : Add CASE flag which allows for case sensitive paths on Linux, macOS, and Windows. Windows drive letters and UNC //host-name/share-name/ portion are still treated insensitively, but all directories will be treated with case sensitivity. NEW : With the recent addition of CASE and FORCEUNIX , FORCECASE is no longer needed. Deprecate FORCECASE which will be removed at some future point.","title":"4.3.0"},{"location":"about/changelog/#420","text":"NEW : Drop Python 3.4 support. NEW : Add flags FORCEWIN and FORCEUNIX to force Windows or Linux/Unix path logic on commands that do not access the file system: translate , fnmatch , filter , globmatch , globfilter , etc. These flags will not work with glob , iglob or with the WcMatch class. It also will not work when using the REALPATH flag with things like fnmatch , filter , globmatch , globfilter . FIX : glob corner case where the first folder, if defined as a literal name (not a magic pattern), would not be treated properly if IGNORECASE was enabled in Linux.","title":"4.2.0"},{"location":"about/changelog/#410","text":"NEW : Add WcMatch.is_aborted . FIX : Remove deprecation of kill and reset in WcMatch . There are legitimate reasons to not deprecate killing via kill instead of simply breaking. FIX : If for any reason, a file exists, but fails \"is directory\" check, consider it as a file.","title":"4.1.0"},{"location":"about/changelog/#401","text":"FIX : Fix regression with exclusion patterns that use braces in glob . FIX : Translate functions should have NODIR patterns exclude if matched not exclude if not matched.","title":"4.0.1"},{"location":"about/changelog/#40","text":"NEW : Deprecated WcMatch class methods kill and reset . WcMatch should be broken with a simple break statement instead. NEW : Add a new flag MARK to force glob to return directories with a trailing slash. NEW : Add MATCHBASE that causes glob glob related functions and WcMatch , when the pattern has no slashes in it, to seek for any file anywhere in the tree with a matching basename. NEW : Add NODIR that causes glob matchers and crawlers to only match and return files. NEW : Exclusion patterns (enabled with NEGATE ) now always enable DOTALL in the exclusion patterns. They also will match symlinks in ** patterns. Only non NEGATE patterns that are paired with a NEGATE pattern are subject to symlinks and dot rules. Exclusion patterns themselves allow dots and symlinks to make filtering easier. NEW : Exclusion patterns no longer provide a default inclusion pattern if one is not specified. Exclusion patterns are meant to filter the results of inclusion patterns. You can either use the SPLIT flag and provide an inclusion pattern with your default ('default_pattern|!exclusion'), or feed in a list of multiple patterns instead of a single string ( ['inclusion', '!exclusion'] ). If you really need the old behavior, you can use the NEGATEALL flag which will provide a default inclusion pattern that matches all files. NEW : Translate now outputs exclusion patterns so that if they match, the file is excluded. This is opposite logic to how it used to be, but is more efficient. FIX : An empty pattern in glob should not match slashes.","title":"4.0"},{"location":"about/changelog/#302","text":"FIX : Fix an offset issue when processing an absolute path pattern in glob on Linux or macOS. FIX : Fix an issue where the glob command would use GLOBSTAR logic on ** even when GLOBSTAR was disabled.","title":"3.0.2"},{"location":"about/changelog/#301","text":"FIX : In the WcMatch class, defer hidden file check until after the file or directory is compared against patterns to potentially avoid calling hidden if the pattern doesn't match. The reduced lstat calls improve performance.","title":"3.0.1"},{"location":"about/changelog/#30","text":"NEW : globsplit and fnsplit have been deprecated. Users are encouraged to use the new SPLIT flag to allow functions to use multiple wildcard paths delimited by | . NEW : globmatch and globfilter will now parse provided paths as real paths if the new REALPATH flag is set. This has the advantage of allowing the commands to be aware of symlinks and properly apply related logic (whether to follow the links or not). It also helps to clarify ambiguous cases where it isn't clear if a file path references a directory because the trailing slash was omitted. It also allows the command to be aware of Windows drives evaluate the path in proper context compared to the current working directory. NEW : WcMatch class no longer accepts the recursive or show_hidden parameter, instead the RECURSIVE or HIDDEN flag must be used. NEW : WcMatch class now can search symlink directories with the new SYMLINK flag. NEW : glob and iglob functions now behave like Bash 5.0 in regards to symlinks in GLOBSTAR ( ** ). GLOBSTAR will ignore symlink directories. This affects other functions such as globmatch and globfilter when the REALPATH flag is enabled. NEW : New flag called FOLLOW was added to force related glob commands to recognize and follow symlink directories. FIX : Fix glob regression where inverse patterns such as !**/test/** would allow a directory base/test to match when it should have excluded it. FIX : glob should handle root paths ( / ) properly, and on Windows, it should assume the drive of the current working directory.","title":"3.0"},{"location":"about/changelog/#221","text":"FIX : EXTMATCH / EXTGLOB should allow literal dots and should not treat dots like sequences do. FIX : Fix !(...) extended match patterns in glob and globmatch so that they properly match . and .. if their pattern starts with . . FIX : Fix !(...) extended match patterns so that they handle path separators correctly. FIX : Patterns such as ? or [.] should not trigger matching directories . and .. in glob and globmatch .","title":"2.2.1"},{"location":"about/changelog/#220","text":"NEW : Officially support Python 3.8.","title":"2.2.0"},{"location":"about/changelog/#210","text":"NEW : Deprecate version and version_info in favor of the more standard __version__ and __version_info__ . FIX : Fix issue where exclusion patterns would trigger before end of path. FIX : Fix GLOBSTAR regular expression pattern issues.","title":"2.1.0"},{"location":"about/changelog/#203","text":"FIX : In glob , properly handle files in the current working directory when give a literal pattern that matches it.","title":"2.0.3"},{"location":"about/changelog/#202","text":"FIX : wcmatch override events ( on_error and on_skip ) should verify the return is not None and not not falsy .","title":"2.0.2"},{"location":"about/changelog/#201","text":"FIX : Can't install due to requirements being assigned to setup opposed to install.","title":"2.0.1"},{"location":"about/changelog/#20","text":"Breaking Changes Version 2.0 introduces breaking changes in regards to flags. This is meant to bring about consistency amongst the provided libraries. Flag names have been changed in some cases, and logic has been inverted in some cases. NEW : Glob's NOBRACE , NOGLOBSTAR , and NOEXTGLOB flags are now BRACE , GLOBSTAR , and EXTGLOB and now enable the features instead of disabling the features. This logic matches the provided fnmatch and wcmatch . NEW : Glob's DOTGLOB and EXTGLOB also have the respective aliases DOTMATCH and EXTMATCH to provide consistent flags across provided libraries, but the GLOB variants that match Bash's feature names can still be used. NEW : fnmatch 's PERIOD flag has been replaced with DOTMATCH with inverted logic from what was originally provided. NEW : Documentation exposes the shorthand form of flags: FORCECASE \u2192 F , etc. FIX : Wcmatch always documented that it had the flag named EXTMATCH , but internally it was actually EXTGLOB , this was a bug though. EXTMATCH is now the documented and the actual flag to use.","title":"2.0"},{"location":"about/changelog/#102","text":"FIX : Officially support Python 3.7.","title":"1.0.2"},{"location":"about/changelog/#101","text":"FIX : Ensure that all patterns in glob that have a directory preceding ** but also end with ** returns the preceding directory. FIX : Fix byte conversion in path normalization. FIX : Ensure POSIX character classes, when at the start of a sequence, properly have hyphens escaped following it. [[:ascii:]-z] should convert to [\\x00-\\x7f\\\\-b] not [\\x00-\\x7f-b] . FIX : Fix an issue where we would fail because we couldn't covert raw characters even though raw character parsing was disabled. FIX : Better default for file patterns. Before if no pattern was provided for files, '*' was assumed, now it is '' , and if '' is used, all files will be matched. This works better for when full path is enabled as you get the same file matching logic.","title":"1.0.1"},{"location":"about/changelog/#10","text":"Initial release","title":"1.0"},{"location":"about/contributing/","text":"Contributing & Support Become a Sponsor Open source projects take time and money. Help support the project by becoming a sponsor. You can add your support at any tier you feel comfortable with. No amount is too little. We also accept one time contributions via PayPal. GitHub Sponsors PayPal Bug Reports Please read the documentation and search the issue tracker to try and find the answer to your question before posting an issue. When creating an issue on the repository, please provide as much info as possible: Version being used. Operating system. Version of Python. Errors in console. Detailed description of the problem. Examples for reproducing the error. You can post pictures, but if specific text or code is required to reproduce the issue, please provide the text in a plain text format for easy copy/paste. The more info provided, the greater the chance someone will take the time to answer, implement, or fix the issue. Be prepared to answer questions and provide additional information if required. Issues in which the creator refuses to respond to follow up questions will be marked as stale and closed. Reviewing Code Take part in reviewing pull requests and/or reviewing direct commits. Make suggestions to improve the code and discuss solutions to overcome weakness in the algorithm. Answer Questions in Issues Take time and answer questions and offer suggestions to people who've created issues in the issue tracker. Often people will have questions that you might have an answer for. Or maybe you know how to help them accomplish a specific task they are asking about. Feel free to share your experience to help others out. Pull Requests Pull requests are welcome, and a great way to help fix bugs and add new features. Documentation Improvements A ton of time has been spent not only creating and supporting this tool and related extensions, but also spent making this documentation. If you feel it is still lacking, show your appreciation for the tool and/or extensions by helping to improve the documentation.","title":"Contributing &amp; Support"},{"location":"about/contributing/#contributing--support","text":"","title":"Contributing &amp; Support"},{"location":"about/contributing/#become-a-sponsor","text":"Open source projects take time and money. Help support the project by becoming a sponsor. You can add your support at any tier you feel comfortable with. No amount is too little. We also accept one time contributions via PayPal. GitHub Sponsors PayPal","title":"Become a Sponsor "},{"location":"about/contributing/#bug-reports","text":"Please read the documentation and search the issue tracker to try and find the answer to your question before posting an issue. When creating an issue on the repository, please provide as much info as possible: Version being used. Operating system. Version of Python. Errors in console. Detailed description of the problem. Examples for reproducing the error. You can post pictures, but if specific text or code is required to reproduce the issue, please provide the text in a plain text format for easy copy/paste. The more info provided, the greater the chance someone will take the time to answer, implement, or fix the issue. Be prepared to answer questions and provide additional information if required. Issues in which the creator refuses to respond to follow up questions will be marked as stale and closed.","title":"Bug Reports"},{"location":"about/contributing/#reviewing-code","text":"Take part in reviewing pull requests and/or reviewing direct commits. Make suggestions to improve the code and discuss solutions to overcome weakness in the algorithm.","title":"Reviewing Code"},{"location":"about/contributing/#answer-questions-in-issues","text":"Take time and answer questions and offer suggestions to people who've created issues in the issue tracker. Often people will have questions that you might have an answer for. Or maybe you know how to help them accomplish a specific task they are asking about. Feel free to share your experience to help others out.","title":"Answer Questions in Issues"},{"location":"about/contributing/#pull-requests","text":"Pull requests are welcome, and a great way to help fix bugs and add new features.","title":"Pull Requests"},{"location":"about/contributing/#documentation-improvements","text":"A ton of time has been spent not only creating and supporting this tool and related extensions, but also spent making this documentation. If you feel it is still lacking, show your appreciation for the tool and/or extensions by helping to improve the documentation.","title":"Documentation Improvements"},{"location":"about/license/","text":"License Wildcard Match MIT License Copyright \u00a9 2018 - 2022 Isaac Muse Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"about/license/#license","text":"","title":"License"},{"location":"about/license/#wildcard-match","text":"MIT License Copyright \u00a9 2018 - 2022 Isaac Muse Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"Wildcard Match"},{"location":"about/release/","text":"Release Notes Upgrade to 8.0 Notable changes are minor and will affect very few. This should clarify breaking changes and how to migrate if applicable. WcMatch class Initialization Hook The WcMatch class on_init hook was cleaned up. Prior to 8.0, it accepted both *args and **kwargs which is quite difficult to maintain and honestly for users to use. Moving forward, the WcMatch class will restrict all parameters to **kwargs . If you are using the on_init hook, you will simply need to change your override to accept arguments as **kwargs : # Excplicitly named def on_init ( self , key1 = value , key2 = value ): # Or just use `**kwargs` def on_init ( self , ** kwargs ): Lastly, only pass your custom variables in as keyword arguments: CustomWcmatch ( '.' , '*.md|*.txt' , flags = wcmatch . RECURSIVE , custom_key = value ) Upgrade to 7.0 Notable changes will be highlighted here to help with migration to 7.0. Globbing Special Directories File globbing with glob.glob , glob.iglob , pathlib.path.glob , and pathlib.Path.rglob no longer inject . and .. into results when scanning directories. This only affects the results of a scanned directory and does not fundamentally change how glob patterns evaluate a path. Python's default glob does not return . or .. for any \"magic\" (non-literal) patterns in glob . This is because magic patterns trigger glob to iterate over a directory in an attempt to find a file that can match the given \"magic\" pattern. Since . and .. are not returned by Python's implementation of scandir , . and .. never get evaluated. Literal patterns can side step the directory iteration with a simple check to see if the file exists. What this means is that a \"magic\" pattern of .* will not match . or .. , because it is not returned in the scan, but a literal pattern of . or .. will as the literal patterns are simply checked to see if they exist. This is common behavior for a number of libraries, Python, [node-glob], etc., but not all. Moving forward, we have chosen to adopt the Python's behavior as our default behavior, with the option of forcing Bash's behavior of returning . and .. in a directory scan if desired. These examples will illustrate the behavior. In the first example, Python's pathlib is used to glob a directory. We can note that not a single entry in the results is . or .. . >>> import pathlib >>> list ( pathlib . Path ( '.' ) . glob ( '.*' )) [PosixPath('.DS_Store'), PosixPath('.codecov.yml'), PosixPath('.tox'), PosixPath('.coverage'), PosixPath('.coveragerc'), PosixPath('.gitignore'), PosixPath('.github'), PosixPath('.pyspelling.yml'), PosixPath('.git')] We can also show that if we search for the literal pattern of .. that glob will then return .. in the results. >>> import pathlib >>> list ( pathlib . Path ( '.' ) . glob ( '..' )) [PosixPath('..')] When using the match function, we see that the pattern can match .. just fine. This illustrates that it is not the pattern logic that restricts this, but a result of the behavior exhibited by scandir . >>> import pathlib >>> pathlib . Path ( '..' ) . match ( '.*' ) True While our algorithm is different due to some of the features we support, and it may oversimplify things to say we now turn off injecting . and .. into scandir results, but for all intents and purposes, all of our file system globbing functions exhibit the same behavior as Python's default glob now. >>> from wcmatch import glob >>> glob . glob ( '.*' ) ['.DS_Store', '.codecov.yml', '.tox', '.coverage', '.coveragerc', '.gitignore', '.github', '.pyspelling.yml', '.git'] >>> glob . glob ( '..' ) ['..'] >>> glob . globmatch ( '..' , '.*' ) True Because this change only affects how files are returned when iterating the directories, we can notice that exclude patterns, which are used to filter the results, can match . or .. with .* : >>> from wcmatch import glob >>> glob . glob ( '..' ) ['..'] >>> glob . glob ([ '..' , '!.*' ], flags = glob . NEGATE ) [] If we want to modify the pattern matcher, and not just the the directory scanner, we can use the flag NODITDIR . >>> from wcmatch import glob >>> glob . glob ([ '..' , '!.*' ], flags = glob . NEGATE | glob . NODOTDIR ) ['..'] >>> glob . glob ([ '..' , '!..' ], flags = glob . NEGATE | glob . NODOTDIR ) [] These changes were done for a couple of reasons: Generally, it is rare to specifically want . and .. , so often when people glob with something like **/.* , they are just trying to get hidden files. While we generally model our behavior off Bash, there are many alternative shells (such as Zsh) that do not return or match . and .. with magic patterns by design, regardless of what directory scanner returns. Many people who come to use our library are probably coming from having experience with Python's glob. By mirroring this behavior out of the box, it may help people adapt to the library easier. Python's pathlib , which Wildcard Match's pathlib is derived from, normalizes paths by stripping out . directories and trimming off trailing slashes. This means patterns such as **/.* , which would normally match both .hidden and .hidden/. , would normalize those results to return two .hidden results. Mirroring this behavior helps provide more sane results and prevent confusing duplicates when using pathlib . This is not unique behavior to Python's glob and our implementation. For example, let's take a look at node-glob and its underlying match library called minimatch . > glob ( '.*' , {}, function ( er , files ) { ... console . log ( files ) ... }) > [ '.codecov.yml' , '.coverage' , '.coveragerc' , '.DS_Store' , '.git' , '.github' , '.gitignore' , '.pyspelling.yml' , '.tox' ] We also see that the file matching library has no issues matching . or .. with .* . > minimatch ( \"..\" , \".*\" ) true We can also see that ignore patterns, just like our ignore patterns, are applied to the results, and are unaffected by the underlying behavior of the directory scanner: > glob ( '..' , {}, function ( er , files ) { ... console . log ( files ) ... }) > [ '..' ] > glob ( '..' , { ignore : [ '.*' ]}, function ( er , files ) { ... console . log ( files ) ... }) > [] For the majority of people, this is most likely an improvement rather than a hindrance, but if the old behavior is desired, you can use the new option SCANDOTDIR which restores the logic that emulates the feel of scandir returning . and .. when iterating a directory. Due to the way pathlib normalizes paths, SCANDOTDIR is not recommended to be used with pathlib . Windows Drive Handling It is not practical to scan a system for all mounted drives and available network paths. Just like with Python's default globbing, we do not scan all available drives, and so wildcard patterns do not apply to these drives. Unfortunately, our implementation used to only handle very basic UNC cases, and if patterns with extended UNC paths were attempted, failure was likely. 7.0 brings improvements related to Windows drives and UNC paths. Glob patterns will now properly respect extended UNC paths such as //?/UNC/LOCALHOST/c$ and others. This means you can use these patterns without issues. And just like simple cases ( //server/mount ), extended cases do not require escaping meta characters, except when using pattern expansion syntax that is available via BRACE and SPLIT . Glob Escaping Because it can be problematic trying to mix Windows drives that use characters such as { and } with the BRACE flag, you can now escape these meta characters in drives if required. Prior to 7.0, such escaping was disallowed, but now you can safely escape { and } to ensure optimal brace handling. While you can safely escape other meta characters in drives as well, it is never actually needed. Additionally, glob.escape and glob.raw_escape will automatically escape { , } and | to avoid complications with BRACE and SPLIT . In general, a lot of corner cases with glob.escape and glob.raw_escape were cleaned up. glob.escape is meant to handle the escaping of normal paths so that they can be used in patterns. >>> glob . escape ( r 'my\\file-[work].txt' , unix = False ) 'my\\\\\\\\file\\\\-\\\\[work\\\\].txt' If you are accepting an input from a source that is giving you a representation of a Python string (where \\ is represented by two \\ ), then glob.raw_escape is what you want: >>> glob . raw_escape ( r 'my \\\\ file-[work].txt' , unix = False ) 'my\\\\\\\\file\\\\-\\\\[work\\\\].txt' By default, glob.raw_escape always translates Python character back references into actual characters, but if this is not needed, a new option called raw_chars ( True by default) has been added to disable this behavior: >>> glob . raw_escape ( r 'my \\\\ file-\\x31.txt' , unix = False ) 'my\\\\\\\\file\\\\-1.txt' >>> glob . raw_escape ( r 'my \\\\ file-\\x31.txt' , unix = False , raw_chars = False ) 'my\\\\\\\\file\\\\-\\\\\\\\x31.txt' Reduction of pathlib Duplicate Results In general, glob should return only unique results for a single inclusive pattern (exclusion patterns are not considered). If given multiple patterns, or if given a pattern that is expanded into multiple via BRACE or SPLIT , then duplicate results are actually possible. In 6.0, logic to strip redundant patterns and to filter out duplicate results was added. This deduping is performed by default if more than a single inclusive pattern is provided, even if they are indirectly provided via pattern expansion. The NOUNIQUE flag disables this behavior if desired. In general, this works well, but due to pathlib 's path normalization quirks, there were cases where duplicate results would still be returned for multiple patterns, and even a case where duplicates were returned for a single pattern. Due to pathlib file path normalization, . directories are stripped out, and trailing slashes are stripped off paths. With the changes noted in Globbing single pattern cases no longer return duplicate paths, but results across multiple patterns still could. For instance, it is possible that three different patterns, provided at the same time (or through pattern expansion) could match the following paths: file/./path , file/path/. , and file/path . Each of these results are unique as far as glob is concerned, but due to the pathlib normalization of . and trailing slashes, pathlib glob will return all three of these results as file/path , giving three identical results. In 7.0, logic was added to detect pathlib normalization cases and ensure that redundant results are not returned. >>> glob . glob ([ 'docs/./src' , 'docs/src/.' , 'docs/src' ]) ['docs/./src', 'docs/src/.', 'docs/src'] >>> list ( pathlib . Path ( '.' ) . glob ([ 'docs/./src' , 'docs/src/.' , 'docs/src' ])) [PosixPath('docs/src')] >>> list ( pathlib . Path ( '.' ) . glob ([ 'docs/./src' , 'docs/src/.' , 'docs/src' ], flags = pathlib . NOUNIQUE )) [PosixPath('docs/src'), PosixPath('docs/src'), PosixPath('docs/src')]","title":"Release Notes"},{"location":"about/release/#release-notes","text":"","title":"Release Notes"},{"location":"about/release/#wcmatch-class-initialization-hook","text":"The WcMatch class on_init hook was cleaned up. Prior to 8.0, it accepted both *args and **kwargs which is quite difficult to maintain and honestly for users to use. Moving forward, the WcMatch class will restrict all parameters to **kwargs . If you are using the on_init hook, you will simply need to change your override to accept arguments as **kwargs : # Excplicitly named def on_init ( self , key1 = value , key2 = value ): # Or just use `**kwargs` def on_init ( self , ** kwargs ): Lastly, only pass your custom variables in as keyword arguments: CustomWcmatch ( '.' , '*.md|*.txt' , flags = wcmatch . RECURSIVE , custom_key = value )","title":"WcMatch class Initialization Hook"},{"location":"about/release/#globbing-special-directories","text":"File globbing with glob.glob , glob.iglob , pathlib.path.glob , and pathlib.Path.rglob no longer inject . and .. into results when scanning directories. This only affects the results of a scanned directory and does not fundamentally change how glob patterns evaluate a path. Python's default glob does not return . or .. for any \"magic\" (non-literal) patterns in glob . This is because magic patterns trigger glob to iterate over a directory in an attempt to find a file that can match the given \"magic\" pattern. Since . and .. are not returned by Python's implementation of scandir , . and .. never get evaluated. Literal patterns can side step the directory iteration with a simple check to see if the file exists. What this means is that a \"magic\" pattern of .* will not match . or .. , because it is not returned in the scan, but a literal pattern of . or .. will as the literal patterns are simply checked to see if they exist. This is common behavior for a number of libraries, Python, [node-glob], etc., but not all. Moving forward, we have chosen to adopt the Python's behavior as our default behavior, with the option of forcing Bash's behavior of returning . and .. in a directory scan if desired. These examples will illustrate the behavior. In the first example, Python's pathlib is used to glob a directory. We can note that not a single entry in the results is . or .. . >>> import pathlib >>> list ( pathlib . Path ( '.' ) . glob ( '.*' )) [PosixPath('.DS_Store'), PosixPath('.codecov.yml'), PosixPath('.tox'), PosixPath('.coverage'), PosixPath('.coveragerc'), PosixPath('.gitignore'), PosixPath('.github'), PosixPath('.pyspelling.yml'), PosixPath('.git')] We can also show that if we search for the literal pattern of .. that glob will then return .. in the results. >>> import pathlib >>> list ( pathlib . Path ( '.' ) . glob ( '..' )) [PosixPath('..')] When using the match function, we see that the pattern can match .. just fine. This illustrates that it is not the pattern logic that restricts this, but a result of the behavior exhibited by scandir . >>> import pathlib >>> pathlib . Path ( '..' ) . match ( '.*' ) True While our algorithm is different due to some of the features we support, and it may oversimplify things to say we now turn off injecting . and .. into scandir results, but for all intents and purposes, all of our file system globbing functions exhibit the same behavior as Python's default glob now. >>> from wcmatch import glob >>> glob . glob ( '.*' ) ['.DS_Store', '.codecov.yml', '.tox', '.coverage', '.coveragerc', '.gitignore', '.github', '.pyspelling.yml', '.git'] >>> glob . glob ( '..' ) ['..'] >>> glob . globmatch ( '..' , '.*' ) True Because this change only affects how files are returned when iterating the directories, we can notice that exclude patterns, which are used to filter the results, can match . or .. with .* : >>> from wcmatch import glob >>> glob . glob ( '..' ) ['..'] >>> glob . glob ([ '..' , '!.*' ], flags = glob . NEGATE ) [] If we want to modify the pattern matcher, and not just the the directory scanner, we can use the flag NODITDIR . >>> from wcmatch import glob >>> glob . glob ([ '..' , '!.*' ], flags = glob . NEGATE | glob . NODOTDIR ) ['..'] >>> glob . glob ([ '..' , '!..' ], flags = glob . NEGATE | glob . NODOTDIR ) [] These changes were done for a couple of reasons: Generally, it is rare to specifically want . and .. , so often when people glob with something like **/.* , they are just trying to get hidden files. While we generally model our behavior off Bash, there are many alternative shells (such as Zsh) that do not return or match . and .. with magic patterns by design, regardless of what directory scanner returns. Many people who come to use our library are probably coming from having experience with Python's glob. By mirroring this behavior out of the box, it may help people adapt to the library easier. Python's pathlib , which Wildcard Match's pathlib is derived from, normalizes paths by stripping out . directories and trimming off trailing slashes. This means patterns such as **/.* , which would normally match both .hidden and .hidden/. , would normalize those results to return two .hidden results. Mirroring this behavior helps provide more sane results and prevent confusing duplicates when using pathlib . This is not unique behavior to Python's glob and our implementation. For example, let's take a look at node-glob and its underlying match library called minimatch . > glob ( '.*' , {}, function ( er , files ) { ... console . log ( files ) ... }) > [ '.codecov.yml' , '.coverage' , '.coveragerc' , '.DS_Store' , '.git' , '.github' , '.gitignore' , '.pyspelling.yml' , '.tox' ] We also see that the file matching library has no issues matching . or .. with .* . > minimatch ( \"..\" , \".*\" ) true We can also see that ignore patterns, just like our ignore patterns, are applied to the results, and are unaffected by the underlying behavior of the directory scanner: > glob ( '..' , {}, function ( er , files ) { ... console . log ( files ) ... }) > [ '..' ] > glob ( '..' , { ignore : [ '.*' ]}, function ( er , files ) { ... console . log ( files ) ... }) > [] For the majority of people, this is most likely an improvement rather than a hindrance, but if the old behavior is desired, you can use the new option SCANDOTDIR which restores the logic that emulates the feel of scandir returning . and .. when iterating a directory. Due to the way pathlib normalizes paths, SCANDOTDIR is not recommended to be used with pathlib .","title":"Globbing Special Directories"},{"location":"about/release/#windows-drive-handling","text":"It is not practical to scan a system for all mounted drives and available network paths. Just like with Python's default globbing, we do not scan all available drives, and so wildcard patterns do not apply to these drives. Unfortunately, our implementation used to only handle very basic UNC cases, and if patterns with extended UNC paths were attempted, failure was likely. 7.0 brings improvements related to Windows drives and UNC paths. Glob patterns will now properly respect extended UNC paths such as //?/UNC/LOCALHOST/c$ and others. This means you can use these patterns without issues. And just like simple cases ( //server/mount ), extended cases do not require escaping meta characters, except when using pattern expansion syntax that is available via BRACE and SPLIT .","title":"Windows Drive Handling"},{"location":"about/release/#glob-escaping","text":"Because it can be problematic trying to mix Windows drives that use characters such as { and } with the BRACE flag, you can now escape these meta characters in drives if required. Prior to 7.0, such escaping was disallowed, but now you can safely escape { and } to ensure optimal brace handling. While you can safely escape other meta characters in drives as well, it is never actually needed. Additionally, glob.escape and glob.raw_escape will automatically escape { , } and | to avoid complications with BRACE and SPLIT . In general, a lot of corner cases with glob.escape and glob.raw_escape were cleaned up. glob.escape is meant to handle the escaping of normal paths so that they can be used in patterns. >>> glob . escape ( r 'my\\file-[work].txt' , unix = False ) 'my\\\\\\\\file\\\\-\\\\[work\\\\].txt' If you are accepting an input from a source that is giving you a representation of a Python string (where \\ is represented by two \\ ), then glob.raw_escape is what you want: >>> glob . raw_escape ( r 'my \\\\ file-[work].txt' , unix = False ) 'my\\\\\\\\file\\\\-\\\\[work\\\\].txt' By default, glob.raw_escape always translates Python character back references into actual characters, but if this is not needed, a new option called raw_chars ( True by default) has been added to disable this behavior: >>> glob . raw_escape ( r 'my \\\\ file-\\x31.txt' , unix = False ) 'my\\\\\\\\file\\\\-1.txt' >>> glob . raw_escape ( r 'my \\\\ file-\\x31.txt' , unix = False , raw_chars = False ) 'my\\\\\\\\file\\\\-\\\\\\\\x31.txt'","title":"Glob Escaping"},{"location":"about/release/#reduction-of-pathlib-duplicate-results","text":"In general, glob should return only unique results for a single inclusive pattern (exclusion patterns are not considered). If given multiple patterns, or if given a pattern that is expanded into multiple via BRACE or SPLIT , then duplicate results are actually possible. In 6.0, logic to strip redundant patterns and to filter out duplicate results was added. This deduping is performed by default if more than a single inclusive pattern is provided, even if they are indirectly provided via pattern expansion. The NOUNIQUE flag disables this behavior if desired. In general, this works well, but due to pathlib 's path normalization quirks, there were cases where duplicate results would still be returned for multiple patterns, and even a case where duplicates were returned for a single pattern. Due to pathlib file path normalization, . directories are stripped out, and trailing slashes are stripped off paths. With the changes noted in Globbing single pattern cases no longer return duplicate paths, but results across multiple patterns still could. For instance, it is possible that three different patterns, provided at the same time (or through pattern expansion) could match the following paths: file/./path , file/path/. , and file/path . Each of these results are unique as far as glob is concerned, but due to the pathlib normalization of . and trailing slashes, pathlib glob will return all three of these results as file/path , giving three identical results. In 7.0, logic was added to detect pathlib normalization cases and ensure that redundant results are not returned. >>> glob . glob ([ 'docs/./src' , 'docs/src/.' , 'docs/src' ]) ['docs/./src', 'docs/src/.', 'docs/src'] >>> list ( pathlib . Path ( '.' ) . glob ([ 'docs/./src' , 'docs/src/.' , 'docs/src' ])) [PosixPath('docs/src')] >>> list ( pathlib . Path ( '.' ) . glob ([ 'docs/./src' , 'docs/src/.' , 'docs/src' ], flags = pathlib . NOUNIQUE )) [PosixPath('docs/src'), PosixPath('docs/src'), PosixPath('docs/src')]","title":"Reduction of pathlib Duplicate Results"}]}